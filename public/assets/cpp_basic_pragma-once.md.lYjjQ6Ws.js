import{_ as a,c as s,o as i,R as e}from"./chunks/framework.2bglP9T5.js";const m=JSON.parse('{"title":"#pragma once","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/pragma-once.md","filePath":"cpp/basic/pragma-once.md"}'),n={name:"cpp/basic/pragma-once.md"},l=e(`<h1 id="pragma-once" tabindex="-1">#pragma once <a class="header-anchor" href="#pragma-once" aria-label="Permalink to &quot;#pragma once&quot;">​</a></h1><p>在 <code>#pragma once</code> 出现之前，C++程序员通常使用宏定义来防止头文件被重复包含。这种做法被称为 &quot;include guards&quot; 或 &quot;header guards&quot;。下面我会通过一个具体的例子来说明在有和没有 <code>#pragma once</code> 的情况下，这些问题是如何被处理的。</p><h3 id="_1-没有-pragma-once-的情况" tabindex="-1">1. 没有 <code>#pragma once</code> 的情况 <a class="header-anchor" href="#_1-没有-pragma-once-的情况" aria-label="Permalink to &quot;1. 没有 \`#pragma once\` 的情况&quot;">​</a></h3><p>假设我们有一个名为 <code>myheader.h</code> 的头文件。在没有 <code>#pragma once</code> 的情况下，为了防止头文件内容被重复包含，我们需要使用宏定义来创建一个包含防护。这通常是这样做的：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// myheader.h</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">ifndef</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> MYHEADER_H</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">define</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> MYHEADER_H</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 头文件内容</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> myFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">endif</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // MYHEADER_H</span></span></code></pre></div><p>在这个例子中：</p><ul><li><code>#ifndef MYHEADER_H</code> 检查 <code>MYHEADER_H</code> 是否未定义。</li><li><code>#define MYHEADER_H</code> 定义宏，以便后续的编译过程中 <code>#ifndef</code> 检查失败，防止重复包含。</li><li><code>#endif</code> 结束预处理器条件。</li></ul><h4 id="存在的问题" tabindex="-1">存在的问题 <a class="header-anchor" href="#存在的问题" aria-label="Permalink to &quot;存在的问题&quot;">​</a></h4><ol><li><strong>手动管理宏</strong>：每个头文件都需要一个唯一的宏名，这增加了开发的复杂性。</li><li><strong>命名冲突</strong>：如果不小心重复使用了宏名，可能会导致错误。</li><li><strong>编译器依赖</strong>：不同的编译器可能对宏的处理方式有所不同，影响代码的可移植性。</li></ol><h3 id="_2-有-pragma-once-的情况" tabindex="-1">2. 有 <code>#pragma once</code> 的情况 <a class="header-anchor" href="#_2-有-pragma-once-的情况" aria-label="Permalink to &quot;2. 有 \`#pragma once\` 的情况&quot;">​</a></h3><p><code>#pragma once</code> 是一个预处理器指令，用于告诉编译器当前头文件只需在单个编译中包含一次。对于同一个头文件，即使它在多个文件中被包含，也只会被处理一次。我们修改上面的例子如下：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// myheader.h</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">pragma</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> once</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 头文件内容</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> myFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre></div><h4 id="解决的问题" tabindex="-1">解决的问题 <a class="header-anchor" href="#解决的问题" aria-label="Permalink to &quot;解决的问题&quot;">​</a></h4><ol><li><strong>简化处理</strong>：不需要定义和维护宏。</li><li><strong>避免冲突</strong>：不再依赖于宏的唯一性，减少了命名冲突的风险。</li><li><strong>提高效率</strong>：在某些情况下，<code>#pragma once</code> 可以减少编译器的工作量，提高编译效率。</li></ol><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>尽管 <code>#pragma once</code> 在很多现代编译器中被广泛支持，并且为防止头文件重复包含提供了一种更简洁的方式，但它并不是C++标准的一部分。因此，在跨平台或使用不同编译器的项目中，使用传统的宏定义包含防护仍然是一种更安全的做法。</p>`,16),t=[l];function p(o,h,c,d,r,k){return i(),s("div",null,t)}const _=a(n,[["render",p]]);export{m as __pageData,_ as default};
