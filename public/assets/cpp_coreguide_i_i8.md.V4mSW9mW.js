import{_ as e,c as a,o as r,R as t}from"./chunks/framework.2bglP9T5.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/coreguide/i/i8.md","filePath":"cpp/coreguide/i/i8.md"}'),o={name:"cpp/coreguide/i/i8.md"},s=t(`<h3 id="i-8-优先使用-ensures-来表达后条件" tabindex="-1"><a name="Ri-ensures"></a>I.8: 优先使用 <code>Ensures()</code> 来表达后条件 <a class="header-anchor" href="#i-8-优先使用-ensures-来表达后条件" aria-label="Permalink to &quot;&lt;a name=&quot;Ri-ensures&quot;&gt;&lt;/a&gt;I.8: 优先使用 \`Ensures()\` 来表达后条件&quot;">​</a></h3><h5 id="理由" tabindex="-1">理由 <a class="header-anchor" href="#理由" aria-label="Permalink to &quot;理由&quot;">​</a></h5><p>清晰地表明这个条件是一个后条件，并便于工具的利用。</p><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><pre><code>void f()
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
}
</code></pre><h5 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>后条件是可以用许多方式来说明的，包括代码注释，<code>if</code> 语句，以及 <code>assert()</code>。 这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。</p><p><strong>替代方案</strong>: 如“这个资源必须被释放”这样形式的后条件最好以 <a href="#Rr-raii">RAII</a> 的方式来表达。</p><h5 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h5><p>理想情况下，<code>Ensures</code> 应当是接口的一部分，但我们无法轻易做到这点。 当前，我们将之放入定义式（函数体）之中。 一旦语言支持变为可用（例如，参见<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf" target="_blank" rel="noreferrer">契约提案</a>），我们就将会采用前条件，后条件和断言的标准版本。</p><h5 id="强制实施" tabindex="-1">强制实施 <a class="header-anchor" href="#强制实施" aria-label="Permalink to &quot;强制实施&quot;">​</a></h5><p>【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 <code>assert()</code>）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。</p>`,12),n=[s];function i(c,d,h,l,p,u){return r(),a("div",null,n)}const m=e(o,[["render",i]]);export{f as __pageData,m as default};
