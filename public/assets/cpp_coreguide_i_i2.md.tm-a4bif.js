import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/coreguide/i/i2.md","filePath":"cpp/coreguide/i/i2.md"}'),t={name:"cpp/coreguide/i/i2.md"},e=n(`<h3 id="i-2-避免非-const-全局变量" tabindex="-1"><a name="Ri-global"></a>I.2: 避免非 <code>const</code> 全局变量 <a class="header-anchor" href="#i-2-避免非-const-全局变量" aria-label="Permalink to &quot;&lt;a name=&quot;Ri-global&quot;&gt;&lt;/a&gt;I.2: 避免非 \`const\` 全局变量&quot;">​</a></h3><h5 id="理由" tabindex="-1">理由 <a class="header-anchor" href="#理由" aria-label="Permalink to &quot;理由&quot;">​</a></h5><p>非 <code>const</code> 全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。</p><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><pre><code>struct Data {
    // ... 大量成员 ...
} data;            //  非 const 数据

void compute()     // 请勿这样做
{
    // ... 使用 data ...
}

void output()     // 请勿这样做
{
    // ... 使用 data ...
}
</code></pre><p>哪个可能会修改 <code>data</code> 呢？</p><p><strong>警告</strong>: 全局对象的初始化并不是完全有序的。 当使用全局对象时，应当用常量为之初始化。 还要注意，即便对于 <code>const</code> 对象，也可能发生未定义的初始化顺序。</p><h5 id="例外" tabindex="-1">例外 <a class="header-anchor" href="#例外" aria-label="Permalink to &quot;例外&quot;">​</a></h5><p>全局对象通常优于单例。</p><h5 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>全局常量是有益的。</p><h5 id="注解-1" tabindex="-1">注解 <a class="header-anchor" href="#注解-1" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>针对全局变量的规则同样适用于命名空间作用域的变量。</p><p><strong>替代方案</strong>: 如果你用全局（或者更一般地说命名空间作用域）数据来避免复制操作的话，请考虑把数据以 <code>const</code> 引用的形式进行传递的方案。 另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。</p><p><strong>警告</strong>: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。 指向可变数据的每个指针或引用都是潜在的数据竞争。</p><p>使用全局指针或引用来访问和修改非 const 且非局部的数据，并非是比非 const 全局变量更好的替代方案， 这是因为它并不能解决隐藏依赖性或潜在竞争条件的问题。</p><h5 id="注解-2" tabindex="-1">注解 <a class="header-anchor" href="#注解-2" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>不可变数据是不会带来数据竞争条件的。</p><p><strong>参见</strong>: 另见<a href="#SS-call">关于调用函数的规则</a>。</p><h4 id="注解-3" tabindex="-1">注解 <a class="header-anchor" href="#注解-3" aria-label="Permalink to &quot;注解&quot;">​</a></h4><p>这条规则是“避免”，而不是“不要用”。当然是有（罕见）例外的，比如 <code>cin</code>、<code>cout</code> 和 <code>cerr</code>。</p><h5 id="强制实施" tabindex="-1">强制实施 <a class="header-anchor" href="#强制实施" aria-label="Permalink to &quot;强制实施&quot;">​</a></h5><p>【简单】 报告所有在命名空间作用域中声明的非 <code>const</code> 变量和全局的指向非 const 数据的指针/引用。</p><p>为了深入解释和对比为什么避免非 <code>const</code> 全局变量是一个好实践，我们可以通过比较两个具体的编程例子来理解这一点：一个使用非 <code>const</code> 全局变量，另一个避免使用它们。这种比较能够更清晰地展示使用非 <code>const</code> 全局变量可能带来的问题，以及通过其他方式管理依赖和状态可以带来的好处。</p><h3 id="使用非-const-全局变量的例子" tabindex="-1">使用非 <code>const</code> 全局变量的例子 <a class="header-anchor" href="#使用非-const-全局变量的例子" aria-label="Permalink to &quot;使用非 \`const\` 全局变量的例子&quot;">​</a></h3><p>假设我们正在开发一个游戏，其中有一个全局变量用于跟踪玩家的总分数：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> totalScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 非 const 全局变量</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> addScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> score</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    totalScore </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> score</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 修改全局变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> resetScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    totalScore </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 也修改全局变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在这个例子中，<code>totalScore</code> 是一个非 <code>const</code> 全局变量，它被多个函数修改。这样的设计有几个问题：</p><ul><li><strong>隐藏的依赖关系</strong>：<code>addScore</code> 和 <code>resetScore</code> 函数的行为依赖于全局变量 <code>totalScore</code>。这个依赖关系在函数签名中并不明显，使得理解和维护代码变得更加困难。</li><li><strong>不可预测的变动</strong>：任何部分的代码都可能修改 <code>totalScore</code>，导致调试和跟踪问题变得复杂。</li><li><strong>并发问题</strong>：如果在多线程环境中，不同的线程试图同时修改 <code>totalScore</code>，可能会导致数据竞争和不一致的状态。</li></ul><h3 id="避免非-const-全局变量的替代方案" tabindex="-1">避免非 <code>const</code> 全局变量的替代方案 <a class="header-anchor" href="#避免非-const-全局变量的替代方案" aria-label="Permalink to &quot;避免非 \`const\` 全局变量的替代方案&quot;">​</a></h3><p>作为替代，我们可以将数据封装在一个类中，并通过成员函数来管理状态：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ScoreKeeper</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> addScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> score</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        totalScore </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> score</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> resetScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        totalScore </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getTotalScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> const</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> totalScore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> totalScore </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 封装在类内部</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre></div><p>在这个改进的设计中：</p><ul><li><strong>明确的依赖关系</strong>：<code>ScoreKeeper</code> 类明确管理着分数的状态，任何对分数的修改都通过其成员函数进行，这使得依赖关系变得清晰。</li><li><strong>控制变动</strong>：分数的修改被限制在类的成员函数内，减少了意外修改的风险。</li><li><strong>更好的并发控制</strong>：通过使用适当的同步机制（例如锁），<code>ScoreKeeper</code> 可以安全地在多线程环境中使用，减少数据竞争的风险。</li></ul><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>通过比较，我们可以看到避免非 <code>const</code> 全局变量并采用封装的方式管理状态和依赖关系，不仅可以使代码更加清晰和可维护，而且还能提高代码的安全性和稳定性。这就是为什么在现代C++编程实践中，推荐使用类和对象来管理状态，而避免使用非 <code>const</code> 全局变量的原因。</p>`,36),l=[e];function h(p,k,o,r,d,c){return a(),i("div",null,l)}const A=s(t,[["render",h]]);export{y as __pageData,A as default};
