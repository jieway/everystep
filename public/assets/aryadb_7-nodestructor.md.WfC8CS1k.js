import{_ as s,c as i,o as a,R as e}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"NoDestructor","description":"","frontmatter":{},"headers":[],"relativePath":"aryadb/7-nodestructor.md","filePath":"aryadb/7-nodestructor.md"}'),t={name:"aryadb/7-nodestructor.md"},n=e(`<h1 id="nodestructor" tabindex="-1">NoDestructor <a class="header-anchor" href="#nodestructor" aria-label="Permalink to &quot;NoDestructor&quot;">​</a></h1><p>其主要功能是创建并管理一个类型为 <code>InstanceType</code> 的对象实例，同时确保该实例的析构函数永远不会被调用。这主要用于管理函数级静态变量的生命周期，特别是在需要确保静态变量在整个程序运行期间一直存在时。</p><p>在 LevelDB 中，<code>NoDestructor</code> 类型的使用主要集中在两个方面：管理单例模式的实例和处理全局静态对象的生命周期。</p><h3 id="_1-管理单例模式的实例" tabindex="-1">1. 管理单例模式的实例 <a class="header-anchor" href="#_1-管理单例模式的实例" aria-label="Permalink to &quot;1. 管理单例模式的实例&quot;">​</a></h3><p>在 LevelDB 中，有些组件或服务可能被设计为单例，即整个程序运行期间只存在一个实例。使用 <code>NoDestructor</code> 可以确保这些单例对象在程序的整个生命周期内都有效，并且它们的析构函数不会在程序退出时被调用。这对于那些需要跨越整个程序生命周期的资源非常有用。</p><h3 id="_2-处理全局静态对象" tabindex="-1">2. 处理全局静态对象 <a class="header-anchor" href="#_2-处理全局静态对象" aria-label="Permalink to &quot;2. 处理全局静态对象&quot;">​</a></h3><p>对于全局静态对象，特别是那些在程序的多个部分中使用，且其析构顺序可能会引起问题的对象，使用 <code>NoDestructor</code> 是一个解决方案。由于全局静态对象的析构通常在程序退出时发生，而这时候一些依赖的资源可能已经被释放，使用 <code>NoDestructor</code> 可以避免在程序退出时对这些已经不再有效的资源进行操作。</p><h3 id="_3-具体应用示例" tabindex="-1">3. 具体应用示例 <a class="header-anchor" href="#_3-具体应用示例" aria-label="Permalink to &quot;3. 具体应用示例&quot;">​</a></h3><p>具体在 LevelDB 源码中 <code>NoDestructor</code> 的应用可能涉及以下几个方面：</p><ul><li><strong>配置管理</strong>：对于全局的配置对象，使用 <code>NoDestructor</code> 管理可以确保在程序的任何地方都能安全地访问配置。</li><li><strong>日志系统</strong>：日志系统可能在程序的整个生命周期中都需要使用。<code>NoDestructor</code> 可以用来确保日志系统不会过早地被析构。</li><li><strong>内存分配器</strong>：自定义的内存分配器，如果被设计为全局对象，可能会使用 <code>NoDestructor</code> 来管理。</li></ul><h3 id="_4-功能和实现" tabindex="-1">4. 功能和实现 <a class="header-anchor" href="#_4-功能和实现" aria-label="Permalink to &quot;4. 功能和实现&quot;">​</a></h3><ul><li><p><strong>功能</strong>： <code>NoDestructor</code> 类的目的是创建一个 <code>InstanceType</code> 类型的对象，同时避免其析构函数在程序结束时自动被调用。这对于管理静态资源、单例模式或者对析构顺序有特殊要求的资源非常有用。</p></li><li><p><strong>实现方式</strong>： <code>NoDestructor</code> 类内部使用了 <code>std::aligned_storage</code> 来分配足够的内存空间来存储 <code>InstanceType</code> 类型的对象。这种方式保证了所分配的内存具有合适的大小和对齐要求。对象是通过“placement new”在这块预分配的内存上构造的，这意味着对象实际上是在 <code>NoDestructor</code> 实例的内存区域内构造的。</p></li></ul><h3 id="_5-使用示例" tabindex="-1">5. 使用示例 <a class="header-anchor" href="#_5-使用示例" aria-label="Permalink to &quot;5. 使用示例&quot;">​</a></h3><p>假设有一个简单的类 <code>Example</code>，我们不希望其析构函数在程序结束时被调用：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    Example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example Constructor</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    ~Example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example Destructor</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> function</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> NoDestructor</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Example</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> no_destruct_example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    Example</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> examplePtr </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> no_destruct_example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 在这里，Example 的实例已经被创建，</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 但其析构函数不会在 function() 结束时被调用</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    function</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 程序退出时，Example 的析构函数不会被调用</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在这个例子中，<code>NoDestructor&lt;Example&gt;</code> 创建了一个 <code>Example</code> 类型的对象，但由于 <code>NoDestructor</code> 的设计，<code>Example</code> 的析构函数不会在 <code>function()</code> 结束或程序退出时被调用。这对于管理静态或全局实例非常有用，尤其是在其析构顺序可能引发问题的情况下。</p><p><code>NoDestructor</code> 类的主要作用是创建一个对象实例，并保证这个实例的析构函数永远不会被调用。这在某些情况下是有用的，尤其是在处理函数级静态变量时，你可能不希望它们在程序结束时被自动销毁。</p><h3 id="内存分配和对象构造" tabindex="-1">内存分配和对象构造 <a class="header-anchor" href="#内存分配和对象构造" aria-label="Permalink to &quot;内存分配和对象构造&quot;">​</a></h3><ol><li><p><strong>内存分配</strong>： <code>NoDestructor</code> 类使用 <code>std::aligned_storage</code> 来分配静态存储空间。这个存储空间的大小和对齐方式与 <code>InstanceType</code> 相匹配。</p></li><li><p><strong>对象构造</strong>： 使用 &quot;placement new&quot; 在 <code>instance_storage_</code> 上构造 <code>InstanceType</code> 的实例。这里，<code>std::forward</code> 用于将构造函数的参数完美转发给 <code>InstanceType</code> 的构造函数。</p></li></ol><p>在这个示例中：</p><ul><li>我们创建了一个 <code>Example</code> 类型的静态实例，使用的是 <code>NoDestructor</code> 包装器。</li><li><code>NoDestructor</code> 在内部为 <code>Example</code> 类型的对象分配了内存，并在这块内存上构造了 <code>Example</code> 对象。</li><li><code>Example</code> 对象的构造函数被调用，但析构函数永远不会被调用。</li><li>可以通过 <code>example.get()</code> 获取 <code>Example</code> 实例的指针，并正常使用这个对象。</li></ul><h3 id="用途和好处" tabindex="-1">用途和好处 <a class="header-anchor" href="#用途和好处" aria-label="Permalink to &quot;用途和好处&quot;">​</a></h3><p><code>NoDestructor</code> 类的设计可以用于管理全局或静态对象的生命周期，尤其是当析构顺序可能导致问题或者析构行为是不必要的时候。这在某些资源管理或设计模式（如单例模式）中非常有用。通过防止静态对象的自动析构，可以避免程序结束时出现复杂的析构逻辑问题。</p><h2 id="nodestructor-如何实现" tabindex="-1">NoDestructor 如何实现 <a class="header-anchor" href="#nodestructor-如何实现" aria-label="Permalink to &quot;NoDestructor 如何实现&quot;">​</a></h2><p>这段代码中的 <code>NoDestructor</code> 类模板通过几个关键步骤实现了其核心功能：创建一个 <code>InstanceType</code> 类型的对象实例，并确保该实例的析构函数不会被调用。下面详细解释这个实现过程：</p><h3 id="_1-类模板定义" tabindex="-1">1. 类模板定义 <a class="header-anchor" href="#_1-类模板定义" aria-label="Permalink to &quot;1. 类模板定义&quot;">​</a></h3><p><code>NoDestructor</code> 是一个类模板，它接受一个类型参数 <code>InstanceType</code>，这表示 <code>NoDestructor</code> 将管理一个 <code>InstanceType</code> 类型的对象实例。</p><h3 id="_2-构造函数" tabindex="-1">2. 构造函数 <a class="header-anchor" href="#_2-构造函数" aria-label="Permalink to &quot;2. 构造函数&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">template</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">typename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">...</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ConstructorArgTypes</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">explicit</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> NoDestructor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ConstructorArgTypes</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">... constructor_args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>这是 <code>NoDestructor</code> 的构造函数，它是一个变参模板，允许接受任意数量和类型的参数，并将这些参数转发给 <code>InstanceType</code> 的构造函数。</p><h3 id="_3-内存分配" tabindex="-1">3. 内存分配 <a class="header-anchor" href="#_3-内存分配" aria-label="Permalink to &quot;3. 内存分配&quot;">​</a></h3><p>在构造函数内部，有两个 <code>static_assert</code> 语句确保 <code>instance_storage_</code> 有足够的空间并满足 <code>InstanceType</code> 的对齐要求：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">typename</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">aligned_storage</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">sizeof</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InstanceType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">),</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> alignof</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InstanceType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)&gt;::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">type</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> instance_storage_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre></div><p>这行代码使用 <code>std::aligned_storage</code> 来创建一个原始内存块，其大小和对齐方式都适合存储一个 <code>InstanceType</code> 类型的对象。</p><h3 id="_4-对象构造" tabindex="-1">4. 对象构造 <a class="header-anchor" href="#_4-对象构造" aria-label="Permalink to &quot;4. 对象构造&quot;">​</a></h3><p>使用 &quot;placement new&quot; 语法在 <code>instance_storage_</code> 上构造 <code>InstanceType</code> 对象：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">new</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">instance_storage_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> InstanceType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">ConstructorArgTypes</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">constructor_args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>这里，<code>new (&amp;instance_storage_)</code> 表示在 <code>instance_storage_</code> 指定的内存地址上构造一个 <code>InstanceType</code> 的实例。<code>std::forward</code> 用于完美转发构造函数的参数。</p><p>在提供的 <code>NoDestructor</code> 类模板中，&quot;placement new&quot; 的体现位于构造函数内部。具体来看，是在下面这行代码中：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">new</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">instance_storage_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> InstanceType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">ConstructorArgTypes</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">constructor_args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>这行代码中的 &quot;placement new&quot; 语法如下解释：</p><ol><li><p><strong><code>new (&amp;instance_storage_)</code></strong>：</p><ul><li>这是 &quot;placement new&quot; 的典型用法。与常规的 <code>new</code> 表达式不同，&quot;placement new&quot; 不会分配新的内存，而是在已经分配的内存上构造对象。这里，<code>&amp;instance_storage_</code> 提供了构造对象的内存地址。</li></ul></li><li><p><strong><code>InstanceType(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...)</code></strong>：</p><ul><li><code>InstanceType</code> 是 <code>NoDestructor</code> 模板的类型参数，表示被构造的对象类型。</li><li><code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> 是完美转发构造函数接收的参数，确保参数的左值/右值特性被保持不变。</li></ul></li></ol><p>总的来说，&quot;placement new&quot; 在这里用于在 <code>instance_storage_</code> 指定的内存位置上构造一个 <code>InstanceType</code> 类型的对象，而无需额外的内存分配。这是实现 <code>NoDestructor</code> 类的关键部分，确保了封装的对象不会自动调用析构函数。</p><h3 id="_5-禁止拷贝和赋值" tabindex="-1">5. 禁止拷贝和赋值 <a class="header-anchor" href="#_5-禁止拷贝和赋值" aria-label="Permalink to &quot;5. 禁止拷贝和赋值&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">NoDestructor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> NoDestructor</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> delete</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">NoDestructor</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> operator</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> NoDestructor</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> delete</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre></div><p>拷贝构造函数和拷贝赋值运算符被删除，确保 <code>NoDestructor</code> 对象不会被拷贝。</p><h3 id="_6-提供对内部实例的访问" tabindex="-1">6. 提供对内部实例的访问 <a class="header-anchor" href="#_6-提供对内部实例的访问" aria-label="Permalink to &quot;6. 提供对内部实例的访问&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">InstanceType</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> reinterpret_cast&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InstanceType</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">instance_storage_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p><code>get</code> 方法返回一个指向已构造的 <code>InstanceType</code> 实例的指针。</p><h3 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h3><p>这个类在需要管理静态或全局生命周期的对象时非常有用，尤其是在析构函数的调用可能引起问题的情况下。例如，在某些环境中，全局静态对象的析构函数可能在某些关键资源（如日志系统或内存分配器）已经被释放之后才调用，这可能导致未定义行为或程序崩溃。使用 <code>NoDestructor</code> 可以避免这类问题，因为它保证了封装的对象不会被析构。</p>`,51),h=[n];function l(p,k,d,r,o,c){return a(),i("div",null,h)}const A=s(t,[["render",l]]);export{y as __pageData,A as default};
