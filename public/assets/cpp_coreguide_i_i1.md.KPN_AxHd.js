import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/coreguide/i/i1.md","filePath":"cpp/coreguide/i/i1.md"}'),t={name:"cpp/coreguide/i/i1.md"},h=n(`<p>为了解释C++ Core Guidelines中关于使接口明确的建议，我们将通过一些实际的例子来探讨。这些例子将展示如何避免在设计接口时依赖隐含的状态或全局变量，从而使接口的行为更加明确和可预测。</p><h3 id="示例1-使用函数参数而不是全局变量" tabindex="-1">示例1: 使用函数参数而不是全局变量 <a class="header-anchor" href="#示例1-使用函数参数而不是全局变量" aria-label="Permalink to &quot;示例1: 使用函数参数而不是全局变量&quot;">​</a></h3><p><strong>问题</strong>: 依赖全局变量来改变函数行为。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 全局变量</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">bool</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> useMetricSystem </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 根据全局变量来决定使用哪个单位系统</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">double</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> calculateDistance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">double</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> miles</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> useMetricSystem </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">?</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> miles </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1.60934</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> miles</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 不好：依赖全局变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p><strong>改进</strong>: 将需要的信息作为参数传递给函数。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 改进后的函数，明确需要哪个单位系统</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">double</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> calculateDistance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">double</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> miles</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> bool</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> useMetric</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> useMetric </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">?</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> miles </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1.60934</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> miles</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在软件开发中，推荐使用函数参数而不是全局变量来改变函数行为的原因有几个：</p><ol><li><p><strong>可读性和可维护性</strong>：通过函数参数明确传递所需的信息，可以使函数的行为更加透明。这样代码的其他用户或未来的你可以更容易理解函数如何工作及其依赖关系，提高代码的可读性和可维护性。</p></li><li><p><strong>减少依赖性</strong>：依赖全局变量会使函数的行为依赖于外部状态，这增加了代码间的耦合度。通过参数传递所需信息，函数的执行不再依赖于外部状态，这样可以减少代码间的耦合，使得函数更加独立，易于测试和重用。</p></li><li><p><strong>易于测试</strong>：依赖于全局变量的函数可能需要在测试前设置全局环境，这会使得测试更加复杂且容易出错。通过将所需信息作为参数传递，可以轻松地为函数提供不同的输入进行测试，使得单元测试更加简单和清晰。</p></li><li><p><strong>避免副作用</strong>：全局变量容易被项目中的任何部分修改，可能会导致难以追踪的副作用，特别是在大型或复杂的代码库中。使用参数而不是全局变量可以避免这种类型的副作用，因为它确保了函数的行为只被局部信息所影响。</p></li><li><p><strong>提高代码的可复用性</strong>：将所需的信息作为参数传递，使得函数更加通用和灵活。这样的函数更容易被其他项目或代码库复用，因为它们不依赖于特定的全局状态。</p></li></ol><p>通过比较上述示例，很明显，改进后的版本更加清晰，易于理解和维护，同时也提高了代码的质量和可复用性。这些原因共同构成了在软件开发实践中，推荐使用函数参数而不是全局变量来改变函数行为的基础。</p><h3 id="示例2-明确异常处理而不是依赖错误码" tabindex="-1">示例2: 明确异常处理而不是依赖错误码 <a class="header-anchor" href="#示例2-明确异常处理而不是依赖错误码" aria-label="Permalink to &quot;示例2: 明确异常处理而不是依赖错误码&quot;">​</a></h3><p><strong>问题</strong>: 通过返回错误码或设置全局状态（如<code>errno</code>）来报告错误，这可能会被调用者忽略。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> openFile</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">string</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> filename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 尝试打开文件，返回错误码</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 假设失败</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p><strong>改进</strong>: 使用异常来明确报告错误，这迫使调用者处理异常，或者它会被传播。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> openFile</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">string</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> filename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    throw</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">runtime_error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Failed to open file</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>使用异常处理而不是依赖错误码来报告和处理错误在现代编程实践中更受推荐，原因如下：</p><ol><li><p><strong>强制错误处理</strong>：异常机制迫使调用者处理错误，因为未捕获的异常会导致程序终止。这与返回错误码不同，调用者可能忽略错误码，导致错误被遗漏和程序继续执行，可能会引起更严重的问题。</p></li><li><p><strong>清晰的错误传播</strong>：异常提供了一种清晰的机制来传播错误，即使是通过多层函数调用。使用错误码时，每一层的函数调用都必须检查错误并显式地返回给它的调用者，这会增加额外的负担和复杂度。</p></li><li><p><strong>分离错误处理代码</strong>：异常允许将错误处理代码从正常的业务逻辑中分离出来，使得业务逻辑更加清晰，易于理解和维护。而错误码需要在业务逻辑中检查和处理，可能导致代码混乱。</p></li><li><p><strong>提供更多错误信息</strong>：异常可以携带丰富的错误信息，包括错误消息、类型和堆栈跟踪等，这比简单的错误码能提供更多的上下文和调试信息。</p></li><li><p><strong>适应复杂情况</strong>：在处理复杂的错误情况时，使用异常可以更加灵活。例如，当一个函数需要处理多种错误条件时，使用异常就不需要为每种错误定义不同的错误码。</p></li><li><p><strong>标准化的错误处理</strong>：在许多现代编程语言中，异常是标准化的错误处理机制，这意味着使用异常能够使你的代码更加符合通用的编程习惯和期望。</p></li></ol><p>虽然异常处理在某些情况下（如性能敏感的系统或资源受限的环境）可能不是最佳选择，但在大多数应用程序开发场景中，使用异常来处理错误提供了一种更安全、更清晰且更强大的方式来管理错误和异常情况。</p><h3 id="示例3-使用参数对象而不是多个参数" tabindex="-1">示例3: 使用参数对象而不是多个参数 <a class="header-anchor" href="#示例3-使用参数对象而不是多个参数" aria-label="Permalink to &quot;示例3: 使用参数对象而不是多个参数&quot;">​</a></h3><p>当函数需要多个参数时，尤其是当某些参数是可选的或者有默认值时，考虑使用参数对象可以使接口更加清晰。</p><p><strong>问题</strong>: 函数接受多个参数，其中一些具有默认值。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> createWindow</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">string</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> title</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> width</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 800</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> height</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 600</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> bool</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> resizable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p><strong>改进</strong>: 定义一个参数对象来封装所有的选项。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">struct</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> WindowOptions</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">string title</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> width </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 800</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> height </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 600</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    bool</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> resizable </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> createWindow</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> WindowOptions</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> options</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>这些例子展示了如何通过使接口更加明确来提高代码的可读性和可维护性。将所需信息作为参数传递、避免隐式的全局状态、明确地处理错误，以及使用参数对象而不是多个参数，都是实现这一目标的有效方法。</p><p>使用参数对象而不是多个参数的方法提供了几个关键优势，使得接口更加清晰、可读性和可维护性得到提升：</p><ol><li><p><strong>可读性</strong>：参数对象使得函数调用更加清晰。调用者可以通过查看参数对象的属性了解哪些信息被传递给函数，而不是试图理解多个可能在调用点混杂的参数。</p></li><li><p><strong>可扩展性</strong>：如果将来需要添加更多的配置选项，使用参数对象可以轻松地扩展功能而无需修改函数签名。这对于维护大型项目或库尤其重要，因为它减少了对现有代码的影响。</p></li><li><p><strong>默认值和可选参数的灵活性</strong>：通过参数对象，可以很容易地为任何参数提供默认值，同时使得覆盖这些默认值变得简单。这种方式比在函数签名中直接指定默认值更灵活，尤其是当有多个可选参数时。</p></li><li><p><strong>减少参数数量</strong>：当函数需要多个参数时，参数列表可能会变得很长，这不仅影响代码的可读性，还可能引起错误。将这些参数封装在一个对象中可以有效地解决这个问题。</p></li><li><p><strong>促进代码复用</strong>：参数对象可以在不同的函数或方法之间共享和重用。这促进了代码复用，减少了重复代码，同时也使得参数的处理更加统一。</p></li><li><p><strong>改善函数调用的清晰度</strong>：使用参数对象，调用代码可以更加清晰地表达意图。例如，使用具名属性设置参数值，比起简单地传递一系列值，可以更清晰地表明每个参数的意义。</p></li><li><p><strong>简化函数签名</strong>：单个参数对象的使用简化了函数签名，使得API更加清洁和易于理解。特别是在涉及到API文档时，这种方法可以使得文档更加简洁明了。</p></li></ol><p>总的来说，使用参数对象的方法在设计清晰、可维护的API接口时非常有用，尤其是在参数数量较多或预期将来会变更的情况下。这种方法通过减少复杂性、提高代码的可读性和可扩展性，来提升整体的软件质量。</p>`,27),p=[h];function l(k,e,r,d,g,o){return a(),i("div",null,p)}const A=s(t,[["render",l]]);export{c as __pageData,A as default};
