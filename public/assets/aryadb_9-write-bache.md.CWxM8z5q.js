import{_ as e,c as i,o as s,R as a}from"./chunks/framework.2bglP9T5.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"aryadb/9-write-bache.md","filePath":"aryadb/9-write-bache.md"}'),t={name:"aryadb/9-write-bache.md"},l=a('<p><code>WriteBatch</code> 用于将多个写操作（插入或删除）捆绑成一个批次，以便这些操作可以作为一个整体原子性地应用到数据库中。</p><h3 id="writebatch-类的结构和成员" tabindex="-1"><code>WriteBatch</code> 类的结构和成员 <a class="header-anchor" href="#writebatch-类的结构和成员" aria-label="Permalink to &quot;`WriteBatch` 类的结构和成员&quot;">​</a></h3><ul><li><p><strong><code>rep_</code></strong>: <code>std::string</code> 类型的成员变量，用于存储编码后的写操作序列。其格式包括序列号、操作计数和实际数据记录。</p><ul><li><strong>序列号（Sequence）</strong>: 一个固定长度（64位）的数字，用于跟踪批次中操作的顺序。</li><li><strong>计数（Count）</strong>: 一个固定长度（32位）的数字，表示批次中的操作数量。</li><li><strong>数据（Data）</strong>: 一系列记录，每个记录代表一个写操作，可以是插入（<code>kTypeValue</code>）或删除（<code>kTypeDeletion</code>）。</li></ul></li><li><p><strong><code>WriteBatch::Handler</code></strong>: 一个嵌套类，定义了用于处理写操作的接口。它有两个虚函数：<code>Put</code> 和 <code>Delete</code>，供子类实现。</p></li></ul><h3 id="writebatch-类的主要方法" tabindex="-1"><code>WriteBatch</code> 类的主要方法 <a class="header-anchor" href="#writebatch-类的主要方法" aria-label="Permalink to &quot;`WriteBatch` 类的主要方法&quot;">​</a></h3><ul><li><strong>构造函数和析构函数</strong>: 初始化和清理 <code>WriteBatch</code> 对象。</li><li><strong><code>Clear</code></strong>: 清除 <code>rep_</code> 中的所有数据，重置为初始状态。</li><li><strong><code>Put</code> 和 <code>Delete</code></strong>: 向 <code>rep_</code> 添加新的写操作。</li><li><strong><code>Iterate</code></strong>: 遍历 <code>rep_</code> 中的所有操作，并对每个操作调用传入的 <code>Handler</code> 对象的相应方法。</li><li><strong><code>Append</code></strong>: 将另一个 <code>WriteBatch</code> 的操作追加到当前对象的 <code>rep_</code> 中。</li></ul><h3 id="writebatchinternal-类" tabindex="-1"><code>WriteBatchInternal</code> 类 <a class="header-anchor" href="#writebatchinternal-类" aria-label="Permalink to &quot;`WriteBatchInternal` 类&quot;">​</a></h3><p>这是一个辅助类，提供了一系列静态方法来处理 <code>WriteBatch</code> 对象。这些方法允许获取和设置 <code>WriteBatch</code> 的内部状态，例如操作计数和序列号，以及将 <code>WriteBatch</code> 的内容插入到 <code>MemTable</code> 或追加到另一个 <code>WriteBatch</code> 中。</p><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li>当需要将多个写操作（如插入或删除）作为一个整体原子操作应用到数据库时，<code>WriteBatch</code> 提供了一个有效的解决方案。</li><li>通过减少对数据库的单独写入次数，<code>WriteBatch</code> 可以提高性能，尤其是在处理大量数据更新时。</li></ul><p>这段代码的重点在于提供一个高效、可靠的方式来处理批量数据库写操作，这在诸如 LevelDB 这样的键值存储系统中非常重要。</p><h3 id="rep-成员的作用和结构" tabindex="-1"><code>rep_</code> 成员的作用和结构 <a class="header-anchor" href="#rep-成员的作用和结构" aria-label="Permalink to &quot;`rep_` 成员的作用和结构&quot;">​</a></h3><p><code>rep_</code> 字符串以一种特定的格式存储了一系列的写入操作，这些操作可以是插入（Put）或删除（Delete）。其格式大致如下：</p><ul><li><strong>序列号（Sequence Number）</strong>：占用 8 个字节，用于存储批处理操作的序列号。</li><li><strong>计数（Count）</strong>：占用 4 个字节，表示批处理中操作的数量。</li><li><strong>数据（Data）</strong>：随后是实际的操作记录，每个记录可以是一个插入操作或一个删除操作。</li></ul><p>对于插入操作，记录格式是：</p><ul><li><code>kTypeValue</code> 标记</li><li>键的长度和内容</li><li>值的长度和内容</li></ul><p>对于删除操作，记录格式是：</p><ul><li><code>kTypeDeletion</code> 标记</li><li>键的长度和内容</li></ul><h3 id="示例-1-插入操作-put" tabindex="-1">示例 1: 插入操作 (Put) <a class="header-anchor" href="#示例-1-插入操作-put" aria-label="Permalink to &quot;示例 1: 插入操作 (Put)&quot;">​</a></h3><p>假设我们要插入键值对 <code>&quot;key1&quot;</code> 和 <code>&quot;value1&quot;</code>。<code>WriteBatch</code> 类的 <code>Put</code> 方法会按照下面的方式编码这个操作到 <code>rep_</code>：</p><ol><li><strong>操作类型</strong>: 首先，它会添加一个表示插入操作的标记（假设为 <code>kTypeValue</code>）。</li><li><strong>键</strong>: 接着，它会将 <code>&quot;key1&quot;</code> 的长度和实际内容添加到 <code>rep_</code>。假设字符串的长度用一个前缀的 varint32 表示。</li><li><strong>值</strong>: 最后，它同样会将 <code>&quot;value1&quot;</code> 的长度和实际内容添加到 <code>rep_</code>。</li></ol><p>如果 <code>&quot;key1&quot;</code> 的长度为 4，<code>&quot;value1&quot;</code> 的长度为 6，那么 <code>rep_</code> 的内容可能如下（以伪代码形式展示）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>[kTypeValue, 4, &quot;key1&quot;, 6, &quot;value1&quot;]</span></span></code></pre></div><h3 id="示例-2-删除操作-delete" tabindex="-1">示例 2: 删除操作 (Delete) <a class="header-anchor" href="#示例-2-删除操作-delete" aria-label="Permalink to &quot;示例 2: 删除操作 (Delete)&quot;">​</a></h3><p>假设我们要删除键 <code>&quot;key2&quot;</code>。<code>WriteBatch</code> 类的 <code>Delete</code> 方法会这样编码这个操作到 <code>rep_</code>：</p><ol><li><strong>操作类型</strong>: 首先，添加一个表示删除操作的标记（假设为 <code>kTypeDeletion</code>）。</li><li><strong>键</strong>: 然后，添加 <code>&quot;key2&quot;</code> 的长度和内容。</li></ol><p>如果 <code>&quot;key2&quot;</code> 的长度为 4，则 <code>rep_</code> 的内容可能如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>[kTypeDeletion, 4, &quot;key2&quot;]</span></span></code></pre></div><h3 id="综合示例-混合操作" tabindex="-1">综合示例: 混合操作 <a class="header-anchor" href="#综合示例-混合操作" aria-label="Permalink to &quot;综合示例: 混合操作&quot;">​</a></h3><p>如果我们连续执行一个插入操作和一个删除操作，比如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">WriteBatch batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">key1</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">value1</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Delete</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">key2</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>则 <code>rep_</code> 的内容将是这两个操作的编码序列。首先是插入 <code>&quot;key1&quot;</code> 的操作，然后是删除 <code>&quot;key2&quot;</code> 的操作。伪代码表示可能如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>[kTypeValue, 4, &quot;key1&quot;, 6, &quot;value1&quot;, kTypeDeletion, 4, &quot;key2&quot;]</span></span></code></pre></div><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>在实际的 LevelDB 实现中，标记（如 <code>kTypeValue</code> 和 <code>kTypeDeletion</code>）和长度（如键和值的长度）可能会以更高效的方式进行编码，比如使用变长编码（varint）。</li><li><code>rep_</code> 字符串还包含用于事务控制的序列号和操作计数信息。</li></ul><p>通过这种方式，LevelDB 能够高效地存储和重放一系列数据库操作，同时保持操作的原子性和一致性。这种编码机制使 <code>WriteBatch</code> 成为在处理大量更新操作时提升性能的重要工具。</p><h3 id="writebatch-类中对-rep-的操作" tabindex="-1"><code>WriteBatch</code> 类中对 <code>rep_</code> 的操作 <a class="header-anchor" href="#writebatch-类中对-rep-的操作" aria-label="Permalink to &quot;`WriteBatch` 类中对 `rep_` 的操作&quot;">​</a></h3><ul><li><strong>构造函数（Constructor）</strong> 和 <strong>Clear</strong> 方法：初始化 <code>rep_</code>，预留头部空间（包含序列号和计数）。</li><li><strong>Put</strong> 和 <strong>Delete</strong> 方法：在 <code>rep_</code> 中追加相应的操作记录。</li><li><strong>Iterate</strong> 方法：遍历 <code>rep_</code>，对每个记录调用传入的 <code>Handler</code> 对象的方法。</li><li><strong>Append</strong> 方法：将另一个</li></ul><p><code>WriteBatch</code> 对象中的操作追加到当前 <code>rep_</code> 中。</p><h3 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h3><p>当使用 LevelDB 进行数据操作时，<code>WriteBatch</code> 提供了一种有效的方式来批量处理多个更新操作。通过将多个操作组合成一个批处理，可以减少磁盘 I/O 操作，从而提高性能。在实际的使用场景中，例如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">WriteBatch batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">key1</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">value1</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Delete</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">key2</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">batch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">key3</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">value3</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>这段代码表示创建了一个 <code>WriteBatch</code> 实例，并添加了三个操作：两个插入（Put）操作和一个删除（Delete）操作。这些操作被编码并存储在 <code>rep_</code> 字符串中。</p><p>当调用 <code>WriteBatch</code> 的 <code>Write</code> 方法（通常是通过 LevelDB 的数据库实例）将这个批处理写入数据库时，LevelDB 会将 <code>rep_</code> 中编码的所有操作作为一个原子操作序列应用到数据库中。这意味着，这些操作要么全部成功，要么在遇到错误时全部不会被应用。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>使用 <code>WriteBatch</code> 的主要优点是性能提升。通过将多个更新操作组合成单个批处理，可以减少对底层存储的访问次数，特别是在涉及到磁盘 I/O 操作时。在大量数据更新的场景下，这种方法尤其高效。</p><p>总之，<code>std::string rep_;</code> 在 <code>WriteBatch</code> 类中作为一个核心成员，存储着所有待处理的数据库操作。通过精心设计的编码方式，它支持高效的数据处理，同时保持了 LevelDB 操作的原子性和一致性。</p><h3 id="writebatchinternal-count" tabindex="-1">WriteBatchInternal::Count <a class="header-anchor" href="#writebatchinternal-count" aria-label="Permalink to &quot;WriteBatchInternal::Count&quot;">​</a></h3><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> WriteBatchInternal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> WriteBatch</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>\n<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> DecodeFixed32</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">rep_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">data</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> WriteBatchInternal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">SetCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">WriteBatch</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>\n<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  EncodeFixed32</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">rep_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">],</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在 <code>WriteBatchInternal::Count</code> 函数中加上 <code>8</code> 的原因与 <code>WriteBatch</code> 数据结构的内部格式密切相关。回顾一下，<code>WriteBatch</code> 对象的 <code>rep_</code> 成员以特定的格式存储了一系列数据库写操作，这个格式包括：</p><ol><li><strong>序列号（Sequence Number）</strong>：8 字节长，用于存储批次的序列号。</li><li><strong>计数（Count）</strong>：4 字节长，紧随序列号之后，表示批次中操作的数量。</li><li><strong>数据（Data）</strong>：实际的操作数据，每项操作的格式依赖于它是插入还是删除操作。</li></ol><p>在 <code>Count</code> 函数中，我们对 <code>rep_</code> 进行解码以获取批次中操作的数量。由于序列号占据了最初的 8 个字节，计数信息紧随其后，我们需要跳过这 8 个字节来到达计数信息的开始位置。这就是为什么要在 <code>b-&gt;rep_.data()</code>（指向 <code>rep_</code> 的起始地址）的基础上加上 <code>8</code> 的原因。加上 <code>8</code> 之后，指针指向的位置正好是 4 字节长度的计数信息的起始位置。</p><p>这里的 <code>DecodeFixed32</code> 函数用于从指定的位置解码出一个 32 位整数（在这个场景下，是操作计数）。通过从 <code>rep_</code> 的第 8 个字节开始解码，我们得到存储在那里的操作数量。这是解析具有特定二进制格式的数据时常见的做法。</p><h3 id="put、delete、append" tabindex="-1">Put、Delete、Append <a class="header-anchor" href="#put、delete、append" aria-label="Permalink to &quot;Put、Delete、Append&quot;">​</a></h3><p><code>WriteBatch</code> 类的三个方法，这些方法用于批量处理数据库写入操作，包括添加新的键值对、删除现有键和将一个批处理的内容追加到另一个批处理中。下面是对每个方法的中文解释：</p><h3 id="_1-writebatch-put-const-slice-key-const-slice-value" tabindex="-1">1. <code>WriteBatch::Put(const Slice&amp; key, const Slice&amp; value)</code> <a class="header-anchor" href="#_1-writebatch-put-const-slice-key-const-slice-value" aria-label="Permalink to &quot;1. `WriteBatch::Put(const Slice&amp; key, const Slice&amp; value)`&quot;">​</a></h3><p>这个方法用于向批处理中添加一个“put”操作，即插入或更新一个键值对。</p><ul><li><code>WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);</code>：这行代码将批处理中的操作计数增加 1。</li><li><code>rep_.push_back(static_cast&lt;char&gt;(kTypeValue));</code>：这行代码在内部字符串 <code>rep_</code> 中添加一个表示插入操作的字符（<code>kTypeValue</code>）。</li><li><code>PutLengthPrefixedSlice(&amp;rep_, key);</code> 和 <code>PutLengthPrefixedSlice(&amp;rep_, value);</code>：这两行代码分别将键和值作为带有长度前缀的数据添加到 <code>rep_</code> 中。这意味着每个键或值之前都存储了它们的长度，以便后续可以准确地解析。</li></ul><h3 id="_2-writebatch-delete-const-slice-key" tabindex="-1">2. <code>WriteBatch::Delete(const Slice&amp; key)</code> <a class="header-anchor" href="#_2-writebatch-delete-const-slice-key" aria-label="Permalink to &quot;2. `WriteBatch::Delete(const Slice&amp; key)`&quot;">​</a></h3><p>这个方法用于向批处理中添加一个“delete”操作，即删除一个键。</p><ul><li><code>WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);</code>：同样，这行代码将批处理中的操作计数增加 1。</li><li><code>rep_.push_back(static_cast&lt;char&gt;(kTypeDeletion));</code>：这行代码在内部字符串 <code>rep_</code> 中添加一个表示删除操作的字符（<code>kTypeDeletion</code>）。</li><li><code>PutLengthPrefixedSlice(&amp;rep_, key);</code>：这行代码将要删除的键作为带有长度前缀的数据添加到 <code>rep_</code> 中。</li></ul><h3 id="_3-writebatch-append-const-writebatch-source" tabindex="-1">3. <code>WriteBatch::Append(const WriteBatch&amp; source)</code> <a class="header-anchor" href="#_3-writebatch-append-const-writebatch-source" aria-label="Permalink to &quot;3. `WriteBatch::Append(const WriteBatch&amp; source)`&quot;">​</a></h3><p>这个方法用于将另一个 <code>WriteBatch</code> 对象的内容追加到当前批处理中。</p><ul><li><code>WriteBatchInternal::Append(this, &amp;source);</code>：这行代码实现了将 <code>source</code> 批处理中的所有操作追加到当前 <code>WriteBatch</code> 对象的功能。</li></ul><p>这些方法一起使得可以高效地组织和执行数据库写入操作，特别是当有许多操作需要批量处理时。通过将多个写操作组合成一个批处理，可以减少对底层存储的访问次数，提高性能。</p>',64),h=[l];function n(o,d,c,p,r,k){return s(),i("div",null,h)}const y=e(t,[["render",n]]);export{u as __pageData,y as default};
