import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/pure-vptr.md","filePath":"cpp/basic/pure-vptr.md"}'),l={name:"cpp/basic/pure-vptr.md"},h=n(`<p>虚函数和纯虚函数是C++中实现多态性的关键概念，它们允许在派生类中改变或实现基类中定义的行为。</p><h3 id="虚函数-virtual-function" tabindex="-1">虚函数（Virtual Function） <a class="header-anchor" href="#虚函数-virtual-function" aria-label="Permalink to &quot;虚函数（Virtual Function）&quot;">​</a></h3><p>虚函数是可以在派生类中被重写的函数。它们用于实现运行时多态。当通过基类的指针或引用调用虚函数时，将调用由指针或引用实际指向的对象类型的函数版本。</p><h4 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h4><ul><li>虚函数依靠虚函数表（vtable）来实现。</li><li>每个含有虚函数的类都有一个vtable，这个表包含了指向类的虚函数的指针。</li><li>类的每个对象都有一个指向其vtable的指针（vptr）。</li></ul><h4 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Animal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> speak</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Some animal sound</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Dog</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Animal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> speak</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Bark!</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// ...</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Animal</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> animal </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Dog</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">animal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">speak</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 输出 &quot;Bark!&quot;</span></span></code></pre></div><p>在这个例子中，<code>Animal</code>类有一个虚函数<code>speaks</code>，<code>Dog</code>类重写了这个函数。当通过<code>Animal</code>类型的指针调用<code>speak</code>时，实际调用的是<code>Dog</code>类的<code>speak</code>函数。</p><h3 id="纯虚函数-pure-virtual-function" tabindex="-1">纯虚函数（Pure Virtual Function） <a class="header-anchor" href="#纯虚函数-pure-virtual-function" aria-label="Permalink to &quot;纯虚函数（Pure Virtual Function）&quot;">​</a></h3><p>纯虚函数是一种特殊的虚函数，它在基类中没有定义具体的实现，而是强制要求派生类提供实现。含有纯虚函数的类称为抽象类，不能被实例化。</p><p>在C++中，如果一个类继承自包含纯虚函数的基类，那么这个派生类必须实现基类中的所有纯虚函数，才能成为一个非抽象类，也就是说才能够实例化对象。如果派生类没有实现基类中的所有纯虚函数，那么这个派生类也将是一个抽象类，无法实例化对象。</p><p>这是因为纯虚函数定义了一个接口协议，要求派生类必须提供这些函数的具体实现。这是一种强制性的要求，确保了多态性的实现。通过实现这些纯虚函数，派生类表明了它们支持基类所定义的接口。</p><h4 id="解决的问题" tabindex="-1">解决的问题 <a class="header-anchor" href="#解决的问题" aria-label="Permalink to &quot;解决的问题&quot;">​</a></h4><ul><li>强制派生类实现特定的函数。</li><li>提供一个接口或抽象基类，派生类必须实现这个接口才能实例化。</li></ul><h4 id="示例-1" tabindex="-1">示例 <a class="header-anchor" href="#示例-1" aria-label="Permalink to &quot;示例&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Shape</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> draw</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 纯虚函数</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Circle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Shape</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> draw</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Drawing a circle</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Shape* shape = new Shape(); </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 错误，不能实例化抽象类</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Shape</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> shape </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Circle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">shape</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">draw</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 输出 &quot;Drawing a circle&quot;</span></span></code></pre></div><p>在这个例子中，<code>Shape</code>是一个抽象基类，它定义了一个纯虚函数<code>draw</code>。<code>Circle</code>是<code>Shape</code>的一个派生类，它提供了<code>draw</code>函数的具体实现。你不能创建一个<code>Shape</code>的实例，因为它是抽象的，但你可以创建一个<code>Shape</code>类型的指针，指向一个<code>Circle</code>的实例，并通过这个指针调用<code>draw</code>。</p><h4 id="纯虚函数的工作原理" tabindex="-1">纯虚函数的工作原理 <a class="header-anchor" href="#纯虚函数的工作原理" aria-label="Permalink to &quot;纯虚函数的工作原理&quot;">​</a></h4><ul><li>当类中存在纯虚函数时，它的虚函数表（vtable）会在相应的表项中存有一个空位或标记，通常是一个空指针或特殊值。</li><li>这个空位标志着纯虚函数没有实现，因此不能创建该类的实例。</li><li>编译器不允许直接调用不存在的函数，所以含有纯虚函数的类（抽象类）不能被实例化。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>虚函数</strong> 允许在派生类中进行重写，提供了默认的实现，用于实现运行时多态。</li><li><strong>纯虚函数</strong> 不提供任何实现，强制派生类实现它们，用于创建抽象基类。</li><li>通过使用纯虚函数，你可以定义一个通用的接口，派生类必须实现这个接口才能实例化。这强制了一种结构，保证了某些方法在派生类中一定会被实现，从而提供了一种更严格的面向接口的编程方式。</li></ul>`,21),p=[h];function t(k,e,r,d,c,o){return a(),i("div",null,p)}const A=s(l,[["render",t]]);export{y as __pageData,A as default};
