
### <a name="Ri-singleton"></a>I.3: 避免使用单例

##### 理由

单例基本上就是经过伪装的更复杂的全局对象。

##### 示例

    class Singleton {
        // ... 大量代码，用于确保只创建一个 Singleton，
        // 进行正确地初始化，等等
    };

单例的想法有许多变种。
这也是问题的一方面。

##### 注解

如果不想让全局对象被改变，请将其声明为 `const` 或 `constexpr`。

##### 例外

你可以使用最简单的“单例”形式（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：

    X& myX()
    {
        static X my_x {3};
        return my_x;
    }

这是解决初始化顺序相关问题的最有效方案之一。
在多线程环境中，静态对象的初始化并不会引入数据竞争条件
（除非你不小心在其构造函数中访问了某个共享对象）。

注意局部的 `static` 对象初始化并不会蕴含竞争条件。
不过，如果 `X` 的销毁中涉及了需要进行同步的操作的话，我们就得用一个不那么简单的方案。
例如：

    X& myX()
    {
        static auto p = new X {3};
        return *p;  // 有可能泄漏
    }

这样就必须有人以某种适当的线程安全方式来 `delete` 这个对象了。
这是容易出错的，因此除了以下情况外我们并不使用这种技巧：

* `myX` 是在多线程代码中，
* 这个 `X` 对象需要销毁（比如由于它要释放某个资源），而且
* `X` 的析构函数的代码需要进行同步。

如果你和许多人一样把单例定义为只能创建一个对象的类的话，像 `myX` 这样的函数并非单例，而且这种好用的技巧并不算无单例规则的例外。

##### 强制实施

通常非常困难。

* 查找名字中包含 `singleton` 的类。
* 查找只创建一个对象的类（通过对对象计数或者检查其构造函数）。
* 如果某个类 X 具有公开的静态函数，并且它包含具有该类 X 类型的函数级局部静态变量并返回指向它的指针或者引用，就禁止它。
