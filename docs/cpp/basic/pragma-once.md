# #pragma once

在 `#pragma once` 出现之前，C++程序员通常使用宏定义来防止头文件被重复包含。这种做法被称为 "include guards" 或 "header guards"。下面我会通过一个具体的例子来说明在有和没有 `#pragma once` 的情况下，这些问题是如何被处理的。

### 1. 没有 `#pragma once` 的情况

假设我们有一个名为 `myheader.h` 的头文件。在没有 `#pragma once` 的情况下，为了防止头文件内容被重复包含，我们需要使用宏定义来创建一个包含防护。这通常是这样做的：

```cpp
// myheader.h
#ifndef MYHEADER_H
#define MYHEADER_H

// 头文件内容
void myFunction();

#endif // MYHEADER_H
```

在这个例子中：
- `#ifndef MYHEADER_H` 检查 `MYHEADER_H` 是否未定义。
- `#define MYHEADER_H` 定义宏，以便后续的编译过程中 `#ifndef` 检查失败，防止重复包含。
- `#endif` 结束预处理器条件。

#### 存在的问题
1. **手动管理宏**：每个头文件都需要一个唯一的宏名，这增加了开发的复杂性。
2. **命名冲突**：如果不小心重复使用了宏名，可能会导致错误。
3. **编译器依赖**：不同的编译器可能对宏的处理方式有所不同，影响代码的可移植性。

### 2. 有 `#pragma once` 的情况

`#pragma once` 是一个预处理器指令，用于告诉编译器当前头文件只需在单个编译中包含一次。对于同一个头文件，即使它在多个文件中被包含，也只会被处理一次。我们修改上面的例子如下：

```cpp
// myheader.h
#pragma once

// 头文件内容
void myFunction();
```

#### 解决的问题
1. **简化处理**：不需要定义和维护宏。
2. **避免冲突**：不再依赖于宏的唯一性，减少了命名冲突的风险。
3. **提高效率**：在某些情况下，`#pragma once` 可以减少编译器的工作量，提高编译效率。

### 结论
尽管 `#pragma once` 在很多现代编译器中被广泛支持，并且为防止头文件重复包含提供了一种更简洁的方式，但它并不是C++标准的一部分。因此，在跨平台或使用不同编译器的项目中，使用传统的宏定义包含防护仍然是一种更安全的做法。