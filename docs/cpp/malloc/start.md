

为了测试您的代码以进行检查点提交，请使用 -C 标志运行 mdriver 和/或 driver.pl。对于最终提交，您不需要任何额外的标志。
您可以获得关于程序性能和您将获得的吞吐量成绩的一些想法。然而，Autolab 服务器将生成不同的吞吐量值，这些值将确定您的实际分数。这在第 7 节中有更详细的讨论。
4

3 必需函数
您的分配器将实现以下在 mm.h 中声明并在 mm.c 中定义的函数：
    bool  mm_init(void);
    void *malloc(size_t size);
    void  free(void *ptr);
    void *realloc(void *ptr, size_t size);
    void *calloc(size_t nmemb, size_t size);
    bool  mm_checkheap(int);
我们为您提供了两个版本的内存分配器：
mm.c：一个完全功能的隐式链表分配器。我们建议您将此代码用作起点。
请注意，提供的代码不实现合并块（coalesce block()）。尽管它是一个有效的内存分配器，但它将导致大量的外部碎片，因此您应该实现合并。我们强烈建议在编写此函数的代码之前考虑您需要实现的所有情况；讲座幻灯片应该帮助您识别和推理这些情况。
mm-naive.c：一个功能实现，运行速度很快，但利用率很差，因为它从不重用任何内存块。
您的分配器必须在 64 位机器上正确运行。它必须支持完整的 64 位地址空间，即使当前的 x86-64 机器实现只支持 48 位地址空间。
您提交的 mm.c 必须实现以下函数：
• bool mm_init(void)：执行任何必要的初始化，比如分配初始堆区域。如果在执行初始化时出现问题，返回值应为 false，否则为 true。您必须在此函数中重新初始化所有数据结构，因为驱动程序在开始新跟踪时会调用您的 mm init 函数以重置为空堆。
• void *malloc(size_t size)：malloc例程返回一个指向至少大小字节的分配块有效载荷的指针。整个分配的块应该位于堆区域内，不应该与任何其他分配的块重叠。
您的 malloc 实现必须始终返回 16 字节对齐的指针。
• void free(void *ptr)：free例程释放由 ptr 指向的块。它不返回任何东西。只有在传递的指针是由先前的 malloc、calloc 或 realloc 调用返回的，且尚未被释放时，此例程才能保证正常工作。free(NULL) 不会产生任何效果。
5

• void *realloc(void *ptr, size_t size)：realloc例程返回一个指向至少大小字节的分配区域的指针，具有以下约束：
- 如果 ptr 为 NULL，则调用等效于 malloc(size);
- 如果 size 等于零，则调用等效于 free(ptr)，并应返回 NULL;
- 如果 ptr 不为 NULL，则调用等效于 free(ptr) 后跟 malloc(size)，但新块的内容将与旧块的内容相同，最多为旧大小和新大小的最小值。
您的 realloc 实现对测量的吞吐量或利用率影响很小。一个正确而简单的实现就足够了。
• void *calloc(size_t nmemb, size_t size)：为大小为 nmemb 的数组分配内存，每个元素大小为 size 字节，并返回分配的内存的指针。在返回之前，内存被设置为零。
您的 calloc 不会根据吞吐量或性能评分。一个正确而简单的实现就足够了。
• bool mm_checkheap(int line)：mm checkheap 函数（堆一致性检查器，或简称堆检查器）扫描堆并检查可能的错误。
一个高质量的堆检查器对于调试 malloc 实现至关重要。许多 malloc 错误都太微妙，以至于无法使用传统的 gdb 技术进行调试。堆一致性检查器可以帮助您隔离导致堆不一致的特定操作。
由于一致性检查器的重要性，它将被评分；第 7.2 节详细描述了您的实现要求。我们还可能要求您在办公时间前编写您的 checkheap 函数。
mm checkheap 函数接受一个整数参数，您可以根据需要使用任何方式。一种技术是使用此参数传递

调用的行号，使用 __LINE__ 宏：
         mm_checkheap(__LINE__);
如果检测到堆问题，这允许您打印调用 mm checkheap 的行号。然而，请注意，驱动程序还将使用参数 0 调用 mm checkheap。
malloc、realloc、calloc 和 free 的语义与相应的 libc 例程相匹配。在 shell 中键入 man malloc 可以获得更多文档。


4 支持例程
memlib.c 包模拟了动态内存分配器的内存系统。您可以在 memlib.c 中调用以下函数：
• void *mem_sbrk(intptr_t incr)：通过 incr 字节扩展堆，其中 incr 是非负整数，并返回新分配堆区域的第一个字节的通用指针。语义与 Unix 的 sbrk 函数相同，但 mem_sbrk 对于负参数将失败。（数据类型 intptr_t 被定义为足够大以容纳指针的有符号整数。在我们的机器上，它是 64 位长。）
• void *mem_heap_lo(void)：返回指向堆中第一个有效字节的通用指针。
• void *mem_heap_hi(void)：返回指向堆中最后一个有效字节的通用指针。
注意：这里给出的 mem_heap_hi() 的定义是正确的，但可能不直观！如果您的堆大小为 8 字节，那么“最后一个有效字节”将距离开头 7 字节，并且其地址不会对齐。
• size_t mem_heapsize(void)：返回堆的当前大小（以字节为单位）。
您还允许使用以下 libc 库函数：memcpy、memset、printf、fprintf 和 sprintf。除了这些函数和支持例程之外，您的 mm.c 代码不得调用任何外部定义的函数。
7

5
•
•
•
编程规则
任何试图明确检测正在运行哪个跟踪的分配器都将受到 20 分的扣分。另一方面，您应该随意编写一个自适应分配器，根据不同跟踪的一般特征动态调整自己。
您不应更改 mm.h 中的任何接口，您的程序必须使用提供的 Makefile 进行编译。但是，我们强烈鼓励您在 mm.c 中使用静态辅助函数，将代码分解成小的、易于理解的部分。
您不允许在 mm.c 程序中定义任何大型的全局数据结构，如大型数组、树或列表。但是，您可以在 mm.c 中声明小的全局数组、结构和标量变量，如整数、浮点数和指针。总的来说，您的全局数据应不超过 128 字节。用 const 限定符定义的全局值不计入 128 字节中。这将通过自动化方式进行测试，如第 7.1.4 节所述。
这一限制的原因是驱动程序无法考虑这些全局变量在其内存利用率测量中的影响。如果需要大型数据结构的空间，可以在堆内为它们分配空间。
在 malloclab 中，不可避免地会存在一些未定义的行为，因为我们执行不安全的内存操作，通常将内存视为一个巨大的游乐场。例如，我们需要做的事情包括在指针类型之间进行转换、执行指针算术和写入内存中的任意位置。在这个实验之外，编写这种风格的代码通常是不合适的，但在这里是必要的。
然而，我们要求您尽量减少未定义行为的数量，尽量避免它。例如，您应该明确地通过使用联合体来别名内存，而不是直接在指针类型之间进行转换。此外，您应该限制指针算术的使用，仅在几个短小的辅助函数中使用，就像我们在 handout 代码中尝试做的那样。
在提供的基线代码中，我们使用零长度数组来声明块结构中的 payload 元素。这是一个非标准的编译器扩展，但我们鼓励您在此实验中使用它作为显式声明块 payload 的一种方式。
一个重要的限制是零长度数组必须出现在其包含结构的最后一个元素中。但是，在 malloclab 中，我们也将允许零长度数组作为联合体的成员，只要该联合体是其包含结构的最后一个元素。这将允许您明确地将 payload 与其他数据别名，您可能还希望存储在同一内存地址中的数据。尽管这不是可移植的，但我们强烈鼓励您使用它，而不是在指针类型之间进行转换的替代方法。
在代码中使用宏定义（使用 #define）受到以下限制：
- 用于调试目的的宏，其名称必须以前缀“dbg_”开头。例如，mm.c 中定义的调试宏。您可以创建自己的调试宏，但在提交的代码中必须将它们禁用。
•
•
•
8



- 常量的定义。这些定义不能带有任何参数。
使用宏定义而不是函数定义的做法现在已经过时。现代编译器（启用优化时）会对小函数进行内联替换，消除了由于使用函数而不是宏而导致的任何低效性。此外，函数提供更好的类型检查并支持更好的调试。
以下是一些允许和不允许的宏定义示例：
#define DEBUG 1 允许 #define CHUNKSIZE (1<<12) 允许 #define WSIZE sizeof(uint64_t) 允许 #define dbg_printf(...) printf(__VA_ARGS__) 允许 #define GET(p) (*(unsigned int *)(p)) 不允许 #define PACK(size, alloc) ((size)|(alloc)) 不允许
定义一个常量 定义一个常量 定义一个常量 调试支持 带有参数 带有参数
当您运行 make 时，它将运行一个检查程序，用于检查代码中不允许的宏定义。这个检查程序过于严格，它无法确定宏定义是否嵌入在注释中或者是否在被条件编译指令禁用的代码的某部分中。尽管如此，您的代码必须通过此检查程序而不出现任何警告消息。
• 教科书中显示的代码（第 9.9.12 节，以及 CS:APP 网站上提供的代码）是实验的一个有用的灵感来源，但它不符合所需的编码标准。它不能处理 64 位分配，它大量使用宏而不是函数，并且严重依赖低级指针算术。同样，K&R 中显示的代码也不满足编码要求。您应该使用提供的代码 mm.c 作为起点。
• 查看教材或其他地方找到的算法的高级描述是可以的，但复制或查看在线或其他来源中找到的任何 malloc 实现的代码是不可接受的，除了教科书中描述的分配器、K&R 中描述的分配器或提供的代码的一部分。
• 从 Wikipedia 和其他存储库中获取有用的通用数据结构和算法的代码是可以的（例如，链表、哈希表、搜索树和优先队列）。（此代码不能已经作为内存分配器的一部分进行了定制。）您必须包含（作为注释）借用代码的来源的归属说明。
• 您的分配器必须始终返回按 16 字节边界对齐的指针。驱动程序将检查此要求。
• 您的代码必须编译而不产生警告。
9

6 驱动程序
运行 make 时会生成三个驱动程序。
1. mdriver 应用于测试代码的性能。它检查标准基准跟踪的正确性、利用率和吞吐量。
2. mdriver-dbg 用于调试程序。这与 mdriver 相同的程序，有两个显著的区别：
(a) 此程序在定义了 DEBUG 的情况下编译，这会启用 mm.c 顶部的 dbg_ 宏。如果没有定义此宏，函数如 dbg_printf 和 dbg_assert 将不会产生任何效果。
(b) 此外，此程序以优化级别 -O0 编译，这允许 GDB 显示更有意义的调试信息。
3. mdriver-emulate 用于对您的程序执行额外的正确性检查，这可能会导致第 7.1.4 节描述的额外扣分。
它使用特殊的编译和内存管理技术，允许测试使用完整的 64 位地址空间的堆。除了标准基准跟踪之外，它还将运行一组包含非常大的分配请求的大型跟踪。
6.1 跟踪文件
驱动程序受一组跟踪文件的控制，这些文件包含了一系列命令，指示驱动程序以某种顺序调用您的 malloc、realloc 和 free 程序。驱动程序和跟踪文件与我们评分时将使用的 handin mm.c 文件相同。
对于内存利用率和吞吐量计数的跟踪，在 mdriver 的输出中用 ' * ' 标记。一些跟踪是短跟踪，不计入内存利用率或吞吐量，但用于检测错误和调试，它们旁边没有标记 ' * '。
运行驱动程序时，它们将多次运行每个跟踪文件：一次用于确保您的实现正确，一次用于确定空间利用率，以及在 3 到 20 次之间用于确定吞吐量。
6.2 命令行参数
驱动程序接受以下命令行参数。正常操作是不带任何参数运行它，但在开发过程中可能会发现在开发过程中使用这些参数很有用。
• -C：应用检查点的评分标准，而不是最终提交的标准。
• -f tracefile：使用一个特定的 tracefile 而不是默认的一组 tracefile 用于测试正确性、利用率和吞吐量。
• -c tracefile：运行一个特定的 tracefile 两次，每次在调用 mm init 之间运行。与 -t 不同，此选项仅测试正确性。如果您想打印出调试消息，此选项非常有用。
• -v level：将详细程度设置为指定值。支持级别 0 到 2，默认级别为 1。提高详细程度会导致在处理每个跟踪文件时打印附加的诊断信息。在调试期间，这可能有助于确定哪个跟踪文件导致您的 malloc 包失败。
• -d level：控制驱动程序执行的有效性检查量。这与 DEBUG 编译时定义完全不同。
在调试级别 0，只进行很少的检查，这对于仅测试性能很有用。
在调试级别 1，驱动程序检查有效负载内容，以确保它们在调用您的代码时不被覆盖。这是默认设置。
在调试级别 2，驱动程序还将调用您的 mm checkheap 实现。此模式较慢，但可以帮助确定错误发生的确切位置。
通过运行 mdriver -h 可以列出其他参数。
11

这是关于Malloc Lab的得分和扣分的描述：

对于检查点（checkpoint）的得分计算如下：
- 利用率（utilization）占20%的分数权重。
- 吞吐量（throughput）占80%的分数权重。

对于最终（final）的得分计算如下：
- 利用率（utilization）占60%的分数权重。
- 吞吐量（throughput）占40%的分数权重。

如果 mdriver 驱动程序在任何追踪中检测到错误，将会分配一个性能指数为0。

自动评分的扣分情况如下：
- 如果 mdriver-emulate 程序运行失败，将扣除30分。
   - 这可能发生在您的代码不支持完整的64位地址空间时，例如，如果您使用 int 而需要 size_t。
   - mdriver-emulate 还会检查您的代码是否读取未初始化的堆数据：在写入之前，您不应从堆中的任何地址读取数据。
- 如果在 mdriver 和 mdriver-emulate 之间的某个追踪中利用率不同，将扣除30分。
- 如果您的程序使用超过128字节的全局数据（请参阅第5节的编程规则），则最多扣除20分。

此外，检查点提交将根据 mm checkheap 的实施质量授予10分。堆检查程序仅适用于检查点提交，不适用于最终提交。

堆检查程序应该检查以下内容：
- 检查堆（隐式列表、显式列表、分离列表）：
   - 检查尾部和首部块。
   - 检查每个块的地址对齐。
   - 检查块是否在堆边界内。
   - 检查每个块的头部和尾部：大小（最小大小）、前一个/后一个分配/空闲位一致性、头部和尾部是否相匹配。
   - 检查合并：堆中没有连续的空闲块。
- 检查空闲列表（显式列表、分离列表）。

这些得分和扣分标准用于评估您的 Malloc Lab 提交的性能和正确性。


以下是关于代码样式的规定：

代码样式将根据您的最终提交进行评分，获得12分。

在malloclab中特别需要注意的一些要点包括：

- 版本控制：您必须使用Git定期提交您的代码。这允许您跟踪您的更改、还原到较旧版本的代码，并定期提醒自己您所做的更改及其原因。关于Git使用的具体指导，请参阅样式指南。根据您的提交频率和消息质量，将奖励2分。
- 模块化：您的代码应该分解为函数，并尽量少使用全局变量。您应该使用静态函数和声明的结构体和联合体来最小化指针算术，并将其隔离到少数地方。
- 魔法数字：应避免在代码中使用数字常量。相反，使用#define或静态常量进行声明。尽量使用C数据类型和sizeof和offsetof操作符来定义各个字段和偏移量的大小，而不是使用固定的数值。
- 头部注释：您的mm.c文件必须以头部注释开头，概述您的自由块和分配块的结构，自由列表的组织方式以及您的分配器如何操作自由列表。
- 函数注释：除了概述头部注释外，每个函数前面必须有一个函数注释，描述函数的作用。确保查阅课程样式指南：我们期望对于每个函数，您至少记录其目的、参数、返回值以及任何相关的前提条件或后置条件。
- 内联注释：您将需要使用内联注释来解释代码流程或棘手的代码。

代码样式的良好实践有助于使您的代码更加可读和易于维护，因此请务必遵循相关规定。

以下是有关提交说明的内容：

确保您的代码在正常运行时不打印任何内容，并且已禁用所有调试宏。确保您已经将最新版本的代码提交并推送到GitHub。

要提交您的代码，请运行`make submit`或将您的`mm.c`文件上传到Autolab。只会对您提交的最后一个版本进行评分。

此外，还要注意以下几点：

- 您的代码应该是模块化、健壮的，并且易于扩展。您应该能够轻松更改定义分配器的各种参数，而不需要实际更改程序的运行方式。例如，您应该能够以最小的修改任意更改分离列表的数量。
- 请使用`clang-format`工具来格式化您的代码，它会根据`.clang-format`配置文件自动重新格式化您的代码。要调用它，请运行`make format`命令。您可以更改配置设置以匹配您的所需格式。有关更多信息，请参阅样式指南。

遵循这些提交指南以确保您的代码能够被准确地评估和分级。


以下是一些关于处理malloc实验的有用提示：

- 在`mm.c`中定义了调试宏，提供了诸如`dbg_assert`等约定函数。我们鼓励您广泛使用这些约定来验证不变量并确保代码的正确性。

- 使用驱动程序的 `-c` 和 `-f` 选项来运行单个跟踪。在初始开发过程中，使用短跟踪文件将简化调试和测试。

- 使用驱动程序的详细模式。 `-V` 选项还将指示何时处理每个跟踪文件，这将有助于您隔离错误。

- 使用gdb来帮助您进行调试。这将帮助您隔离和识别超出边界的内存引用。在调试时，使用编译了 `-O0` 标志以禁用优化的 `mdriver-dbg` 二进制文件。

- 使用Clang静态分析器。Clang静态分析器能够在编译时找到并定位一些错误，并为这些错误提供解释。要使用它，请运行 `make clean`，然后运行 `/usr/local/depot/llvm-7.0/bin/scan-build make` 并查找在您的 `mm.c` 中发现的错误。

- 使用gdb的 watch 命令来查找更改了某个您不希望更改的值的原因。

- 通过使用结构体和联合体减少复杂的指针算术。尽管您的数据结构将以压缩形式实现在堆内，但您应该尽量使它们看起来尽可能常规，使用结构体和联合体声明来编码不同的字段。基线实现中展示了这种风格的示例。

- 封装您的指针操作在函数中。内存管理器中的指针算术因为需要进行大量的类型转换而令人困惑和容易出错。通过为指针操作编写函数，您可以显着减少复杂性。在`mm.c`中查看示例代码。请记住：您不允许定义宏——教科书中的代码不符合我们的编码标准。

- 您的分配器必须适用于64位地址空间。`mdriver-emulate` 将专门测试这个功能。您应该为所有指针和大小字段分配完整的8字节。（您可以利用由于对齐要求而导致的某些值的低阶位为零的特性。）确保您不会无意中使用表达式 `1<<32` 等来触发32位算术，而不是 `1L<<32`。



这个实验有一个相当重要的实现部分，比之前的实验复杂得多。请期望需要花费数小时来调试问题 — 没有绕过这一点的方法。

助教将不会：
• 逐行查看您的程序以确定问题出在哪里。
• 阅读您的代码以确定您所做的一切是否正确。问题太多，我们无法查看每个人的程序。

助教将会：
• 帮助您有效地使用GDB来监视程序的状态。
• 对您正在做的事情进行概念上的讨论。

在TA前来帮助您之前，以下是一些有用的准备工作：
• 一个详尽的堆栈检查器，用于详细测试您的实现。
• 数据结构的文档（草图非常有用！）
• 对您所遇到问题的详细描述，以及到目前为止您已经尝试了什么（不要说“我的malloc不起作用，我不知道为什么”）

作为提醒，请查看课程网站上的办公时间安排。尽早开始，这样您就可以尽早获得帮助！


您必须设计算法和数据结构来管理自由块，以实现空间利用率和速度的正确平衡。这涉及到一种权衡，可以通过分配块并永不释放它们来编写一个快速的分配器，或者可以仔细地将块紧密地打包在一起以实现高利用率的分配器。您必须努力将浪费的空间最小化，同时使程序运行速度更快。

如教材和讲座所述，由于碎片化，利用率降低到100%以下，有两种不同的形式：
• 外部碎片：已分配块之间或堆的末尾的未使用空间
• 内部碎片：分配块内部的空间，不能用于存储数据，因为它需要用于一些管理器的数据结构（例如标头、尾部和空闲列表指针），或者因为必须分配额外的字节以满足对齐或最小块大小要求

为了减少外部碎片，您将希望实施良好的块放置启发式方法。为了减少内部碎片，有助于尽量减少数据结构的存储。

最大化吞吐量需要确保您的分配器能够快速找到合适的块。这涉及构建比提供的代码中找到的更复杂的数据结构。但是，您的代码不必使用任何奇特的数据结构，比如搜索树。我们的参考实现只使用了单链表和双链表。

以下是我们建议您在满足检查点和最终版本要求时采用的策略：
• 检查点。提供的代码已经满足了所需的利用性能，但吞吐量很低。您可以通过将其转换为显式列表分配器，然后将其转换为分离的自由列表分配器来实现所需的吞吐量。这两个更改都不会对您的利用率产生太大影响。
您将需要尝试不同的分配策略。提供的代码实现了首次适配搜索。某些分配器尝试最佳适配搜索，但这很难实现高效。您可以找到方法来将最佳适配搜索的元素引入首次适配分配器中，同时保持搜索量有界。
根据您将新释放的块放在自由列表的开始还是结尾，您可以实施后进先出（LIFO）或先进先出（FIFO）的队列原则。您应该尝试两者。
• 最终版本。在检查点版本的基础上，您必须大大提高利用率并保持高吞吐量。您必须减少外部和内部碎片。减少外部碎片需要实现接近最佳适配分配。减少内部碎片需要减少数据结构开销。有多种方法可以实现这一点，每种方法都有其挑战。可能的方法及其相关挑战包括：
– 消除已分配块中的尾部。但是，您仍然需要能够实现合并。请参阅教材第852页关于此优化的讨论。
– 减小最小块大小。但是，您必须管理太小以至于无法容纳双链自由列表指针的自由块。
– 为小型、固定大小的块设置特殊的内存区域。但是，您需要管理这些块，并且只能在给定其有效负载起始地址时释放块。
有关这些优化的定量结果的近似预期，请参阅附录A.1。
关于如何实施和调试您的软件包的一些建议将在讲座和复习中涵盖，以及在Malloc Lab Bootcamp中。

祝好运！










A A.1
性能评估
来自优化的近似预期结果
 优化
隐式列表（入门代码） 显式自由列表 分离的自由列表 更好的适应算法 消除已分配块中的尾部 减小块大小/小块 压缩标头
机器依赖性
利用率 吞吐量
 59% -3
- 59% +9% +6% +2%
10-100 2000-5000 11000 可变 - -20%
-
A.2
您会发现，根据运行程序的机器的CPU型号，您的程序会得到不同的吞吐量值。我们的评估代码通过将您的程序的性能与我们为检查点和最终版本编写的实现进行比较，以弥补这些差异。它可以以两种不同的方式确定执行程序的机器的参考性能。首先，它查看文件throughputs.txt，看它是否有执行CPU的记录。（Linux机器包含一个包含有关CPU型号信息的文件/proc/cpuinfo。）其次，如果找不到此信息，它将运行作为提供的文件的一部分包含的参考实现。
已为Shark机器的CPU以及Autolab服务器使用的CPU型号生成了吞吐量信息，我们将其称为“Autolab C”。所使用的不同CPU类型如下：
 名称
Shark Autolab C
ID Intel(R)Xeon(R)CPUE5520@2.27GHz Intel(R)Xeon(R)Gold6132CPU@2.60GHz
类别 Intel Xeon Intel Xeon
型号
E5520 Gold 6132
时钟（GHz） 2.27 2.60
  当mdriver运行时，它将打印出CPU型号ID（/proc/cpuinfo中的信息的压缩版本）以及该CPU型号的基准吞吐量。
A.3 性能积分
考虑到内存和CPU周期都是昂贵的系统资源，我们将这两个度量合并为一个性能指标P，其中0≤P≤100，计算为空间利用率和吞吐量的加权和：
   U−Umin 
+ (1 − w) · Threshold
 T−Tmin 
T − T max min
P (U, T ) = 100 w · Threshold U − U max
min
   3- 表示没有变化。

B.1 查看没有辅助函数的堆
在调试程序gdb中，可以用来追踪内存分配器中的错误。我们希望在课程的这一阶段，您已经熟悉了gdb的许多功能。您将希望充分利用它们。
不幸的是，在运行mdriver-emulate时，不能使用正常的gdb命令来查看堆。在本附录中，我们将介绍如何使用gdb与您的程序一起使用，并描述一个辅助函数，该函数可用于使用gdb查看mdriver和mdriver-emulate的堆。在本教程中，我们使用mm.c中的代码作为参考实现。
B.1 在没有辅助函数的情况下查看堆
要查看在调用free时块的标头的典型gdb会话可能如下所示。在下面的示例中，用户键入的所有斜体文本。已编辑会话以删除打印输出的一些无趣部分。
linux> gdb mdriver
(gdb) break mm ̇free
Breakpoint 1 at 0x4043a1: file mm.c, line 288.
(gdb) run -c traces/syn-array-short.rep
Breakpoint 1, mm_free (bp=bp@entry=0x80000eac0) at mm.c:288 (gdb) print bp
$1 = (void *) 0x80000eac0
(gdb) print /x *((unsigned long *) bp - 1)
$2 = 0x41a1
(gdb) quit
这个会话值得注意的几个方面：
• gdb中的名为“free”的函数在其未别名的形式“mm_free”中为gdb所知。您可以看到，别名是通过文件开头的宏定义引入的。当您使用gdb时，您将引用未别名的函数名称。 mm.c中的其他重要函数的未别名名称包括：mm_malloc、mm_realloc、mm_calloc、mem_memset和mem_memcpy。
• gdb命令“print /x *((unsigned long *) bp - 1)”首先将free的参数强制转换为unsigned long型指针。然后，它将该指针减小，指向块头，然后以十六进制格式打印它。
• 打印的值0x41a1表示该块的大小为0x41a0（十进制16,800），并且较低阶位已设置为指示块已分配。查看跟踪文件，您将看到要释放的块具有16,784字节的有效负载。这需要分配大小为16,800的块，以容纳标头、有效负载和页脚。

当我们尝试在mdriver-emulate中使用相同的方法时，情况并不那么顺利。在这种情况下，我们使用一个具有大型分配的跟踪之一，但在任何跟踪中都会遇到相同的问题。
linux> gdb mdriver-emulate
(gdb) break mm ̇free
Breakpoint 1 at 0x4043b7: file mm.c, line 285.
(gdb) run -c traces/syn-giantarray-short.rep
Breakpoint 1, mm_free (bp=bp@entry=0x23368bd380eb2cb0) at mm.c:285 (gdb) print bp
$1 = (void *) 0x23368bd380eb2cb0
(gdb) print /x *((unsigned long *) bp - 1)
Cannot access memory at address 0x23368bd380eb2ca8
(gdb) quit
问题在于bp设置为0x23368bd380eb2cb0，约为2.54×1018，远远超出了机器支持的虚拟地址范围。mdriver-emulate程序使用了稀疏内存技术，以提供完整的64位地址空间的幻象，因此它支持非常大的指针值。但是，实际寻址具有100 MB实际内存使用的总体限制。
B.2 使用hprobe辅助函数查看堆
为了支持在调试内存的正常版本和模拟版本时使用gdb，我们创建了一个具有以下原型的函数：
void hprobe(void *ptr, int offset, size_t count);
该函数将打印从summing ptr和offset给定的地址开始的count字节。具有单独的offset参数可以避免在查询中进行指针算术。
以下是在mdriver中使用hprobe的示例：
linux> gdb mdriver
(gdb) break mm ̇free
Breakpoint 1 at 0x4043a1: file mm.c, line 288.
(gdb) run -c traces/syn-array-short.rep
Breakpoint 1, mm_free (bp=bp@entry=0x80000eac0) at mm.c:288 (gdb) print bp
$1 = (void *) 0x80000eac0
(gdb) print hprobe(bp, -8, 8)
Bytes 0x80000eabf...0x80000eab8: 0x00000000000041a1
(gdb) quit


请注意，hprobe是使用free的参数作为指针，偏移量为-8，计数为8来调用的。该函数打印的字节以最高有效字节在左侧显示，就像正常打印数字值一样。地址范围显示为HighAddr...LowAddr。我们可以看到打印的值与使用指针算术打印的值相同，但添加了前导零。

相同的命令序列适用于mdriver-emulate：
linux> gdb mdriver-emulate
(gdb) break mm_free
Breakpoint 1 at 0x4043b7: file mm.c, line 285.
(gdb) run -c traces/syn-giantarray-short.rep
Breakpoint 1, mm_free (bp=bp@entry=0x23368bd380eb2cb0) at mm.c:285 (gdb) print bp
$1 = (void *) 0x23368bd380eb2cb0
(gdb) print hprobe(bp, -8, 8)
Bytes 0x23368bd380eb2caf...0x23368bd380eb2ca8: 0x00eb55b00c8f1ed1 (gdb) quit
标头的内容表示块大小为0xeb55b00c8f1ed0（十进制66,240,834,140,315,344），最低有效位设置为指示块已分配。查看跟踪时，我们可以看到要释放的块的有效负载为66,240,834,160,315,328字节。标头和页脚还需要额外的16字节。

成为高效的程序员的一部分是利用可用的工具。许多初学者程序员在代码中充满了打印语句。虽然这可以是一种有用的方法，但通常更高效的方法是使用调试器，例如gdb。使用hprobe辅助函数，您可以在驱动程序程序的两个版本上使用gdb。

