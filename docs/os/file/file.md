### 文件系统结构

在大多数 UNIX 文件系统中，可用的磁盘空间被划分为两种主要类型的区域：inode 区域和数据区域。每个文件在文件系统中都会被分配一个 inode，这个 inode 保存了关于文件的关键元数据，例如它的 stat 属性和指向其数据块的指针。数据区域则被划分为更大的数据块（通常是 8KB 或更大），文件系统在这些数据块中存储文件数据和目录元数据。

目录条目包含文件名和指向 inode 的指针。如果文件系统中的多个目录条目引用同一个文件的 inode，那么这个文件就被称为硬链接。

### 目录条目

目录条目（Directory Entry）是文件系统中的一个重要概念，它在文件系统中表示一个文件或目录。在 UNIX 和类 UNIX 系统中，目录条目主要包含以下两部分信息：

1. 文件名：这是用户用来识别文件的名称。

2. inode 指针：这是一个指向 inode 结构的指针，inode 结构包含了文件的元数据，如文件大小、文件类型（普通文件、目录、链接等）、文件权限、文件创建和修改时间等。inode 还包含了指向文件数据块的指针，这些数据块中存储了文件的实际内容。

当文件系统中的多个目录条目引用同一个 inode 时，这些目录条目对应的文件被称为硬链接。这意味着，这些文件在文件系统中有多个名称和位置，但它们共享同一份数据和元数据。

### JOS 的文件系统结构

然而，JOS 的文件系统不支持硬链接，因此可以进行一种方便的简化：JOS 的文件系统根本不使用 inode，而是直接在描述该文件的（唯一的）目录条目中存储所有的文件（或子目录）元数据。这意味着我们的文件系统在设计上更为简单，因为我们不需要处理 inode 和硬链接的复杂性。

在许多文件系统中，每个文件都有一个 inode（索引节点），它是一个数据结构，包含了文件的元数据，如文件大小、创建时间、修改时间等，以及指向文件数据块的指针。这种设计允许文件系统支持硬链接，即多个目录条目可以指向同一个 inode，从而共享同一份文件数据。

然而，JOS 文件系统采取了一种更简化的设计。在 JOS 文件系统中，每个文件的元数据直接存储在描述文件的目录条目中，而不是存储在单独的 inode 中。这意味着在 JOS 文件系统中，每个目录条目都直接关联到一份文件数据，而不是通过 inode 间接关联。这种设计使得 JOS 文件系统无法支持硬链接，但同时也避免了处理 inode 和硬链接的复杂性，使得文件系统的设计和实现更为简单和直接。

### 数据块

在 JOS 的文件系统中，文件和目录都由一系列数据块组成，这些数据块可能分布在磁盘的各个地方。这种布局类似于操作系统中的虚拟内存管理，其中进程的虚拟地址空间的页面可以分散在物理内存中。

文件系统进程为用户提供了一个抽象层，隐藏了这些块布局的细节。用户可以在文件中的任意偏移处读写字节序列，而不需要关心这些字节实际上是存储在哪个磁盘块中。当执行诸如文件创建和删除等操作时，文件系统进程会负责所有的目录修改。

在许多操作系统中，文件系统通常会提供一些特殊的系统调用，用于执行诸如列出目录内容（即 ls 程序）这样的操作。然而，在 JOS 操作系统中，文件系统并没有提供这样的特殊系统调用。

相反，JOS 的文件系统允许用户进程直接使用 read 系统调用来读取目录的元数据。元数据是描述文件或目录属性的数据，例如文件的大小、创建时间、修改时间等。在 JOS 文件系统中，目录的元数据包含了目录中所有文件的信息，例如文件名、文件大小等。

因此，用户进程可以通过直接读取目录的元数据，然后解析这些元数据，来获取目录中所有文件的信息。这样，用户进程就可以自己实现 ls 程序，而不必依赖于文件系统提供的特殊系统调用。

这种设计使得 JOS 的文件系统更为简单和灵活，但同时也要求用户进程具有解析目录元数据的能力。

然而，这种设计也有一个缺点。由于用户进程需要直接解析目录元数据，这就使得用户进程必须了解元数据的格式。如果文件系统的内部布局（即元数据的格式）发生改变，那么所有直接解析元数据的用户进程都可能需要进行修改或者重新编译，以适应新的元数据格式。这会增加维护的复杂性，并可能导致兼容性问题。

这就是为什么大多数现代的 UNIX 变体不鼓励这种设计的原因。在这些系统中，文件系统通常会提供一些特殊的系统调用，用于执行诸如列出目录内容这样的操作。这样，用户进程就无需直接解析元数据，而只需要调用这些系统调用即可。这种设计使得文件系统的内部布局可以更加灵活地进行修改和优化，而无需影响到用户进程。

### 超级块

超级块是文件系统中的特殊磁盘块，它们存储了描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的元数据、最后一次挂载文件系统的时间、最后一次检查文件系统错误的时间等。这些特殊的块通常位于磁盘的"易于找到"的位置（例如磁盘的开头或结尾）。

在我们的文件系统中，将只有一个超级块，它总是位于磁盘上的块 1 的位置。它的布局由 `inc/fs.h` 中的 `struct Super`定义。

```c
struct Super {
	uint32_t s_magic;		// 魔数：FS_MAGIC，用于标识文件系统
	uint32_t s_nblocks;		// 磁盘上的总块数
	struct File s_root;		// 根目录节点
};
```

块 0 通常被保留用于存放引导加载器和分区表。引导加载器是在计算机启动时运行的一段小程序，它的任务是加载操作系统的内核并将控制权交给内核。分区表则是存储在磁盘上的一个数据结构，它描述了磁盘的分区布局，例如每个分区的开始位置、大小等信息。由于这些信息是在计算机启动时需要的，因此它们通常被存放在磁盘的第一个块中，这样引导加载器可以很容易地找到它们。

然后，许多"真实"的文件系统会维护多个 superblocks，并且这些 superblocks 会在磁盘的几个广泛分布的区域中复制。superblock 是文件系统的一个重要组成部分，它包含了文件系统的一些元信息，例如文件系统的大小、空闲和已使用的块的数量、根目录的位置等。通过在磁盘的不同区域复制 superblock，可以增加文件系统的健壮性。如果某个区域的 superblock 被损坏，或者磁盘在该区域发展出媒体错误，那么文件系统可以使用其他区域的 superblock 来继续正常运行。

### 文件

`struct File`结构体在`inc/fs.h`文件中定义，它用于描述文件的元数据，包括文件的名称、大小、类型以及文件的块指针。

```c
struct File {
	char f_name[MAXNAMELEN];	// 文件名
	off_t f_size;			// 文件大小，以字节为单位
	uint32_t f_type;		// 文件类型

	// 块指针。
	// 当且仅当其值不等于0时，块被分配。
	uint32_t f_direct[NDIRECT];	// 直接块
	uint32_t f_indirect;		// 间接块

	// 填充至256字节；在编译fsformat时必须进行计算
	// 以防我们在64位机器上编译。
	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];
} __attribute__((packed));	// 仅在某些64位机器上需要
```

在这个文件系统设计中，元数据存储在磁盘上的目录条目中，而不是 inode 中，这与许多"真实"的文件系统有所不同。这种设计的目的是为了简化文件系统的实现，因此无论元数据是在磁盘上还是在内存中，都使用同一个`struct File`结构体来表示。

`struct File`中的`f_direct`数组是一个直接块指针数组，它包含了文件的前 10 个块的块号。这意味着，对于小于或等于 40KB 的文件（每个块的大小为 4096 字节），其所有的块号都可以直接存储在`struct File`结构体中。

然而，对于大于 40KB 的文件，我们需要一个额外的空间来存储文件的其余块号。这就需要使用到间接块。间接块是一个额外分配的磁盘块，它可以存储多达 1024 个额外的块号。这样，文件系统就可以支持最大为 1034 个块，也就是稍微超过 4MB 的文件。

需要注意的是，这种设计只支持到间接块，如果要支持更大的文件，"真实"的文件系统通常还会支持双重间接块和三重间接块。这些设计可以进一步扩展文件系统支持的文件大小，但同时也会增加文件系统的复杂性。

### 目录与常规文件

在我们的文件系统中，File 结构体可以表示一个常规文件或一个目录；这两种类型的"文件"通过 File 结构体中的 type 字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它不会解析与常规文件关联的数据块的内容，而文件系统会将目录文件的内容解析为一系列描述目录内文件和子目录的 File 结构体。

我们的文件系统中的超级块包含一个 File 结构体（struct Super 中的 root 字段），它保存了文件系统根目录的元数据。这个目录文件的内容是一系列描述文件系统根目录内的文件和目录的 File 结构体。根目录中的任何子目录可能会包含更多代表子子目录的 File 结构体，依此类推。

### 磁盘访问

在传统的宏内核操作系统中，通常会在内核中添加 IDE 磁盘驱动器，并提供必要的系统调用以允许文件系统访问它。然而，这里采取的策略是将 IDE 磁盘驱动器作为用户级文件系统进程的一部分来实现，这意味着磁盘访问的功能实际上是在用户空间而不是内核空间中实现的。

为了让文件系统进程具有实现磁盘访问所需的权限，需要对内核进行一些修改。这种修改的目的是为了设置适当的权限，使得文件系统进程可以直接访问磁盘。

这里提到的"程序化 I/O"（PIO）基础的磁盘访问是一种轮询机制，即文件系统进程会不断检查磁盘是否已经准备好进行读写操作。这种方式的优点是实现简单，但缺点是效率较低，因为在磁盘准备好之前，文件系统进程会一直在等待。

另一种方式是使用磁盘中断，即当磁盘准备好进行读写操作时，会产生一个中断信号，内核会捕获这个中断并通知文件系统进程。这种方式的优点是效率较高，但实现起来更复杂，因为需要在内核中处理设备中断并将它们分派到正确的用户模式进程。虽然在用户模式下实现中断驱动的设备驱动程序更困难，但一些先进的操作系统（如 L3 和 L4 内核）已经实现了这种功能。

### 访问权限

在 x86 架构中，EFLAGS 寄存器是一个 32 位的寄存器，用于存储一些状态标志，如进位标志、零标志、符号标志等。其中，IOPL（I/O 特权级别）位是 EFLAGS 寄存器中的两个位，用于确定当前运行的代码是否有权限执行特殊的设备 I/O 指令，如 IN 和 OUT。

IN 和 OUT 指令用于在 CPU 和 I/O 设备之间传输数据。IN 指令从一个 I/O 设备读取数据到一个 CPU 寄存器，而 OUT 指令将数据从一个 CPU 寄存器写入到一个 I/O 设备。

在受保护模式下，只有当当前特权级别（CPL）小于或等于 IOPL 时，才允许执行 IN 和 OUT 指令。否则，如果试图执行这些指令，处理器将产生一个异常。

在这段内容中，提到的 IDE 磁盘寄存器位于 x86 的 I/O 空间，而不是内存映射。这意味着，为了让文件系统进程能够访问这些寄存器，我们需要给它 I/O 权限，即设置 EFLAGS 寄存器中的 IOPL 位。

然而，IOPL 位提供的是一种全局的权限控制，即要么所有用户模式的代码都可以访问 I/O 空间，要么都不可以。在这种情况下，我们希望只有文件系统进程能够访问 I/O 空间，而其他进程则不能。这就需要我们在设计操作系统时，对不同的进程设置不同的 IOPL 级别，以实现对 I/O 空间访问的精细控制。

### 磁盘缓存

文件系统中使用了虚拟内存系统来实现一个简单的块缓存。这个块缓存的代码位于`fs/bc.c`文件中。

在这个文件系统中，处理器的虚拟内存系统被用来实现一个块缓存。块缓存是一种缓存策略，它将磁盘上的数据块缓存到内存中，以提高读写性能。当需要读取或写入一个数据块时，首先会在块缓存中查找这个数据块。如果找到了，就直接从缓存中读取或写入数据，而不需要访问磁盘。如果没有找到，就需要从磁盘中读取这个数据块，并将其添加到块缓存中。

在这个文件系统中，为了实现块缓存，预留了一个大的、固定的 3GB 的虚拟地址空间，用来作为磁盘的"内存映射"版本。这个地址空间的范围是从 0x10000000（DISKMAP）到 0xD0000000（DISKMAP+DISKMAX）。在这个地址空间中，每个磁盘块都有一个对应的虚拟地址。例如，磁盘块 0 对应的虚拟地址是 0x10000000，磁盘块 1 对应的虚拟地址是 0x10001000，依此类推。`fs/bc.c`文件中的`diskaddr`函数实现了从磁盘块号到虚拟地址的转换。

这种设计的一个优点是，可以将整个磁盘看作是在内存中。当需要读取或写入一个数据块时，只需要访问这个数据块对应的虚拟地址即可。这样，就可以避免了直接访问磁盘的开销。但是，由于内存的大小通常远小于磁盘的大小，所以并不可能将整个磁盘都加载到内存中。因此，这个文件系统实现了一种需求分页的形式，只有当访问一个数据块时，才会将这个数据块从磁盘加载到内存中。

这种设计的一个限制是，只能处理 3GB 或更小的磁盘。这是因为预留的虚拟地址空间的大小是 3GB。对于大于 3GB 的磁盘，这种设计就无法处理了。然而，在具有 64 位地址空间的机器上，这种限制就不存在了，因为 64 位地址空间的大小远大于 3GB。

### 从磁盘加载到内存

当试图访问的磁盘块没有被加载到内存中时，就会触发页面错误，然后调用自定义的 `bc_pgfault` 函数。

函数首先获取页面错误的地址`utf->utf_fault_va`，并计算出这个地址对应的磁盘块号。

然后，函数检查页面错误的地址是否在块缓存区域内。如果不在，就会触发 panic。

接着，函数检查磁盘块号是否有效。如果磁盘块号超过了磁盘的总块数，也会触发 panic。

然后，函数会在磁盘映射区域分配一个新的页面，并从磁盘中读取相应的块到这个新页面中。这里首先将地址向下舍入到页面边界，然后调用`sys_page_alloc`函数分配一个新的页面。然后，调用`ide_read`函数从磁盘中读取数据到新分配的页面中。

接下来，函数会清除新分配页面的脏位，因为刚从磁盘中读取的数据块是最新的，没有被修改过，所以不是脏的。这里调用`sys_page_map`函数将新分配的页面映射到同一个地址，同时清除脏位。

最后，函数会检查我们刚刚读取的磁盘块是否已经被分配。如果这个磁盘块是空闲的，也就是说，它没有被分配给任何文件，那么试图读取它就是一个错误，需要触发 panic。

总的来说，这个函数的作用是处理页面错误，当试图访问的磁盘块没有被加载到内存中时，它会分配一个新的页面，并从磁盘中读取数据到这个新页面中。

### 将数据从内存写入到磁盘

`flush_block` 函数的作用是将包含特定虚拟地址（VA）的块（如果需要）刷新到磁盘，并使用`sys_page_map`清除 PTE_D 位。如果该块不在块缓存中或者不是脏的（即没有被修改过），则该函数不执行任何操作。

函数首先计算出虚拟地址对应的磁盘块号。然后，检查虚拟地址是否在磁盘映射区域内，如果不在，则会触发 panic。

接着，函数将虚拟地址向下舍入到页面边界。然后，检查这个地址是否已经被映射到内存中，以及这个地址是否是脏的。如果地址没有被映射到内存中，或者地址不是脏的，那么函数就直接返回，不执行任何操作。

如果地址已经被映射到内存中，并且地址是脏的，那么函数就会将包含这个地址的磁盘块写回到磁盘。这里调用`ide_write`函数将数据写回到磁盘。

最后，函数会清除新写入磁盘的页面的脏位，因为这个页面已经被写回到磁盘，所以不再是脏的。这里调用`sys_page_map`函数将页面映射到同一个地址，同时清除脏位。

总的来说，这个函数的作用是将修改过的数据（即脏的数据）写回到磁盘，以确保内存中的修改能够被持久化到磁盘中。

### 文件系统初始化

这段代码是文件系统的初始化函数`fs_init`。

首先，它使用`static_assert`来确保`struct File`的大小为 256 字节。

然后，它尝试找到一个 JOS 磁盘。如果有第二个 IDE 磁盘（编号为 1）可用，就使用它；否则，就使用第一个 IDE 磁盘（编号为 0）。

接着，它调用`bc_init`函数来初始化块缓存。

然后，它将全局变量`super`设置为指向超级块的地址。超级块是文件系统的元数据，包含了文件系统的一些基本信息，如文件系统的总块数、空闲块数等。这里，超级块位于磁盘的第 1 个块。

接着，它调用`check_super`函数来验证超级块的有效性。如果超级块无效，`check_super`函数会触发 panic。

然后，它将全局变量`bitmap`设置为指向第一个位图块的地址。位图块用于记录文件系统中每个块的使用情况。在这个文件系统中，位图块位于磁盘的第 2 个块。

最后，它调用`check_bitmap`函数来验证位图的有效性。如果位图无效，`check_bitmap`函数会触发 panic。

总的来说，这个函数的作用是初始化文件系统，包括选择磁盘、初始化块缓存、设置并验证超级块和位图等。

### bitmap

`bitmap`在文件系统中的作用是跟踪磁盘上每个块的使用情况。它是一个位数组，每个位对应磁盘上的一个块。如果位被设置为 1，那么对应的块就被认为是已使用的；如果位被设置为 0，那么对应的块就被认为是空闲的。

这种设计使得文件系统可以快速地找到空闲的块来存储新的数据，也可以快速地检查一个块是否被使用。例如，`block_is_free`函数就是通过检查`bitmap`中对应的位来判断一个块是否空闲。

在初始化文件系统时，`bitmap`被设置为指向磁盘上的第一个位图块。这是因为在这个文件系统中，第 0 个块是保留块，第 1 个块是超级块，第 2 个块开始是位图块。所以`bitmap = diskaddr(2);`就是将`bitmap`指向第一个位图块。

总的来说，`bitmap`是文件系统管理磁盘使用情况的重要工具。

### 使用 bitmap 来管理磁盘块

`alloc_block` 函数的功能是在文件系统的位图中寻找一个空闲的块，并将其分配出去。位图是一个数据结构，用于跟踪文件系统中每个块的使用情况。每个位对应一个块，如果位被设置为 1，那么对应的块就被认为是已使用的；如果位被设置为 0，那么对应的块就被认为是空闲的。

以下是这段代码的详细解释：

1. `uint32_t bmpblock_start = 2;`：定义了位图块在磁盘上的起始块号，这里是 2。

2. `for (uint32_t blockno = 0; blockno < super->s_nblocks; blockno++)`：遍历所有的磁盘块。

3. `if (block_is_free(blockno))`：使用`block_is_free`函数检查当前块是否空闲。

4. `bitmap[blockno / 32] &= ~(1 << (blockno % 32));`：如果当前块是空闲的，就将其标记为已使用。这里使用了位操作来修改位图中的相应位。

5. `flush_block(diskaddr(bmpblock_start + (blockno / 32) / NINDIRECT));`：将更改后的位图块刷新到磁盘。这里使用了`diskaddr`函数来获取位图块在内存中的地址，然后使用`flush_block`函数将其刷新到磁盘。

6. `return blockno;`：返回分配的块号。

7. `return -E_NO_DISK;`：如果所有的块都已经被使用，就返回`-E_NO_DISK`表示磁盘已满。

总的来说，这段代码的作用是在文件系统的位图中寻找一个空闲的块，将其标记为已使用，并将更改后的位图块刷新到磁盘。

### 文件操作

现在我们已经在文件系统进程中实现了必要的功能，我们必须使其他希望使用文件系统的进程可以访问它。由于其他进程不能直接调用文件系统进程中的函数，我们将通过远程过程调用（RPC）抽象来暴露对文件系统进程的访问，该抽象建立在 JOS 的 IPC 机制之上。从图形上看，调用文件系统服务器（例如，读取）的过程如下所示：

```
      常规进程           FS进程
   +---------------+   +---------------+
   |      read     |   |   file_read   |
   |   (lib/fd.c)  |   |   (fs/fs.c)   |
...|.......|.......|...|.......^.......|...............
   |       v       |   |       |       | RPC机制
   |  devfile_read |   |  serve_read   |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |     fsipc     |   |     serve     |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |   ipc_send    |   |   ipc_recv    |
   |       |       |   |       ^       |
   +-------|-------+   +-------|-------+
           |                   |
           +-------------------+
```

这段内容描述的是一个文件系统进程中的读取操作的过程。这个过程涉及到两个进程：常规进程和文件系统进程。在这个过程中，一个读取请求从常规进程传递到文件系统进程，然后返回结果。

首先，我们有一个名为`read`的函数，它可以在任何文件描述符上工作。这个函数的工作就是将读取操作分派到适当的设备读取函数，这里是`devfile_read`。`devfile_read`函数专门用于读取磁盘上的文件。在`lib/file.c`中，我们有一系列的`devfile_*`函数，它们实现了文件系统操作的客户端。这些函数的工作方式大致相同，它们将参数打包到一个请求结构中，然后调用`fsipc`函数发送 IPC 请求，并解包返回的结果。`fsipc`函数的工作就是处理发送请求到服务器和接收回复的常见细节。

文件系统服务器的代码可以在`fs/serv.c`中找到。在这个文件中，有一个名为`serve`的函数，它的工作就是无休止地通过 IPC 接收请求，将请求分派到适当的处理函数，并通过 IPC 发送结果回去。在读取操作的示例中，`serve`函数将请求分派到`serve_read`函数。`serve_read`函数将处理特定于读取请求的 IPC 细节，如解包请求结构，并最终调用`file_read`函数来实际执行文件读取操作。

回想一下，JOS 的 IPC 机制允许进程发送一个单独的 32 位数字，并且可以选择共享一个页面。为了从客户端向服务器发送请求，我们使用 32 位数字作为请求类型（文件系统服务器 RPC 就像系统调用一样编号），并将请求的参数存储在通过 IPC 共享的页面上的一个联合 Fsipc 中。在客户端，我们总是在 fsipcbuf 处共享页面；在服务器端，我们将传入的请求页面映射到 fsreq（0x0ffff000）。

服务器也通过 IPC 发送响应。我们使用 32 位数字作为函数的返回代码。对于大多数 RPC，这就是它们返回的所有内容。FSREQ_READ 和 FSREQ_STAT 也返回数据，它们只需将数据写入客户端在其请求上发送的页面。由于客户端首先与文件系统服务器共享了这个页面，所以不需要在响应 IPC 中发送这个页面。此外，FSREQ_OPEN 在其响应中与客户端共享一个新的“Fd 页面”。我们稍后会回到文件描述符页面。

练习 5. 在 fs/serv.c 中实现 serve_read 。

serve_read 的主要工作将由已经实现的 fs/fs.c 中的 file_read 完成（它实际上只是一堆对 file_get_block 的调用）。serve_read 只需要为文件读取提供 RPC 接口。查看 serve_set_size 中的注释和代码，以了解服务器函数应如何构造。

使用 make grade 来测试你的代码。你的代码应该通过"serve_open/file_stat/file_close"和"file_read"，得分为 70/150。

练习 6. 在 fs/serv.c 中实现 serve_write，并在 lib/file.c 中实现 devfile_write。

使用 make grade 来测试你的代码。你的代码应该通过"file_write"，"file_read after file_write"，"open"，和"large file"，得分为 90/150。

产生进程
我们已经给你提供了 spawn 的代码（参见 lib/spawn.c），它创建一个新的进程，从文件系统中加载一个程序镜像到其中，然后启动子进程运行这个程序。父进程然后独立于子进程继续运行。spawn 函数实际上就像 UNIX 中的 fork，然后在子进程中立即执行 exec。

我们实现了 spawn 而不是 UNIX 风格的 exec，因为 spawn 更容易在用户空间中以"exokernel 方式"实现，而不需要内核的特殊帮助。思考一下你需要做什么才能在用户空间中实现 exec，并确保你理解为什么这更难。

练习 7. spawn 依赖于新的系统调用 sys_env_set_trapframe 来初始化新创建的进程的状态。在 kern/syscall.c 中实现 sys_env_set_trapframe（不要忘记在 syscall()中分派新的系统调用）。

通过从 kern/init.c 运行 user/spawnhello 程序来测试你的代码，该程序将尝试从文件系统中生成/hello。

使用 make grade 来测试你的代码。

挑战！实现 Unix 风格的 exec。

挑战！实现 mmap 风格的内存映射文件，并修改 spawn 以便在可能的情况下直接从 ELF 映像映射页面。

跨 fork 和 spawn 共享库状态

UNIX 文件描述符是一个通用概念，也包括管道、控制台 I/O 等。在 JOS 中，每种设备类型都有一个对应的 struct Dev，其中包含指向实现该设备类型的 read/write/etc.函数的指针。lib/fd.c 在此基础上实现了通用的类 UNIX 文件描述符接口。每个 struct Fd 都指示其设备类型，lib/fd.c 中的大多数函数只是将操作分派给适当的 struct Dev 中的函数。

lib/fd.c 还维护了每个应用进程地址空间中的文件描述符表区域，从 FDTABLE 开始。这个区域为每个可以同时打开的最多 MAXFD（当前为 32）个文件描述符预留了一个页面（4KB）的地址空间。在任何给定的时间，如果相应的文件描述符正在使用，特定的文件描述符表页面就会被映射。每个文件描述符还有一个可选的"数据页"，开始于 FILEDATA，设备可以选择使用。

我们希望在 fork 和 spawn 中共享文件描述符状态，但文件描述符状态保存在用户空间内存中。现在，在 fork 时，内存将被标记为写时复制，因此状态将被复制而不是共享。（这意味着进程无法在它们自己没有打开的文件中寻找，管道在 fork 中也无法工作。）在 spawn 时，内存将被遗留下来，完全不复制。（实际上，生成的进程开始时没有打开的文件描述符。）

我们将改变 fork，让它知道内存中的某些区域被"库操作系统"使用，应该始终共享。我们不会在某个地方硬编码一个区域列表，而是在页表条目中设置一个未使用的位（就像我们在 fork 中做的 PTE_COW 位一样）。

我们在 inc/lib.h 中定义了一个新的 PTE_SHARE 位。这个位是 Intel 和 AMD 手册中标记为"可供软件使用"的三个 PTE 位之一。我们将建立一个约定，如果一个页表条目设置了这个位，那么在 fork 和 spawn 中，PTE 应该直接从父进程复制到子进程。注意，这与标记为写时复制是不同的：正如第一段所描述的，我们希望确保共享对页面的更新。

练习 8. 在 lib/fork.c 中改变 duppage 以遵循新的约定。如果页表条目设置了 PTE_SHARE 位，只需直接复制映射。（你应该使用 PTE_SYSCALL，而不是 0xfff，来从页表条目中屏蔽相关的位。0xfff 会获取访问和脏位。）

同样，实现 lib/spawn.c 中的 copy_shared_pages。它应该遍历当前进程中的所有页表条目（就像 fork 一样），将设置了 PTE_SHARE 位的任何页面映射复制到子进程中。

使用 make run-testpteshare 检查你的代码是否正常运行。你应该看到"fork handles PTE_SHARE right"和"spawn handles PTE_SHARE right"这样的行。

使用 make run-testfdsharing 检查文件描述符是否正确共享。你应该看到"read in child succeeded"和"read in parent succeeded"这样的行。

键盘接口
为了使 shell 工作，我们需要一种方法来输入。QEMU 一直在显示我们写入 CGA 显示器和串行端口的输出，但到目前为止，我们只在内核监视器中输入。在 QEMU 中，图形窗口中输入的内容会作为键盘对 JOS 的输入，而控制台输入的内容会作为串行端口上的字符。kern/console.c 已经包含了从实验 1 开始就被内核监视器使用的键盘和串行驱动程序，但现在你需要将这些连接到系统的其他部分。

练习 9. 在你的 kern/trap.c 中，调用 kbd_intr 处理 trap IRQ_OFFSET+IRQ_KBD，调用 serial_intr 处理 trap IRQ_OFFSET+IRQ_SERIAL。

我们已经为你实现了控制台输入/输出文件类型，在 lib/console.c 中。kbd_intr 和 serial_intr 用最近读取的输入填充一个缓冲区，而控制台文件类型则清空缓冲区（控制台文件类型默认用于 stdin/stdout，除非用户重定向它们）。

通过运行 make run-testkbd 并输入几行来测试你的代码。当你完成它们时，系统应该将你的行回显给你。尝试在控制台和图形窗口中输入，如果你有这两个可用的话。

Shell
运行 make run-icode 或 make run-icode-nox。这将运行你的内核并启动 user/icode。icode 会执行 init，它将设置控制台作为文件描述符 0 和 1（标准输入和标准输出）。然后它将生成 sh，即 shell。你应该能够运行以下命令：

    echo hello world | cat
    cat lorem |cat
    cat lorem |num
    cat lorem |num |num |num |num |num
    lsfd

注意，用户库例程 cprintf 直接打印到控制台，而不使用文件描述符代码。这对于调试很好，但对于管道到其他程序不好。要将输出打印到特定的文件描述符（例如，1，标准输出），使用 fprintf(1, "...", ...)。printf("...", ...)是打印到 FD 1 的快捷方式。参见 user/lsfd.c 的示例。

练习 10.

shell 不支持 I/O 重定向。能够运行 sh <script 而不是手动输入脚本中的所有命令会很好。在 user/sh.c 中添加<I/O 重定向。

通过在你的 shell 中输入 sh <script 来测试你的实现

运行 make run-testshell 来测试你的 shell。testshell 只是将上述命令（也可以在 fs/testshell.sh 中找到）输入到 shell 中，然后检查输出是否与 fs/testshell.key 匹配。

挑战！为 shell 添加更多功能。可能包括（一些需要改变文件系统）：

后台命令（ls &）
每行多个命令（ls; echo hi）
命令分组（(ls; echo hi) | cat > out）
进程变量扩展（echo $hello）
引用（echo "a | b"）
命令行历史和/或编辑
制表符完成
目录，cd，和命令查找的 PATH。
文件创建
ctl-c 杀死正在运行的进程
但是，也可以做一些不在这个列表上的事情。
你的代码应该通过所有测试。像往常一样，你可以用 make grade 来评估你的提交，并用 make handin 提交你的解决方案。

这完成了实验。像往常一样，不要忘记运行 make grade 并写下你的答案和你的挑战练习解决方案的描述。提交之前，使用 git status 和 git diff 检查你的更改，不要忘记 git add answers-lab5.txt。准备好后，使用 git commit -am 'my solutions to lab 5'提交你的更改，然后 make handin 提交你的解决方案。
