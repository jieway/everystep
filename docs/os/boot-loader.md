
BIOS 最后会将 512 字节的引导扇区加载到物理地址0x7c00到 0x7dff 的内存中，然后使用指令 jmp 将 CS：IP 设置为 0000:7c00 ，将控制权传递给引导加载程序。与BIOS加载地址一样，这些地址是相当任意的 - 但它们对于PC来说是固定和标准化的。


操作系统本身也是一个程序，需要加载到内存中，Boot Loader 就是来做这件事情的。而 PC 是以扇区为单位从磁盘中读取数据的，即读取或写入数据至少都要读写一个扇区大小。Boot Loader 也是一段程序，BIOS 会将 Boot Loader 从磁盘中读取并写入内存中物理地址 0x7c00 到 0x7dff 处。Boot Loader 通常位于磁盘的第一个扇区，也被称为“引导扇区”。随后将控制权交给 Boot Loader 。

总的来说，这个过程就是电脑在启动时如何读取硬盘或软盘上的特定部分（引导扇区）并开始执行其中的代码，以便接下来加载和启动操作系统。

### Boot Loader 程序

下面是 Boot Loader 的汇编代码，接下来详细解释具体的工作细节。注意此时 BIOS 已经将控权交给了 Boot Loader ，随后开始执行。

下面是一个引导加载器的实现，主要负责将CPU从16位的实模式切换到32位的保护模式，并且准备好环境以便跳转到C语言编写的更高级的引导程序。下面是对代码的逐行解释：

1. **定义段选择器和标志**：
   - `.set PROT_MODE_CSEG, 0x8`：定义32位模式下的代码段选择器。
   - `.set PROT_MODE_DSEG, 0x10`：定义32位模式下的数据段选择器。
   - `.set CR0_PE_ON, 0x1`：定义启用保护模式的标志。

2. **开始部分**：
   - `.globl start`：声明`start`是一个全局符号，可以在其他文件中被引用。
   - `start:`：标记代码的开始位置。
   - `.code16`：告诉汇编器以下代码以16位模式汇编。
   - `cli`：禁用中断。
   - `cld`：设置字符串操作的方向为正向。

3. **设置数据段寄存器**：
   - `xorw %ax,%ax` 等几行：将数据段（DS）、附加段（ES）和栈段（SS）寄存器设置为零。

4. **启用A20线**：
   - 这一部分代码通过操作端口来启用A20线，以允许访问高于1MB的内存地址。

5. **切换到保护模式**：
   - `lgdt gdtdesc`：加载全局描述符表（GDT）。
   - 接下来的几行设置控制寄存器（CR0），并打开保护模式。

6. **长跳转到32位代码段**：
   - `ljmp $PROT_MODE_CSEG, $protcseg`：执行长跳转到标签`protcseg`，这在执行过程中切换到32位模式。

7. **设置32位模式下的数据段寄存器**：
   - `.code32`：接下来的代码以32位模式汇编。
   - 设置各种段寄存器（DS、ES、FS、GS、SS）到保护模式的数据段。

8. **调用C语言函数**：
   - 设置堆栈指针（ESP），然后调用`bootmain`，这通常是用C语言编写的引导程序的入口。

9. **无限循环**：
   - 如果`bootmain`函数返回，执行一个无限循环，防止CPU执行无效地址的代码。

10. **引导GDT定义**：
   - 定义了用于引导时的全局描述符表（GDT）及其描述符（gdtdesc）。

整体来说，这段代码是在启动过程中的关键步骤，它设置了CPU的运行环境，从实模式切换到保护模式，并准备好跳转到高级语言编写的引导程序。

