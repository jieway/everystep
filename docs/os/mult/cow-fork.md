### COW fork

Unix 通过提供 fork()系统调用作为其主要的进程创建原语。这个系统调用的功能是复制调用它的进程（我们称之为父进程）的地址空间，从而创建一个新的进程（我们称之为子进程）。地址空间是一个进程在内存中的映射，包括了进程的代码、数据、堆和栈等。

xv6 Unix 实现 fork()的方式是将父进程的所有页面（页是内存管理的基本单位）的数据复制到为子进程新分配的页面中。这种方式基本上与 dumbfork()的实现方式相同。在这个过程中，最耗时的部分就是将父进程的地址空间复制到子进程。

然而，在实际使用中，fork()系统调用经常会紧接着在子进程中调用 exec()系统调用。exec()系统调用的功能是用一个新的程序替换当前进程的内存。例如，shell 在创建一个新的进程来运行一个命令时，就会先调用 fork()创建一个新的进程，然后在新的进程中调用 exec()来运行命令。在这种情况下，复制父进程地址空间的操作大部分都被浪费了，因为子进程在调用 exec()之前只会使用很少的内存。

为了解决这个问题，后来的 Unix 版本利用了虚拟内存硬件的特性，允许父进程和子进程在其中一个进程实际修改它之前共享映射到各自地址空间的内存。这种技术被称为写时复制（copy-on-write）。具体来说，当调用 fork()时，内核会将地址空间映射从父进程复制到子进程，而不是复制映射的页面内容，并同时将现在共享的页面标记为只读。当两个进程中的一个试图写入这些共享页面时，该进程会发生页面错误。在这一点上，Unix 内核意识到该页面实际上是一个"虚拟的"或"写时复制的"副本，所以它为出错的进程创建一个新的、私有的、可写的页面副本。通过这种方式，只有在实际写入页面时，才会真正复制页面内容。这种优化使得在子进程中紧接着执行 exec()的 fork()变得更便宜：子进程在调用 exec()之前可能只需要复制一个页面（其堆栈的当前页面）。

在正常执行过程中，JOS 中的用户进程将在正常的用户栈上运行：其 ESP 寄存器开始时指向 USTACKTOP，它推送的栈数据位于 USTACKTOP-PGSIZE 和 USTACKTOP-1 之间的页面上。然而，当在用户模式下发生页面错误时，内核将在另一个栈上，即用户异常栈上，重新启动用户进程运行指定的用户级页面错误处理程序。本质上，我们将使 JOS 内核实现自动的"栈切换"，以代替用户进程，这与 x86 处理器在从用户模式转到内核模式时已经实现的栈切换非常相似！

JOS 用户异常栈的大小也是一页，其顶部被定义为虚拟地址 UXSTACKTOP，因此用户异常栈的有效字节从 UXSTACKTOP-PGSIZE 到 UXSTACKTOP-1。在此异常栈上运行时，用户级页面错误处理程序可以使用 JOS 的常规系统调用来映射新页面或调整映射，以便修复最初导致页面错误的问题。然后，用户级页面错误处理程序通过汇编语言存根返回到原始栈上的错误代码。

每个希望支持用户级页面错误处理的用户进程都需要使用在部分 A 中引入的 sys_page_alloc()系统调用为其自己的异常栈分配内存。
