# Hash

这一章主要研究 `util/hash.cc` 和 `util/hash.h` 。

hash 又用到了 `util/coding.cc` 和 `util/coding.h`

## 1. Coding

`util/coding.cc` 和 `util/coding.h` 提供了一套用于数据编码和解码的功能，特别是针对固定长度和可变长度整数以及字符串数据。它主要实现了：

1. **固定长度整数的编码与解码**：使用小端字节序编码 `uint32_t` 和 `uint64_t` 类型的整数，并提供相应的解码功能。

2. **可变长度整数（varint）的编码与解码**：对 `uint32_t` 和 `uint64_t` 类型的整数进行可变长度编码，称为 varint 编码，同时提供解码这些编码的功能。

3. **字符串的长度前缀编码**：将字符串前缀为其长度（使用 varint 编码），然后是字符串本身，提供解析这种格式的字符串的功能。

总的来说，这段代码是一个用于处理不同类型数据（特别是整数和字符串）的端序中立编码和解码库，适用于需要高效存储和传输数据的场景。

这部分代码比较底层，没有太多可以修改的地方，先略过。

## 2. Hash

下面研究 `util/hash.cc` ，这里面是一个 hash 函数。

Leveldb 的 布隆过滤器中的 Hash 函数采用了一个类似 MurmurHash。MurmurHash是一种非加密型哈希函数，适用于一般的哈希检索操作。这个名称“Murmur”来源于两个基本操作，即乘法（multiply）和旋转（rotate），这是这个算法的关键部分。MurmurHash以其高效性和产生较少哈希碰撞的能力而闻名。它不适用于加密，因为它不是为安全性设计的，而是为速度和效率设计的。

MurmurHash 的几个关键特点包括：

1. **性能高效**：MurmurHash被设计成在处理大量数据时保持高效和快速。它的算法结构确保了即使是大量的数据也能快速处理。

2. **分布均匀**：MurmurHash能生成的哈希值分布非常均匀，这减少了哈希碰撞的可能性，即不同的输入产生相同哈希值的情况。

3. **不同版本**：MurmurHash有几个不同的版本，如MurmurHash1、MurmurHash2、MurmurHash3等。每个版本在效率和分布特性方面都有所不同。

4. **平台独立**：MurmurHash算法在不同的硬件和操作系统上都能保持一致的性能和结果。

5. **非加密用途**：重要的是要记住，MurmurHash不适合用于任何需要加密的场合。它的设计重点是速度和效率，而不是防止逆向工程或抵抗哈希碰撞攻击。

MurmurHash常用于数据存储和处理领域，如哈希表的键值映射、数据分片、负载均衡等。由于其高效的性能特点，它在需要快速哈希运算的场景中非常受欢迎。

### MurmurHash 的处理步骤

Leveldb 的 MurmurHash 的处理步骤可以简要概述如下：

1. **初始化**：
   - 使用异或操作将初始种子与数据总大小乘以常数 `m` 结合起来。

2. **处理四字节块**：
   - 当数据长度足够（剩余至少4字节）时，按4字节为一组处理数据。
   - 对每4字节：
     - 读取4字节数据，并将其加到哈希值 `h` 上。
     - 将哈希值 `h` 乘以常数 `m`。
     - 将哈希值 `h` 右移16位后与自身进行异或操作。

3. **处理剩余字节**：
   - 根据剩余字节数（0到3字节），处理每个剩余字节：
     - 如果剩余3字节，则将第三个字节左移16位后加到哈希值 `h` 上。
     - 如果剩余至少2字节，则将第二个字节左移8位后加到哈希值 `h` 上。
     - 如果剩余至少1字节，则将第一个字节直接加到哈希值 `h` 上。
   - 在处理完剩余字节后，将哈希值 `h` 乘以常数 `m`，然后将哈希值 `h` 右移 `r`（24位）位后与自身进行异或操作。

4. **返回最终哈希值**：
   - 返回处理完成后的哈希值 `h`。
