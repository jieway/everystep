<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Lab 2 (Chinese) - everystep</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../theme/style.css">


</head>
<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">ç®€ä»‹</a></li><li class="chapter-item affix "><li class="part-title">ğŸ· é€ è½®å­</li><li class="spacer"></li><li class="chapter-item "><a href="../bitcask/index.html"><strong aria-hidden="true">1.</strong> ä»é›¶å®ç° Bitcask å­˜å‚¨å¼•æ“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.1.</strong> Bitcask ç®€ä»‹</a></li><li class="chapter-item "><a href="../bitcask/p2.html"><strong aria-hidden="true">1.2.</strong> åˆ›å»º C++ é¡¹ç›®</a></li><li class="chapter-item "><a href="../bitcask/p3.html"><strong aria-hidden="true">1.3.</strong> æ•°æ®åœ¨å†…å­˜ä¸­</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.4.</strong> æ•°æ®åœ¨ç£ç›˜ä¸Š</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.5.</strong> BenchMark</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.6.</strong> å®ç°åˆå¹¶</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.7.</strong> å®ç°åƒåœ¾å›æ”¶</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.8.</strong> hintfile å®ç°</a></li><li class="chapter-item "><a href="../bitcask/p1.html"><strong aria-hidden="true">1.9.</strong> å“ˆå¸Œè¡¨ä¼˜åŒ–ä¸ºå¤šçº¿ç¨‹</a></li><li class="chapter-item "><a href="../bitcask/ch1.html"><strong aria-hidden="true">1.10.</strong> æ•°æ®åœ¨ç£ç›˜ä¸Šå¦‚ä½•å­˜æ”¾ï¼Ÿ</a></li><li class="chapter-item "><a href="../bitcask/ch2.html"><strong aria-hidden="true">1.11.</strong> å­˜å‚¨å¼•æ“çš„æ¥å£è®¾è®¡</a></li><li class="chapter-item "><a href="../bitcask/ch3.html"><strong aria-hidden="true">1.12.</strong> å®ç° Setã€Get</a></li><li class="chapter-item "><a href="../bitcask/ch4.html"><strong aria-hidden="true">1.13.</strong> åˆ é™¤é€»è¾‘å’Œ Compact </a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸ­ æ“ä½œç³»ç»Ÿ</li><li class="spacer"></li><li class="chapter-item "><a href="../6.S081/0-summary.html"><strong aria-hidden="true">2.</strong> 6.S081</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../6.S081/1-lab1.html"><strong aria-hidden="true">2.1.</strong> Lab 1</a></li><li class="chapter-item "><a href="../6.S081/2-lab2.html"><strong aria-hidden="true">2.2.</strong> Lab 2</a></li><li class="chapter-item "><a href="../6.S081/3-lab3.html"><strong aria-hidden="true">2.3.</strong> Lab 3</a></li><li class="chapter-item "><a href="../6.S081/4-lab4.html"><strong aria-hidden="true">2.4.</strong> Lab 4</a></li><li class="chapter-item "><a href="../6.S081/5-lab5.html"><strong aria-hidden="true">2.5.</strong> Lab 5</a></li><li class="chapter-item "><a href="../6.S081/6-lab6.html"><strong aria-hidden="true">2.6.</strong> Lab 6</a></li><li class="chapter-item "><a href="../6.S081/7-lab7.html"><strong aria-hidden="true">2.7.</strong> Lab 7</a></li><li class="chapter-item "><a href="../6.S081/8-lab8.html"><strong aria-hidden="true">2.8.</strong> Lab 8</a></li><li class="chapter-item "><a href="../6.S081/9-lab9.html"><strong aria-hidden="true">2.9.</strong> Lab 9</a></li><li class="chapter-item "><a href="../6.S081/10-lab10.html"><strong aria-hidden="true">2.10.</strong> Lab 10</a></li><li class="chapter-item "><a href="../6.S081/11-lab11.html"><strong aria-hidden="true">2.11.</strong> Lab 11</a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸš€ æ•°æ®åº“</li><li class="chapter-item "><a href="../abyssdb/p0.html"><strong aria-hidden="true">3.</strong> ä»é›¶å®ç°å…³ç³»å‹æ•°æ®åº“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../abyssdb/p1.html"><strong aria-hidden="true">3.1.</strong> ä» Table å¼€å§‹</a></li><li class="chapter-item "><a href="../abyssdb/p2.html"><strong aria-hidden="true">3.2.</strong> Part 2. å®ç° Tuple</a></li><li class="chapter-item "><a href="../abyssdb/p3.html"><strong aria-hidden="true">3.3.</strong> Part 3. å®ç° Page</a></li><li class="chapter-item "><a href="../abyssdb/p4.html"><strong aria-hidden="true">3.4.</strong> Part 4. å®ç° HeapFile</a></li><li class="chapter-item "><a href="../abyssdb/p5.html"><strong aria-hidden="true">3.5.</strong> Part 5. å®ç° BufferPool</a></li><li class="chapter-item "><a href="../abyssdb/p6.html"><strong aria-hidden="true">3.6.</strong> Part 6. æ”¯æŒ int å’Œ string ç­‰æ•°æ®ç±»å‹ã€‚</a></li><li class="chapter-item "><a href="../abyssdb/p7.html"><strong aria-hidden="true">3.7.</strong> Part 7. å®ç° Catalog</a></li></ol></li><li class="chapter-item "><a href="../6.830/1-lab0.html"><strong aria-hidden="true">4.</strong> 6.830</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../6.830/ans/2-lab1-ans.html"><strong aria-hidden="true">4.1.</strong> Lab 1 Answers</a></li><li class="chapter-item "><a href="../6.830/ans/3-lab2-ans.html"><strong aria-hidden="true">4.2.</strong> Lab 2 Answers</a></li><li class="chapter-item "><a href="../6.830/ans/4-lab3-ans.html"><strong aria-hidden="true">4.3.</strong> Lab 3 Answers</a></li><li class="chapter-item "><a href="../6.830/ans/5-lab4-ans.html"><strong aria-hidden="true">4.4.</strong> Lab 4 Answers</a></li><li class="chapter-item "><a href="../6.830/ans/6-lab5-ans.html"><strong aria-hidden="true">4.5.</strong> Lab 5 Answers</a></li><li class="chapter-item "><a href="../6.830/ans/7-lab6-ans.html"><strong aria-hidden="true">4.6.</strong> Lab 6 Answers</a></li><li class="chapter-item "><a href="../6.830/cn/2-lab1.html"><strong aria-hidden="true">4.7.</strong> Lab 1 (Chinese)</a></li><li class="chapter-item "><a href="../6.830/cn/3-lab2.html"><strong aria-hidden="true">4.8.</strong> Lab 2 (Chinese)</a></li><li class="chapter-item "><a href="../6.830/cn/4-lab3.html"><strong aria-hidden="true">4.9.</strong> Lab 3 (Chinese)</a></li><li class="chapter-item "><a href="../6.830/cn/5-lab4.html"><strong aria-hidden="true">4.10.</strong> Lab 4 (Chinese)</a></li><li class="chapter-item "><a href="../6.830/cn/6-lab5.html"><strong aria-hidden="true">4.11.</strong> Lab 5 (Chinese)</a></li><li class="chapter-item "><a href="../6.830/cn/7-lab6.html"><strong aria-hidden="true">4.12.</strong> Lab 6 (Chinese)</a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸ§Š åˆ†å¸ƒå¼</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../6.824/0-lab0.html"><strong aria-hidden="true">5.</strong> 6.824</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../6.824/1-lab1-cn.html"><strong aria-hidden="true">5.1.</strong> Lab 1 (Chinese)</a></li><li class="chapter-item "><a href="../6.824/1-lab1.html"><strong aria-hidden="true">5.2.</strong> Lab 1</a></li><li class="chapter-item expanded "><a href="../6.824/2-lab2-cn.html" class="active"><strong aria-hidden="true">5.3.</strong> Lab 2 (Chinese)</a></li><li class="chapter-item "><a href="../6.824/2-lab2.html"><strong aria-hidden="true">5.4.</strong> Lab 2</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">everystep</h1>

                <div class="right-buttons">
                    <a href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/weijiew/everystep" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/weijiew/everystep/edit/master/src/6.824/2-lab2-cn.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                }); 

                // Mark viewed after 30s
                setTimeout(function() {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc"><nav class="pagetoc"></nav></div>
                <main>
                    <h1 id="lab-2-raft-ç¿»è¯‘"><a class="header" href="#lab-2-raft-ç¿»è¯‘">Lab 2: Raft ç¿»è¯‘</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>å®ç° Raft åè®®å¹¶æ„å»ºä¸€ä¸ªå…·å¤‡å®¹é”™åŠŸèƒ½çš„ K/V å­˜å‚¨ç³»ç»Ÿã€‚</p>
<p>In this lab you'll implement Raft, a replicated state machine protocol. In the next lab you'll build a key/value service on top of Raft. Then you will â€œshardâ€ your service over multiple replicated state machines for higher performance.</p>
<p>è¿™æ˜¯ä¸€ç³»åˆ—å®éªŒå®¤ä¸­çš„ç¬¬ä¸€ä¸ªï¼Œä½ å°†å»ºç«‹ä¸€ä¸ªå®¹é”™çš„é”®/å€¼å­˜å‚¨ç³»ç»Ÿã€‚åœ¨è¿™ä¸ªå®éªŒå®¤ä¸­ï¼Œä½ å°†å®ç°Raftï¼Œä¸€ä¸ªå¤åˆ¶çš„çŠ¶æ€æœºåè®®ã€‚åœ¨ä¸‹ä¸€ä¸ªå®éªŒå®¤ä¸­ï¼Œä½ å°†åœ¨Raftçš„åŸºç¡€ä¸Šå»ºç«‹ä¸€ä¸ªé”®/å€¼æœåŠ¡ã€‚ç„¶åä½ å°†åœ¨å¤šä¸ªå¤åˆ¶çš„çŠ¶æ€æœºä¸Š &quot;åˆ†ç‰‡ &quot;ä½ çš„æœåŠ¡ï¼Œä»¥è·å¾—æ›´é«˜çš„æ€§èƒ½ã€‚</p>
<p>A replicated service achieves fault tolerance by storing complete copies of its state (i.e., data) on multiple replica servers. Replication allows the service to continue operating even if some of its servers experience failures (crashes or a broken or flaky network). The challenge is that failures may cause the replicas to hold differing copies of the data.</p>
<p>å¤åˆ¶çš„æœåŠ¡é€šè¿‡åœ¨å¤šä¸ªå¤åˆ¶æœåŠ¡å™¨ä¸Šå­˜å‚¨å…¶çŠ¶æ€ï¼ˆå³æ•°æ®ï¼‰çš„å®Œæ•´å‰¯æœ¬æ¥å®ç°å®¹é”™ã€‚å¤åˆ¶å…è®¸æœåŠ¡ç»§ç»­è¿è¡Œï¼Œå³ä½¿å®ƒçš„ä¸€äº›æœåŠ¡å™¨å‡ºç°æ•…éšœï¼ˆå´©æºƒæˆ–ç½‘ç»œæ•…éšœæˆ–æ‘‡æ‘†ä¸å®šï¼‰ã€‚æŒ‘æˆ˜åœ¨äºï¼Œæ•…éšœå¯èƒ½å¯¼è‡´å‰¯æœ¬æŒæœ‰ä¸åŒçš„æ•°æ®å‰¯æœ¬ã€‚</p>
<p>Raft organizes client requests into a sequence, called the log, and ensures that all the replica servers see the same log. Each replica executes client requests in log order, applying them to its local copy of the service's state. Since all the live replicas see the same log contents, they all execute the same requests in the same order, and thus continue to have identical service state. If a server fails but later recovers, Raft takes care of bringing its log up to date. Raft will continue to operate as long as at least a majority of the servers are alive and can talk to each other. If there is no such majority, Raft will make no progress, but will pick up where it left off as soon as a majority can communicate again.</p>
<p>Raftå°†å®¢æˆ·è¯·æ±‚ç»„ç»‡æˆä¸€ä¸ªåºåˆ—ï¼Œç§°ä¸ºæ—¥å¿—ï¼Œå¹¶ç¡®ä¿æ‰€æœ‰å‰¯æœ¬æœåŠ¡å™¨çœ‹åˆ°ç›¸åŒçš„æ—¥å¿—ã€‚æ¯ä¸ªå‰¯æœ¬æŒ‰æ—¥å¿—é¡ºåºæ‰§è¡Œå®¢æˆ·è¯·æ±‚ï¼Œå°†å®ƒä»¬åº”ç”¨äºå…¶æœ¬åœ°çš„æœåŠ¡çŠ¶æ€å‰¯æœ¬ã€‚ç”±äºæ‰€æœ‰çš„å®æ—¶å‰¯æœ¬çœ‹åˆ°ç›¸åŒçš„æ—¥å¿—å†…å®¹ï¼Œå®ƒä»¬éƒ½ä»¥ç›¸åŒçš„é¡ºåºæ‰§è¡Œç›¸åŒçš„è¯·æ±‚ï¼Œä»è€Œç»§ç»­æ‹¥æœ‰ç›¸åŒçš„æœåŠ¡çŠ¶æ€ã€‚å¦‚æœä¸€ä¸ªæœåŠ¡å™¨å‘ç”Ÿæ•…éšœä½†åæ¥æ¢å¤äº†ï¼ŒRaftä¼šè´Ÿè´£å°†å…¶æ—¥å¿—æ›´æ–°ã€‚åªè¦è‡³å°‘æœ‰å¤§å¤šæ•°çš„æœåŠ¡å™¨è¿˜æ´»ç€ï¼Œå¹¶ä¸”èƒ½å¤Ÿç›¸äº’äº¤è°ˆï¼ŒRaftå°±ä¼šç»§ç»­è¿è¡Œã€‚å¦‚æœæ²¡æœ‰è¿™æ ·çš„å¤šæ•°ï¼ŒRaftå°†ä¸ä¼šå–å¾—ä»»ä½•è¿›å±•ï¼Œä½†ä¸€æ—¦å¤šæ•°æœåŠ¡å™¨èƒ½å¤Ÿå†æ¬¡é€šä¿¡ï¼ŒRaftå°†é‡æ–°å¼€å§‹å·¥ä½œã€‚</p>
<p>In this lab you'll implement Raft as a Go object type with associated methods, meant to be used as a module in a larger service. A set of Raft instances talk to each other with RPC to maintain replicated logs. Your Raft interface will support an indefinite sequence of numbered commands, also called log entries. The entries are numbered with index numbers. The log entry with a given index will eventually be committed. At that point, your Raft should send the log entry to the larger service for it to execute.</p>
<p>åœ¨è¿™ä¸ªå®éªŒå®¤ä¸­ï¼Œä½ å°†æŠŠRaftå®ç°ä¸ºä¸€ä¸ªå¸¦æœ‰ç›¸å…³æ–¹æ³•çš„Goå¯¹è±¡ç±»å‹ï¼Œæ—¨åœ¨ä½œä¸ºä¸€ä¸ªæ›´å¤§çš„æœåŠ¡ä¸­çš„æ¨¡å—ä½¿ç”¨ã€‚ä¸€ç»„Raftå®ä¾‹é€šè¿‡RPCç›¸äº’å¯¹è¯ï¼Œä»¥ç»´æŠ¤å¤åˆ¶çš„æ—¥å¿—ã€‚ä½ çš„Raftæ¥å£å°†æ”¯æŒä¸€è¿ä¸²ä¸ç¡®å®šçš„ç¼–å·å‘½ä»¤ï¼Œä¹Ÿç§°ä¸ºæ—¥å¿—æ¡ç›®ã€‚æ¡ç›®æ˜¯ç”¨ç´¢å¼•å·æ¥ç¼–å·çš„ã€‚å…·æœ‰ç‰¹å®šç´¢å¼•çš„æ—¥å¿—æ¡ç›®æœ€ç»ˆå°†è¢«æäº¤ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ çš„Raftåº”è¯¥å°†æ—¥å¿—æ¡ç›®å‘é€åˆ°æ›´å¤§çš„æœåŠ¡ï¼Œè®©å®ƒæ‰§è¡Œã€‚</p>
<p>You should follow the design in the <a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">extended Raft paper</a>, with particular attention to Figure 2. You'll implement most of what's in the paper, including saving persistent state and reading it after a node fails and then restarts. You will not implement cluster membership changes (Section 6).</p>
<p>ä½ åº”è¯¥éµå¾ª<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">æ‰©å±•çš„Raftè®ºæ–‡</a>ä¸­çš„è®¾è®¡ï¼Œç‰¹åˆ«æ³¨æ„å›¾2ã€‚ä½ å°†å®ç°è®ºæ–‡ä¸­çš„å¤§éƒ¨åˆ†å†…å®¹ï¼ŒåŒ…æ‹¬ä¿å­˜æŒä¹…æ€§çŠ¶æ€å’Œåœ¨èŠ‚ç‚¹æ•…éšœåé‡æ–°å¯åŠ¨åè¯»å–çŠ¶æ€ã€‚ä½ å°†ä¸ä¼šå®ç°é›†ç¾¤æˆå‘˜çš„å˜åŒ–ï¼ˆç¬¬6èŠ‚ï¼‰ã€‚</p>
<p>You may find this <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">guide</a> useful, as well as this advice about <a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">locking</a> and <a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">structure</a> for concurrency. For a wider perspective, have a look at Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication, and <a href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf">Bolosky et al.</a> (Note: the student's guide was written several years ago, and part 2D in particular has since changed. Make sure you understand why a particular implementation strategy makes sense before blindly following it!)</p>
<p>ä½ å¯èƒ½ä¼šå‘ç°è¿™ä¸ª<a href="https://thesquareplanet.com/blog/students-guide-to-raft/">æŒ‡å—</a>å¾ˆæœ‰ç”¨ï¼Œè¿˜æœ‰è¿™ä¸ªå…³äºå¹¶å‘çš„é”å’Œç»“æ„çš„å»ºè®®ã€‚ä¸ºäº†è·å¾—æ›´å¹¿æ³›çš„è§†è§’ï¼Œå¯ä»¥çœ‹çœ‹Paxosã€Chubbyã€Paxos Made Liveã€Spannerã€Zookeeperã€Harpã€Viewstamped Replicationå’ŒBoloskyç­‰ï¼ˆæ³¨æ„ï¼šå­¦ç”ŸæŒ‡å—æ˜¯å‡ å¹´å‰å†™çš„ï¼Œå°¤å…¶æ˜¯2Déƒ¨åˆ†åæ¥æœ‰äº†å˜åŒ–ã€‚è¯·ç¡®ä¿ä½ åœ¨ç›²ç›®è¿½éšæŸä¸ªç‰¹å®šçš„å®æ–½ç­–ç•¥ä¹‹å‰ï¼Œäº†è§£å®ƒä¸ºä»€ä¹ˆæœ‰æ„ä¹‰ï¼)</p>
<p>Keep in mind that the most challenging part of this lab may not be implementing your solution, but debugging it. To help address this challenge, you may wish to spend time thinking about how to make your implementation more easily debuggable. You might refer to the <a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html">Guidance</a> page and to this blog post about <a href="https://blog.josejg.com/debugging-pretty/">effective print statements</a>.</p>
<p>è¯·è®°ä½ï¼Œæœ¬å®éªŒä¸­æœ€å…·æŒ‘æˆ˜æ€§çš„éƒ¨åˆ†å¯èƒ½ä¸æ˜¯å®ç°ä½ çš„è§£å†³æ–¹æ¡ˆï¼Œè€Œæ˜¯è°ƒè¯•å®ƒã€‚ä¸ºäº†å¸®åŠ©åº”å¯¹è¿™ä¸€æŒ‘æˆ˜ï¼Œä½ å¯èƒ½å¸Œæœ›èŠ±æ—¶é—´è€ƒè™‘å¦‚ä½•ä½¿ä½ çš„å®ç°æ›´å®¹æ˜“è°ƒè¯•ã€‚ä½ å¯ä»¥å‚è€ƒæŒ‡å¯¼é¡µå’Œè¿™ç¯‡å…³äºæœ‰æ•ˆæ‰“å°è¯­å¥çš„åšæ–‡ã€‚</p>
<p>We also provide a <a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf">diagram of Raft interactions</a> that can help clarify how your Raft code interacts with the layers on top of it.</p>
<p>æˆ‘ä»¬è¿˜æä¾›äº†ä¸€ä¸ªRaftäº’åŠ¨å›¾ï¼Œå¯ä»¥å¸®åŠ©æ¾„æ¸…ä½ çš„Raftä»£ç å¦‚ä½•ä¸ä¸Šé¢çš„å±‚äº’åŠ¨ã€‚</p>
<p>This lab is due in four parts. You must submit each part on the corresponding due date.</p>
<p>æœ¬å®éªŒåˆ†å››éƒ¨åˆ†å®Œæˆã€‚ä½ å¿…é¡»åœ¨ç›¸åº”çš„åˆ°æœŸæ—¥æäº¤æ¯ä¸ªéƒ¨åˆ†ã€‚</p>
<h2 id="getting-started-å…¥é—¨"><a class="header" href="#getting-started-å…¥é—¨">Getting Started å…¥é—¨</a></h2>
<p>If you have done Lab 1, you already have a copy of the lab source code. If not, you can find directions for obtaining the source via git in the Lab 1 instructions.</p>
<p>å¦‚æœä½ åšè¿‡å®éªŒ1ï¼Œä½ å·²ç»æœ‰ä¸€ä»½å®éªŒæºä»£ç çš„å‰¯æœ¬ã€‚å¦‚æœæ²¡æœ‰ï¼Œä½ å¯ä»¥åœ¨å®éªŒ1çš„è¯´æ˜ä¸­æ‰¾åˆ°é€šè¿‡gitè·å–æºä»£ç çš„æ–¹æ³•ã€‚</p>
<p>We supply you with skeleton code src/raft/raft.go. We also supply a set of tests, which you should use to drive your implementation efforts, and which we'll use to grade your submitted lab. The tests are in src/raft/test_test.go.</p>
<p>æˆ‘ä»¬ä¸ºä½ æä¾›äº†éª¨æ¶ä»£ç  src/raft/raft.goã€‚æˆ‘ä»¬è¿˜æä¾›äº†ä¸€å¥—æµ‹è¯•ï¼Œä½ åº”è¯¥ç”¨å®ƒæ¥æ¨åŠ¨ä½ çš„å®æ–½å·¥ä½œï¼Œæˆ‘ä»¬ä¼šç”¨å®ƒæ¥ç»™ä½ æäº¤çš„å®éªŒå®¤è¯„åˆ†ã€‚è¿™äº›æµ‹è¯•åœ¨ src/raft/test_test.go ä¸­ã€‚</p>
<p>When we grade your submissions, we will run the tests without the -race flag. However, you should make sure that your code does not have race conditions because race conditions can cause the tests to fail. So, it's highly recommended to also run the tests with the -race flag as you develop your solution.</p>
<p>å½“æˆ‘ä»¬å¯¹ä½ æäº¤çš„æ–‡ä»¶è¿›è¡Œè¯„åˆ†æ—¶ï¼Œæˆ‘ä»¬å°†åœ¨æ²¡æœ‰-raceæ ‡å¿—çš„æƒ…å†µä¸‹è¿è¡Œæµ‹è¯•ã€‚ç„¶è€Œï¼Œä½ åº”è¯¥ç¡®ä¿ä½ çš„ä»£ç ä¸å­˜åœ¨ç«èµ›æ¡ä»¶ï¼Œå› ä¸ºç«èµ›æ¡ä»¶ä¼šå¯¼è‡´æµ‹è¯•å¤±è´¥ã€‚å› æ­¤ï¼Œå¼ºçƒˆå»ºè®®ä½ åœ¨å¼€å‘ä½ çš„è§£å†³æ–¹æ¡ˆæ—¶ï¼Œä¹Ÿç”¨-raceæ ‡å¿—æ¥è¿è¡Œæµ‹è¯•ã€‚</p>
<p>To get up and running, execute the following commands. Don't forget the git pull to get the latest software.</p>
<p>è¦å¯åŠ¨å’Œè¿è¡Œï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ã€‚ä¸è¦å¿˜è®°ä½¿ç”¨git pullæ¥è·å–æœ€æ–°çš„è½¯ä»¶ã€‚</p>
<pre><code>$ cd ~/6.824
$ git pull
...
$ cd src/raft
$ go test
Test (2A): initial election ...
--- FAIL: TestInitialElection2A (5.04s)
        config.go:326: expected one leader, got none
Test (2A): election after network failure ...
--- FAIL: TestReElection2A (5.03s)
        config.go:326: expected one leader, got none
...
$
</code></pre>
<h2 id="the-code-å‡†åˆ™"><a class="header" href="#the-code-å‡†åˆ™">The code å‡†åˆ™</a></h2>
<p>Implement Raft by adding code to raft/raft.go. In that file you'll find skeleton code, plus examples of how to send and receive RPCs.</p>
<p>é€šè¿‡å‘raft/raft.goæ·»åŠ ä»£ç æ¥å®ç°Raftã€‚åœ¨è¯¥æ–‡ä»¶ä¸­ï¼Œä½ ä¼šå‘ç°éª¨æ¶ä»£ç ï¼Œä»¥åŠå¦‚ä½•å‘é€å’Œæ¥æ”¶RPCçš„ä¾‹å­ã€‚</p>
<p>Your implementation must support the following interface, which the tester and (eventually) your key/value server will use. You'll find more details in comments in raft.go.</p>
<p>ä½ çš„å®ç°å¿…é¡»æ”¯æŒä»¥ä¸‹æ¥å£ï¼Œæµ‹è¯•è€…å’Œï¼ˆæœ€ç»ˆï¼‰ä½ çš„é”®/å€¼æœåŠ¡å™¨å°†ä½¿ç”¨è¯¥æ¥å£ã€‚ä½ å¯ä»¥åœ¨raft.goçš„æ³¨é‡Šä¸­æ‰¾åˆ°æ›´å¤šç»†èŠ‚ã€‚</p>
<pre><code>// create a new Raft server instance:
// åˆ›å»ºä¸€ä¸ªæ–°çš„RaftæœåŠ¡å™¨å®ä¾‹ã€‚
rf := Make(peers, me, persister, applyCh)

// start agreement on a new log entry:
// å¯åŠ¨åœ¨ä¸€ä¸ªæ–°çš„æ—¥å¿—æ¡ç›®çš„åè®®ã€‚
rf.Start(command interface{}) (index, term, isleader)

// ask a Raft for its current term, and whether it thinks it is leader
// è¯¢é—®ä¸€ä¸ª Raft çš„å½“å‰ä»»æœŸï¼Œä»¥åŠå®ƒæ˜¯å¦è®¤ä¸ºè‡ªå·±æ˜¯é¢†å¯¼è€…ã€‚
rf.GetState() (term, isLeader)

// each time a new entry is committed to the log, each Raft peer
// should send an ApplyMsg to the service (or tester).
// æ¯å½“ä¸€ä¸ªæ–°æ¡ç›®è¢«æäº¤åˆ°æ—¥å¿—ä¸­æ—¶ï¼Œæ¯ä¸ª Raft å¯¹ç­‰ä½“
// åº”è¯¥å‘æœåŠ¡ï¼ˆæˆ–æµ‹è¯•è€…ï¼‰å‘é€ä¸€ä¸ªApplyMsgã€‚
type ApplyMsg
</code></pre>
<p>A service calls Make(peers,me,â€¦) to create a Raft peer. The peers argument is an array of network identifiers of the Raft peers (including this one), for use with RPC. The me argument is the index of this peer in the peers array. Start(command) asks Raft to start the processing to append the command to the replicated log. Start() should return immediately, without waiting for the log appends to complete. The service expects your implementation to send an ApplyMsg for each newly committed log entry to the applyCh channel argument to Make().</p>
<p>ä¸€ä¸ªæœåŠ¡è°ƒç”¨Make(peers,me,...)æ¥åˆ›å»ºä¸€ä¸ªRaftå¯¹ç­‰ä½“ã€‚peerså‚æ•°æ˜¯ä¸€ä¸ªRaftå¯¹ç­‰ä½“ï¼ˆåŒ…æ‹¬è¿™ä¸ªï¼‰çš„ç½‘ç»œæ ‡è¯†ç¬¦æ•°ç»„ï¼Œç”¨äºRPCã€‚meå‚æ•°æ˜¯è¯¥å¯¹ç­‰ä½“åœ¨å¯¹ç­‰ä½“æ•°ç»„ä¸­çš„ç´¢å¼•ã€‚Start(command)è¦æ±‚Raftå¼€å§‹å¤„ç†ï¼Œå°†è¯¥å‘½ä»¤é™„åŠ åˆ°å¤åˆ¶çš„æ—¥å¿—ä¸­ã€‚Start()åº”ç«‹å³è¿”å›ï¼Œè€Œä¸éœ€è¦ç­‰å¾…æ—¥å¿—è¿½åŠ å®Œæˆã€‚è¯¥æœåŠ¡å¸Œæœ›ä½ çš„å®ç°ä¸ºæ¯ä¸ªæ–°æäº¤çš„æ—¥å¿—æ¡ç›®å‘é€ä¸€ä¸ªApplyMsgåˆ°Make()çš„applyChé€šé“å‚æ•°ã€‚</p>
<p>raft.go contains example code that sends an RPC (sendRequestVote()) and that handles an incoming RPC (RequestVote()). Your Raft peers should exchange RPCs using the labrpc Go package (source in src/labrpc). The tester can tell labrpc to delay RPCs, re-order them, and discard them to simulate various network failures. While you can temporarily modify labrpc, make sure your Raft works with the original labrpc, since that's what we'll use to test and grade your lab. Your Raft instances must interact only with RPC; for example, they are not allowed to communicate using shared Go variables or files.</p>
<p>raft.goåŒ…å«å‘é€RPCï¼ˆsendRequestVote()ï¼‰å’Œå¤„ç†ä¼ å…¥RPCï¼ˆRequestVote()ï¼‰çš„ç¤ºä¾‹ä»£ç ã€‚ä½ çš„Raftå¯¹ç­‰ä½“åº”è¯¥ä½¿ç”¨labrpc GoåŒ…ï¼ˆæºä»£ç åœ¨src/labrpcä¸­ï¼‰äº¤æ¢RPCã€‚æµ‹è¯•äººå‘˜å¯ä»¥å‘Šè¯‰labrpcå»¶è¿ŸRPCï¼Œé‡æ–°æ’åºï¼Œå¹¶ä¸¢å¼ƒå®ƒä»¬ä»¥æ¨¡æ‹Ÿå„ç§ç½‘ç»œæ•…éšœã€‚è™½ç„¶ä½ å¯ä»¥ä¸´æ—¶ä¿®æ”¹labrpcï¼Œä½†è¦ç¡®ä¿ä½ çš„Raftä¸åŸå§‹çš„labrpcä¸€èµ·å·¥ä½œï¼Œå› ä¸ºæˆ‘ä»¬å°†ç”¨å®ƒæ¥æµ‹è¯•å’Œè¯„å®šä½ çš„å®éªŒå®¤ã€‚ä½ çš„Raftå®ä¾‹å¿…é¡»åªä¸RPCäº’åŠ¨ï¼›ä¾‹å¦‚ï¼Œå®ƒä»¬ä¸å…è®¸ä½¿ç”¨å…±äº«çš„Goå˜é‡æˆ–æ–‡ä»¶è¿›è¡Œé€šä¿¡ã€‚</p>
<p>Subsequent labs build on this lab, so it is important to give yourself enough time to write solid code.</p>
<p>éšåçš„å®éªŒæ˜¯åœ¨è¿™ä¸ªå®éªŒçš„åŸºç¡€ä¸Šè¿›è¡Œçš„ï¼Œæ‰€ä»¥ç»™è‡ªå·±è¶³å¤Ÿçš„æ—¶é—´æ¥å†™å‡ºåšå®çš„ä»£ç æ˜¯å¾ˆé‡è¦çš„ã€‚</p>
<h2 id="part-2a-leader-election-moderate"><a class="header" href="#part-2a-leader-election-moderate">Part 2A: leader election (moderate)</a></h2>
<p>Implement Raft leader election and heartbeats (AppendEntries RPCs with no log entries). The goal for Part 2A is for a single leader to be elected, for the leader to remain the leader if there are no failures, and for a new leader to take over if the old leader fails or if packets to/from the old leader are lost. Run go test -run 2A to test your 2A code.</p>
<p>å®ç°Rafté¢†å¯¼è€…é€‰ä¸¾å’Œå¿ƒè·³ï¼ˆAppendEntries RPCsï¼Œæ²¡æœ‰æ—¥å¿—æ¡ç›®ï¼‰ã€‚ç¬¬2Aéƒ¨åˆ†çš„ç›®æ ‡æ˜¯é€‰å‡ºä¸€ä¸ªé¢†å¯¼è€…ï¼Œå¦‚æœæ²¡æœ‰å¤±è´¥ï¼Œè¯¥é¢†å¯¼è€…å°†ç»§ç»­æ‹…ä»»é¢†å¯¼è€…ï¼Œå¦‚æœè€é¢†å¯¼è€…å¤±è´¥æˆ–ä¸è€é¢†å¯¼è€…ä¹‹é—´çš„æ•°æ®åŒ…ä¸¢å¤±ï¼Œåˆ™ç”±æ–°é¢†å¯¼è€…æ¥ç®¡ã€‚è¿è¡Œgo test -run 2Aæ¥æµ‹è¯•ä½ çš„2Aä»£ç ã€‚</p>
<ul>
<li>You can't easily run your Raft implementation directly; instead you should run it by way of the tester, i.e. go test -run 2A .</li>
</ul>
<p>ä½ ä¸èƒ½è½»æ˜“åœ°ç›´æ¥è¿è¡Œä½ çš„Raftå®ç°ï¼›ç›¸åï¼Œä½ åº”è¯¥é€šè¿‡æµ‹è¯•å™¨æ¥è¿è¡Œå®ƒï¼Œå³go test -run 2A ã€‚</p>
<ul>
<li>Follow the paper's Figure 2. At this point you care about sending and receiving RequestVote RPCs, the Rules for Servers that relate to elections, and the State related to leader election,</li>
</ul>
<p>æŒ‰ç…§è®ºæ–‡ä¸­çš„å›¾2ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ å…³å¿ƒçš„æ˜¯å‘é€å’Œæ¥æ”¶ RequestVote RPCs ï¼Œä¸é€‰ä¸¾æœ‰å…³çš„æœåŠ¡å™¨è§„åˆ™ï¼Œä»¥åŠä¸é¢†å¯¼é€‰ä¸¾æœ‰å…³çš„çŠ¶æ€ã€‚</p>
<p>Add the Figure 2 state for leader election to the Raft struct in raft.go. You'll also need to define a struct to hold information about each log entry.</p>
<p>åœ¨raft.goä¸­çš„Raftç»“æ„ä¸­æ·»åŠ å›¾2ä¸­é¢†å¯¼è€…é€‰ä¸¾çš„çŠ¶æ€ã€‚ä½ è¿˜éœ€è¦å®šä¹‰ä¸€ä¸ªç»“æ„æ¥ä¿å­˜æ¯ä¸ªæ—¥å¿—æ¡ç›®çš„ä¿¡æ¯ã€‚</p>
<p>Fill in the RequestVoteArgs and RequestVoteReply structs. Modify Make() to create a background goroutine that will kick off leader election periodically by sending out RequestVote RPCs when it hasn't heard from another peer for a while. This way a peer will learn who is the leader, if there is already a leader, or become the leader itself. Implement the RequestVote() RPC handler so that servers will vote for one another.</p>
<p>å¡«å…¥ RequestVoteArgs å’Œ RequestVoteReply ç»“æ„ã€‚ä¿®æ”¹Make()ä»¥åˆ›å»ºä¸€ä¸ªåå°goroutineï¼Œå½“å®ƒæœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰æ”¶åˆ°å¦ä¸€ä¸ªå¯¹ç­‰ä½“çš„æ¶ˆæ¯æ—¶ï¼Œå®ƒå°†é€šè¿‡å‘é€RequestVote RPCså®šæœŸå¯åŠ¨é¢†å¯¼è€…é€‰ä¸¾ã€‚è¿™æ ·ï¼Œå¦‚æœå·²ç»æœ‰äº†ä¸€ä¸ªé¢†å¯¼è€…ï¼Œå¯¹ç­‰ä½“å°†äº†è§£è°æ˜¯é¢†å¯¼è€…ï¼Œæˆ–è€…è‡ªå·±æˆä¸ºé¢†å¯¼è€…ã€‚å®ç°RequestVote()RPCå¤„ç†ç¨‹åºï¼Œè¿™æ ·æœåŠ¡å™¨å°±å¯ä»¥äº’ç›¸æŠ•ç¥¨äº†ã€‚</p>
<p>To implement heartbeats, define an AppendEntries RPC struct (though you may not need all the arguments yet), and have the leader send them out periodically. Write an AppendEntries RPC handler method that resets the election timeout so that other servers don't step forward as leaders when one has already been elected.</p>
<p>ä¸ºäº†å®ç°å¿ƒè·³ï¼Œå®šä¹‰ä¸€ä¸ªAppendEntries RPCç»“æ„ï¼ˆå°½ç®¡ä½ å¯èƒ½è¿˜ä¸éœ€è¦æ‰€æœ‰çš„å‚æ•°ï¼‰ï¼Œå¹¶è®©é¢†å¯¼è€…å®šæœŸå‘é€å®ƒä»¬ã€‚ç¼–å†™ä¸€ä¸ªAppendEntries RPCå¤„ç†æ–¹æ³•ï¼Œé‡è®¾é€‰ä¸¾è¶…æ—¶ï¼Œè¿™æ ·å½“ä¸€ä¸ªäººå·²ç»å½“é€‰æ—¶ï¼Œå…¶ä»–æœåŠ¡å™¨å°±ä¸ä¼šç«™å‡ºæ¥å½“é¢†å¯¼è€…ã€‚</p>
<p>Make sure the election timeouts in different peers don't always fire at the same time, or else all peers will vote only for themselves and no one will become the leader.</p>
<p>ç¡®ä¿ä¸åŒå¯¹ç­‰ä½“çš„é€‰ä¸¾è¶…æ—¶ä¸ä¼šæ€»æ˜¯åœ¨åŒä¸€æ—¶é—´å‘ç”Ÿï¼Œå¦åˆ™æ‰€æœ‰å¯¹ç­‰ä½“å°†åªä¸ºè‡ªå·±æŠ•ç¥¨ï¼Œæ²¡æœ‰äººä¼šæˆä¸ºé¢†å¯¼è€…ã€‚</p>
<p>The tester requires that the leader send heartbeat RPCs no more than ten times per second.</p>
<p>æµ‹è¯•è€…è¦æ±‚é¢†å¯¼è€…æ¯ç§’å‘é€å¿ƒè·³RPCçš„æ¬¡æ•°ä¸è¶…è¿‡10æ¬¡ã€‚</p>
<p>The tester requires your Raft to elect a new leader within five seconds of the failure of the old leader (if a majority of peers can still communicate). Remember, however, that leader election may require multiple rounds in case of a split vote (which can happen if packets are lost or if candidates unluckily choose the same random backoff times). You must pick election timeouts (and thus heartbeat intervals) that are short enough that it's very likely that an election will complete in less than five seconds even if it requires multiple rounds.</p>
<p>æµ‹è¯•å‘˜è¦æ±‚ä½ çš„Raftåœ¨è€é¢†è¢–å¤±è´¥åçš„äº”ç§’é’Ÿå†…é€‰å‡ºä¸€ä¸ªæ–°çš„é¢†è¢–ï¼ˆå¦‚æœå¤§å¤šæ•°å¯¹ç­‰ä½“ä»èƒ½é€šä¿¡ï¼‰ã€‚ç„¶è€Œï¼Œè¯·è®°ä½ï¼Œå¦‚æœå‡ºç°åˆ†è£‚æŠ•ç¥¨ï¼Œé¢†è¢–é€‰ä¸¾å¯èƒ½éœ€è¦å¤šè½®æŠ•ç¥¨ï¼ˆå¦‚æœæ•°æ®åŒ…ä¸¢å¤±æˆ–å€™é€‰äººä¸èµ°è¿åœ°é€‰æ‹©ç›¸åŒçš„éšæœºé€€é¿æ—¶é—´ï¼Œå°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼‰ã€‚ä½ å¿…é¡»é€‰æ‹©è¶³å¤ŸçŸ­çš„é€‰ä¸¾è¶…æ—¶ï¼ˆä»¥åŠå¿ƒè·³é—´éš”ï¼‰ï¼Œå³ä½¿éœ€è¦å¤šè½®é€‰ä¸¾ï¼Œä¹Ÿå¾ˆå¯èƒ½åœ¨5ç§’å†…å®Œæˆã€‚</p>
<p>The paper's Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds. Because the tester limits you to 10 heartbeats per second, you will have to use an election timeout larger than the paper's 150 to 300 milliseconds, but not too large, because then you may fail to elect a leader within five seconds.</p>
<p>è®ºæ–‡çš„ç¬¬5.2èŠ‚æåˆ°é€‰ä¸¾è¶…æ—¶çš„èŒƒå›´æ˜¯150åˆ°300æ¯«ç§’ã€‚åªæœ‰å½“é¢†å¯¼è€…å‘é€å¿ƒè·³çš„é¢‘ç‡å¤§å¤§è¶…è¿‡æ¯150æ¯«ç§’ä¸€æ¬¡æ—¶ï¼Œè¿™æ ·çš„èŒƒå›´æ‰æœ‰æ„ä¹‰ã€‚å› ä¸ºæµ‹è¯•è€…æŠŠä½ é™åˆ¶åœ¨æ¯ç§’10æ¬¡å¿ƒè·³ï¼Œæ‰€ä»¥ä½ å¿…é¡»ä½¿ç”¨æ¯”æ–‡ä»¶ä¸­çš„150åˆ°300æ¯«ç§’æ›´å¤§çš„é€‰ä¸¾è¶…æ—¶ï¼Œä½†ä¸èƒ½å¤ªå¤§ï¼Œå› ä¸ºé‚£æ ·ä½ å¯èƒ½æ— æ³•åœ¨5ç§’å†…é€‰å‡ºä¸€ä¸ªé¢†å¯¼è€…ã€‚</p>
<p>You may find Go's rand useful.</p>
<p>ä½ å¯èƒ½ä¼šå‘ç°Goçš„randå¾ˆæœ‰ç”¨ã€‚</p>
<p>You'll need to write code that takes actions periodically or after delays in time. The easiest way to do this is to create a goroutine with a loop that calls time.Sleep(); (see the ticker() goroutine that Make() creates for this purpose). Don't use Go's time.Timer or time.Ticker, which are difficult to use correctly.</p>
<p>ä½ éœ€è¦ç¼–å†™ä»£ç ï¼Œå®šæœŸæˆ–åœ¨æ—¶é—´å»¶è¿Ÿåé‡‡å–è¡ŒåŠ¨ã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯åˆ›å»ºä¸€ä¸ªå¸¦æœ‰å¾ªç¯çš„goroutineï¼Œè°ƒç”¨time.Sleep();ï¼ˆå‚è§Make()ä¸ºæ­¤ç›®çš„è€Œåˆ›å»ºçš„ticker()goroutineï¼‰ã€‚ä¸è¦ä½¿ç”¨Goçš„time.Timeræˆ–time.Tickerï¼Œå®ƒä»¬å¾ˆéš¾æ­£ç¡®ä½¿ç”¨ã€‚</p>
<p>The <a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html">Guidance page</a> has some tips on how to develop and debug your code.</p>
<p>æŒ‡å¯¼é¡µæœ‰ä¸€äº›å…³äºå¦‚ä½•å¼€å‘å’Œè°ƒè¯•ä½ çš„ä»£ç çš„æç¤ºã€‚</p>
<p>If your code has trouble passing the tests, read the paper's Figure 2 again; the full logic for leader election is spread over multiple parts of the figure.</p>
<p>å¦‚æœä½ çš„ä»£ç éš¾ä»¥é€šè¿‡æµ‹è¯•ï¼Œè¯·å†æ¬¡é˜…è¯»è¯¥è®ºæ–‡çš„å›¾2ï¼›é¢†å¯¼äººé€‰ä¸¾çš„å…¨éƒ¨é€»è¾‘åˆ†å¸ƒåœ¨å›¾ä¸­çš„å¤šä¸ªéƒ¨åˆ†ã€‚</p>
<p>Don't forget to implement GetState().</p>
<p>ä¸è¦å¿˜è®°å®ç°GetState()ã€‚</p>
<p>The tester calls your Raft's rf.Kill() when it is permanently shutting down an instance. You can check whether Kill() has been called using rf.killed(). You may want to do this in all loops, to avoid having dead Raft instances print confusing messages.</p>
<p>æµ‹è¯•å‘˜åœ¨æ°¸ä¹…å…³é—­ä¸€ä¸ªå®ä¾‹æ—¶ï¼Œä¼šè°ƒç”¨ä½ çš„Raftçš„rf.Kill()ã€‚æ‚¨å¯ä»¥ä½¿ç”¨rf.killed()æ£€æŸ¥Kill()æ˜¯å¦è¢«è°ƒç”¨ã€‚æ‚¨å¯èƒ½å¸Œæœ›åœ¨æ‰€æœ‰çš„å¾ªç¯ä¸­éƒ½è¿™æ ·åšï¼Œä»¥é¿å…æ­»äº¡çš„Raftå®ä¾‹æ‰“å°æ··ä¹±çš„ä¿¡æ¯ã€‚</p>
<p>Go RPC sends only struct fields whose names start with capital letters. Sub-structures must also have capitalized field names (e.g. fields of log records in an array). The labgob package will warn you about this; don't ignore the warnings.</p>
<p>Go RPCåªå‘é€åç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´çš„ç»“æ„å­—æ®µã€‚å­ç»“æ„ä¹Ÿå¿…é¡»æœ‰å¤§å†™çš„å­—æ®µåï¼ˆä¾‹å¦‚ï¼Œæ•°ç»„ä¸­çš„æ—¥å¿—è®°å½•å­—æ®µï¼‰ã€‚labgobåŒ…ä¼šå¯¹æ­¤å‘å‡ºè­¦å‘Šï¼›ä¸è¦å¿½è§†è¿™äº›è­¦å‘Šã€‚</p>
<p>Be sure you pass the 2A tests before submitting Part 2A, so that you see something like this:</p>
<p>åœ¨æäº¤ç¬¬2Aéƒ¨åˆ†ä¹‹å‰ï¼Œè¯·ç¡®ä¿ä½ é€šè¿‡äº†2Aæµ‹è¯•ï¼Œè¿™æ ·ä½ å°±ä¼šçœ‹åˆ°è¿™æ ·çš„å†…å®¹ã€‚</p>
<pre><code>$ go test -run 2A
Test (2A): initial election ...
... Passed --   3.5  3   58   16840    0
Test (2A): election after network failure ...
... Passed --   5.4  3  118   25269    0
Test (2A): multiple elections ...
... Passed --   7.3  7  624  138014    0
PASS
ok  	6.824/raft	16.265s
$
</code></pre>
<p>Each &quot;Passed&quot; line contains five numbers; these are the time that the test took in seconds, the number of Raft peers, the number of RPCs sent during the test, the total number of bytes in the RPC messages, and the number of log entries that Raft reports were committed. Your numbers will differ from those shown here. You can ignore the numbers if you like, but they may help you sanity-check the number of RPCs that your implementation sends. For all of labs 2, 3, and 4, the grading script will fail your solution if it takes more than 600 seconds for all of the tests (go test), or if any individual test takes more than 120 seconds.</p>
<p>æ¯ä¸€è¡Œ &quot;é€šè¿‡ &quot;åŒ…å«äº”ä¸ªæ•°å­—ï¼›å®ƒä»¬æ˜¯æµ‹è¯•æ‰€èŠ±çš„æ—¶é—´ï¼ˆç§’ï¼‰ã€Raftå¯¹ç­‰ä½“çš„æ•°é‡ã€æµ‹è¯•æœŸé—´å‘é€çš„RPCæ•°é‡ã€RPCæ¶ˆæ¯ä¸­çš„æ€»å­—èŠ‚æ•°ï¼Œä»¥åŠRaftæŠ¥å‘Šçš„æäº¤çš„æ—¥å¿—æ¡ç›®æ•°é‡ã€‚æ‚¨çš„æ•°å­—å°†ä¸è¿™é‡Œæ˜¾ç¤ºçš„æ•°å­—ä¸åŒã€‚å¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥å¿½ç•¥è¿™äº›æ•°å­—ï¼Œä½†å®ƒä»¬å¯ä»¥å¸®åŠ©ä½ ç†æ™ºåœ°æ£€æŸ¥ä½ çš„å®ç°æ‰€å‘é€çš„RPCçš„æ•°é‡ã€‚å¯¹äºæ‰€æœ‰çš„å®éªŒ2ã€3å’Œ4ï¼Œå¦‚æœä½ çš„è§£å†³æ–¹æ¡ˆåœ¨æ‰€æœ‰çš„æµ‹è¯•ä¸­èŠ±è´¹è¶…è¿‡600ç§’ï¼ˆå»æµ‹è¯•ï¼‰ï¼Œæˆ–è€…ä»»ä½•å•ç‹¬çš„æµ‹è¯•èŠ±è´¹è¶…è¿‡120ç§’ï¼Œè¯„åˆ†è„šæœ¬å°†ä¼šå¤±è´¥ã€‚</p>
<p>When we grade your submissions, we will run the tests without the -race flag but you should also make sure that your code consistently passes the tests with the -race flag.</p>
<p>å½“æˆ‘ä»¬å¯¹ä½ æäº¤çš„æ–‡ä»¶è¿›è¡Œè¯„åˆ†æ—¶ï¼Œæˆ‘ä»¬ä¼šåœ¨æ²¡æœ‰-raceæ ‡å¿—çš„æƒ…å†µä¸‹è¿è¡Œæµ‹è¯•ï¼Œä½†ä½ ä¹Ÿåº”è¯¥ç¡®ä¿ä½ çš„ä»£ç åœ¨æœ‰-raceæ ‡å¿—çš„æƒ…å†µä¸‹èƒ½æŒç»­é€šè¿‡æµ‹è¯•ã€‚</p>
<h2 id="part-2b-log-hard"><a class="header" href="#part-2b-log-hard">Part 2B: log (hard)</a></h2>
<p>Implement the leader and follower code to append new log entries, so that the go test -run 2B tests pass.</p>
<p>å®ç°é¢†å¯¼è€…å’Œè¿½éšè€…ä»£ç ï¼Œä»¥è¿½åŠ æ–°çš„æ—¥å¿—æ¡ç›®ï¼Œä»è€Œä½¿go test -run 2Bæµ‹è¯•é€šè¿‡ã€‚</p>
<p>Run git pull to get the latest lab software.</p>
<p>è¿è¡Œgit pullä»¥è·å¾—æœ€æ–°çš„å®éªŒå®¤è½¯ä»¶ã€‚</p>
<p>Your first goal should be to pass TestBasicAgree2B(). Start by implementing Start(), then write the code to send and receive new log entries via AppendEntries RPCs, following Figure 2. Send each newly committed entry on applyCh on each peer.</p>
<p>ä½ çš„ç¬¬ä¸€ä¸ªç›®æ ‡åº”è¯¥æ˜¯é€šè¿‡TestBasicAgree2Bï¼ˆï¼‰ã€‚ä»å®ç°Start()å¼€å§‹ï¼Œç„¶åç¼–å†™ä»£ç ï¼Œé€šè¿‡AppendEntries RPCså‘é€å’Œæ¥æ”¶æ–°çš„æ—¥å¿—æ¡ç›®ï¼Œå¦‚ä¸‹å›¾2ã€‚åœ¨æ¯ä¸ªå¯¹ç­‰ä½“çš„applyChä¸Šå‘é€æ¯ä¸ªæ–°æäº¤çš„æ¡ç›®ã€‚</p>
<p>You will need to implement the election restriction (section 5.4.1 in the paper).</p>
<p>ä½ å°†éœ€è¦å®æ–½é€‰ä¸¾é™åˆ¶ï¼ˆæ–‡ä»¶ä¸­çš„5.4.1èŠ‚ï¼‰ã€‚</p>
<p>One way to fail to reach agreement in the early Lab 2B tests is to hold repeated elections even though the leader is alive. Look for bugs in election timer management, or not sending out heartbeats immediately after winning an election.</p>
<p>åœ¨æ—©æœŸçš„Lab 2Bæµ‹è¯•ä¸­ï¼Œæ— æ³•è¾¾æˆåè®®çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ï¼Œå³ä½¿é¢†å¯¼äººè¿˜æ´»ç€ï¼Œä¹Ÿè¦é‡å¤ä¸¾è¡Œé€‰ä¸¾ã€‚å¯»æ‰¾é€‰ä¸¾å®šæ—¶å™¨ç®¡ç†ä¸­çš„é”™è¯¯ï¼Œæˆ–è€…åœ¨èµ¢å¾—é€‰ä¸¾åä¸ç«‹å³å‘é€å¿ƒè·³çš„é—®é¢˜ã€‚</p>
<p>Your code may have loops that repeatedly check for certain events. Don't have these loops execute continuously without pausing, since that will slow your implementation enough that it fails tests. Use Go's condition variables, or insert a time.Sleep(10 * time.Millisecond) in each loop iteration.</p>
<p>ä½ çš„ä»£ç å¯èƒ½æœ‰é‡å¤æ£€æŸ¥æŸäº›äº‹ä»¶çš„å¾ªç¯ã€‚ä¸è¦è®©è¿™äº›å¾ªç¯åœ¨æ²¡æœ‰æš‚åœçš„æƒ…å†µä¸‹è¿ç»­æ‰§è¡Œï¼Œå› ä¸ºè¿™å°†ä½¿ä½ çš„æ‰§è¡Œé€Ÿåº¦æ…¢åˆ°æ— æ³•é€šè¿‡æµ‹è¯•ã€‚ä½¿ç”¨ Go çš„æ¡ä»¶å˜é‡ï¼Œæˆ–è€…åœ¨æ¯ä¸ªå¾ªç¯è¿­ä»£ä¸­æ’å…¥ time.Sleep(10 * time.Millisecond) ã€‚</p>
<p>Do yourself a favor for future labs and write (or re-write) code that's clean and clear. For ideas, re-visit our the <a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html">Guidance page</a> with tips on how to develop and debug your code.</p>
<p>ä¸ºä½ è‡ªå·±å°†æ¥çš„å®éªŒå¸®ä¸ªå¿™ï¼Œå†™ï¼ˆæˆ–é‡å†™ï¼‰å¹²å‡€æ¸…æ™°çš„ä»£ç ã€‚æƒ³äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·é‡æ–°è®¿é—®æˆ‘ä»¬çš„æŒ‡å¯¼é¡µé¢ï¼Œäº†è§£å¦‚ä½•å¼€å‘å’Œè°ƒè¯•ä»£ç çš„æŠ€å·§ã€‚</p>
<p>If you fail a test, look over the code for the test in config.go and test_test.go to get a better understanding what the test is testing. config.go also illustrates how the tester uses the Raft API.</p>
<p>å¦‚æœä½ æµ‹è¯•å¤±è´¥ï¼Œè¯·æŸ¥çœ‹config.goå’Œtest_test.goä¸­çš„æµ‹è¯•ä»£ç ï¼Œä»¥æ›´å¥½åœ°äº†è§£æµ‹è¯•çš„å†…å®¹ã€‚config.goè¿˜è¯´æ˜äº†æµ‹è¯•äººå‘˜å¦‚ä½•ä½¿ç”¨Raft APIã€‚</p>
<p>The tests for upcoming labs may fail your code if it runs too slowly. You can check how much real time and CPU time your solution uses with the time command. Here's typical output:</p>
<p>å¦‚æœä½ çš„ä»£ç è¿è¡Œå¤ªæ…¢ï¼Œå³å°†è¿›è¡Œçš„å®éªŒå®¤æµ‹è¯•å¯èƒ½ä¼šå¤±è´¥ã€‚ä½ å¯ä»¥ç”¨æ—¶é—´å‘½ä»¤æ£€æŸ¥ä½ çš„è§£å†³æ–¹æ¡ˆä½¿ç”¨äº†å¤šå°‘å®æ—¶æ—¶é—´å’ŒCPUæ—¶é—´ã€‚ä¸‹é¢æ˜¯å…¸å‹çš„è¾“å‡ºã€‚</p>
<pre><code>$ time go test -run 2B
Test (2B): basic agreement ...
... Passed --   0.9  3   16    4572    3
Test (2B): RPC byte count ...
... Passed --   1.7  3   48  114536   11
Test (2B): agreement after follower reconnects ...
... Passed --   3.6  3   78   22131    7
Test (2B): no agreement if too many followers disconnect ...
... Passed --   3.8  5  172   40935    3
Test (2B): concurrent Start()s ...
... Passed --   1.1  3   24    7379    6
Test (2B): rejoin of partitioned leader ...
... Passed --   5.1  3  152   37021    4
Test (2B): leader backs up quickly over incorrect follower logs ...
... Passed --  17.2  5 2080 1587388  102
Test (2B): RPC counts aren't too high ...
... Passed --   2.2  3   60   20119   12
PASS
ok  	6.824/raft	35.557s

real	0m35.899s
user	0m2.556s
sys	0m1.458s
$
</code></pre>
<p>The &quot;ok 6.824/raft 35.557s&quot; means that Go measured the time taken for the 2B tests to be 35.557 seconds of real (wall-clock) time. The &quot;user 0m2.556s&quot; means that the code consumed 2.556 seconds of CPU time, or time spent actually executing instructions (rather than waiting or sleeping). If your solution uses much more than a minute of real time for the 2B tests, or much more than 5 seconds of CPU time, you may run into trouble later on. Look for time spent sleeping or waiting for RPC timeouts, loops that run without sleeping or waiting for conditions or channel messages, or large numbers of RPCs sent.</p>
<p>ok 6.824/raft 35.557s &quot;æ„å‘³ç€Goæµ‹é‡äº†2Bæµ‹è¯•æ‰€èŠ±è´¹çš„æ—¶é—´æ˜¯35.557ç§’çš„å®é™…ï¼ˆæŒ‚é’Ÿï¼‰æ—¶é—´ã€‚user 0m2.556s &quot;æ„å‘³ç€ä»£ç æ¶ˆè€—äº†2.556ç§’çš„CPUæ—¶é—´ï¼Œæˆ–å®é™…æ‰§è¡ŒæŒ‡ä»¤çš„æ—¶é—´ï¼ˆè€Œä¸æ˜¯ç­‰å¾…æˆ–ç¡çœ ï¼‰ã€‚å¦‚æœä½ çš„è§£å†³æ–¹æ¡ˆåœ¨2Bæµ‹è¯•ä¸­ä½¿ç”¨çš„å®é™…æ—¶é—´è¿œè¿œè¶…è¿‡1åˆ†é’Ÿï¼Œæˆ–è€…è¿œè¿œè¶…è¿‡5ç§’çš„CPUæ—¶é—´ï¼Œä½ ä»¥åå¯èƒ½ä¼šé‡åˆ°éº»çƒ¦ã€‚å¯»æ‰¾èŠ±è´¹åœ¨ç¡çœ æˆ–ç­‰å¾…RPCè¶…æ—¶ä¸Šçš„æ—¶é—´ï¼Œåœ¨æ²¡æœ‰ç¡çœ æˆ–ç­‰å¾…æ¡ä»¶æˆ–é€šé“æ¶ˆæ¯çš„æƒ…å†µä¸‹è¿è¡Œçš„å¾ªç¯ï¼Œæˆ–å‘é€å¤§é‡çš„RPCã€‚</p>
<h2 id="part-2c-persistence-hard"><a class="header" href="#part-2c-persistence-hard">Part 2C: persistence (hard)</a></h2>
<p>If a Raft-based server reboots it should resume service where it left off. This requires that Raft keep persistent state that survives a reboot. The paper's Figure 2 mentions which state should be persistent.</p>
<p>å¦‚æœåŸºäºRaftçš„æœåŠ¡å™¨é‡æ–°å¯åŠ¨ï¼Œå®ƒåº”è¯¥åœ¨å…¶åœæ­¢çš„åœ°æ–¹æ¢å¤æœåŠ¡ã€‚è¿™å°±è¦æ±‚Raftåœ¨é‡å¯åä»èƒ½ä¿æŒæŒä¹…çš„çŠ¶æ€ã€‚è¯¥æ–‡ä»¶çš„å›¾2æåˆ°äº†å“ªäº›çŠ¶æ€åº”è¯¥æ˜¯æŒä¹…çš„ã€‚</p>
<p>A real implementation would write Raft's persistent state to disk each time it changed, and would read the state from disk when restarting after a reboot. Your implementation won't use the disk; instead, it will save and restore persistent state from a Persister object (see persister.go). Whoever calls Raft.Make() supplies a Persister that initially holds Raft's most recently persisted state (if any). Raft should initialize its state from that Persister, and should use it to save its persistent state each time the state changes. Use the Persister's ReadRaftState() and SaveRaftState() methods.</p>
<p>çœŸæ­£çš„å®ç°ä¼šåœ¨æ¯æ¬¡Raftçš„æŒä¹…åŒ–çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶å°†å…¶å†™å…¥ç£ç›˜ï¼Œå¹¶åœ¨é‡å¯åé‡æ–°å¯åŠ¨æ—¶ä»ç£ç›˜è¯»å–çŠ¶æ€ã€‚ä½ çš„å®ç°ä¸ä¼šä½¿ç”¨ç£ç›˜ï¼›ç›¸åï¼Œå®ƒå°†ä»Persisterå¯¹è±¡ï¼ˆè§persister.goï¼‰ä¿å­˜å’Œæ¢å¤æŒä¹…åŒ–çŠ¶æ€ã€‚è°ƒç”¨Raft.Make()çš„äººæä¾›äº†ä¸€ä¸ªPersisterï¼Œå®ƒæœ€åˆæŒæœ‰Raftæœ€è¿‘çš„æŒä¹…åŒ–çŠ¶æ€ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚Raftåº”è¯¥ä»è¯¥Persisteråˆå§‹åŒ–å…¶çŠ¶æ€ï¼Œå¹¶åœ¨æ¯æ¬¡çŠ¶æ€æ”¹å˜æ—¶ä½¿ç”¨å®ƒæ¥ä¿å­˜å…¶æŒä¹…åŒ–çŠ¶æ€ã€‚ä½¿ç”¨Persisterçš„ReadRaftStateï¼ˆï¼‰å’ŒSaveRaftStateï¼ˆï¼‰æ–¹æ³•ã€‚</p>
<p>Complete the functions persist() and readPersist() in raft.go by adding code to save and restore persistent state. You will need to encode (or &quot;serialize&quot;) the state as an array of bytes in order to pass it to the Persister. Use the labgob encoder; see the comments in persist() and readPersist(). labgob is like Go's gob encoder but prints error messages if you try to encode structures with lower-case field names. Insert calls to persist() at the points where your implementation changes persistent state. Once you've done this, and if the rest of your implementation is correct, you should pass all of the 2C tests.</p>
<p>é€šè¿‡æ·»åŠ ä¿å­˜å’Œæ¢å¤æŒä¹…åŒ–çŠ¶æ€çš„ä»£ç ï¼Œå®Œæˆraft.goä¸­çš„ persist() å’Œ readPersist() å‡½æ•°ã€‚ä½ å°†éœ€è¦æŠŠçŠ¶æ€ç¼–ç ï¼ˆæˆ– &quot;åºåˆ—åŒ–&quot;ï¼‰ä¸ºä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œä»¥ä¾¿å°†å…¶ä¼ é€’ç»™æŒä¹…åŒ–å™¨ã€‚ä½¿ç”¨labgobç¼–ç å™¨ï¼›å‚è§persist()å’ŒreadPersist()ä¸­çš„æ³¨é‡Šã€‚labgobå°±åƒGoçš„gobç¼–ç å™¨ï¼Œä½†å¦‚æœä½ è¯•å›¾ç”¨å°å†™çš„å­—æ®µåå¯¹ç»“æ„è¿›è¡Œç¼–ç ï¼Œä¼šæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯ã€‚åœ¨ä½ çš„å®ç°æ”¹å˜æŒä¹…åŒ–çŠ¶æ€çš„åœ°æ–¹æ’å…¥å¯¹persist()çš„è°ƒç”¨ã€‚ä¸€æ—¦ä½ å®Œæˆäº†è¿™äº›ï¼Œå¹¶ä¸”å¦‚æœä½ çš„å…¶ä»–å®ç°æ˜¯æ­£ç¡®çš„ï¼Œä½ å°±åº”è¯¥é€šè¿‡æ‰€æœ‰çš„2Cæµ‹è¯•ã€‚</p>
<p>Run git pull to get the latest lab software.</p>
<p>è¿è¡Œgit pullä»¥è·å¾—æœ€æ–°çš„å®éªŒå®¤è½¯ä»¶ã€‚</p>
<p>The 2C tests are more demanding than those for 2A or 2B, and failures may be caused by problems in your code for 2A or 2B.</p>
<p>2Cæµ‹è¯•æ¯”2Aæˆ–2Bçš„æµ‹è¯•è¦æ±‚æ›´é«˜ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç”±äºä½ çš„2Aæˆ–2Bçš„ä»£ç æœ‰é—®é¢˜é€ æˆçš„ã€‚</p>
<p>You will probably need the optimization that backs up nextIndex by more than one entry at a time. Look at the extended Raft paper starting at the bottom of page 7 and top of page 8 (marked by a gray line). The paper is vague about the details; you will need to fill in the gaps, perhaps with the help of the 6.824 Raft lecture notes.</p>
<p>ä½ å¯èƒ½ä¼šéœ€è¦ä¸€æ¬¡å¤‡ä»½å¤šä¸ªæ¡ç›®çš„NextIndexçš„ä¼˜åŒ–ã€‚çœ‹çœ‹ä»ç¬¬7é¡µåº•éƒ¨å’Œç¬¬8é¡µé¡¶éƒ¨å¼€å§‹çš„æ‰©å±•Raftè®ºæ–‡ï¼ˆç”¨ç°çº¿æ ‡è®°ï¼‰ã€‚è®ºæ–‡ä¸­çš„ç»†èŠ‚å¾ˆæ¨¡ç³Šï¼Œä½ éœ€è¦å¡«è¡¥è¿™äº›ç©ºç™½ï¼Œä¹Ÿè®¸å¯ä»¥å€ŸåŠ©6.824 Raftçš„è®²ä¹‰ã€‚</p>
<p>Your code should pass all the 2C tests (as shown below), as well as the 2A and 2B tests.</p>
<p>ä½ çš„ä»£ç åº”è¯¥é€šè¿‡æ‰€æœ‰2Cæµ‹è¯•ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ï¼Œä»¥åŠ2Aå’Œ2Bæµ‹è¯•ã€‚</p>
<pre><code>$ go test -run 2C
Test (2C): basic persistence ...
... Passed --   5.0  3   86   22849    6
Test (2C): more persistence ...
... Passed --  17.6  5  952  218854   16
Test (2C): partitioned leader and one follower crash, leader restarts ...
... Passed --   2.0  3   34    8937    4
Test (2C): Figure 8 ...
... Passed --  31.2  5  580  130675   32
Test (2C): unreliable agreement ...
... Passed --   1.7  5 1044  366392  246
Test (2C): Figure 8 (unreliable) ...
... Passed --  33.6  5 10700 33695245  308
Test (2C): churn ...
... Passed --  16.1  5 8864 44771259 1544
Test (2C): unreliable churn ...
... Passed --  16.5  5 4220 6414632  906
PASS
ok  	6.824/raft	123.564s
$
</code></pre>
<p>It is a good idea to run the tests multiple times before submitting and check that each run prints PASS.</p>
<p>åœ¨æäº¤ä¹‹å‰ï¼Œæœ€å¥½å¤šæ¬¡è¿è¡Œæµ‹è¯•ï¼Œå¹¶æ£€æŸ¥æ¯ä¸€æ¬¡è¿è¡Œéƒ½æ‰“å°å‡ºPASSã€‚</p>
<pre><code>$ for i in {0..10}; do go test; done
</code></pre>
<h2 id="part-2d-log-compaction-hard"><a class="header" href="#part-2d-log-compaction-hard">Part 2D: log compaction (hard)</a></h2>
<p>As things stand now, a rebooting server replays the complete Raft log in order to restore its state. However, it's not practical for a long-running service to remember the complete Raft log forever. Instead, you'll modify Raft to cooperate with services that persistently store a &quot;snapshot&quot; of their state from time to time, at which point Raft discards log entries that precede the snapshot. The result is a smaller amount of persistent data and faster restart. However, it's now possible for a follower to fall so far behind that the leader has discarded the log entries it needs to catch up; the leader must then send a snapshot plus the log starting at the time of the snapshot. Section 7 of the extended Raft paper outlines the scheme; you will have to design the details.</p>
<p>æŒ‰ç…§ç›®å‰çš„æƒ…å†µï¼Œé‡æ–°å¯åŠ¨çš„æœåŠ¡å™¨ä¼šå¤åˆ¶å®Œæ•´çš„Raftæ—¥å¿—ï¼Œä»¥æ¢å¤å…¶çŠ¶æ€ã€‚ç„¶è€Œï¼Œå¯¹äºä¸€ä¸ªé•¿æœŸè¿è¡Œçš„æœåŠ¡æ¥è¯´ï¼Œæ°¸è¿œè®°ä½å®Œæ•´çš„Raftæ—¥å¿—æ˜¯ä¸ç°å®çš„ã€‚ç›¸åï¼Œä½ å°†ä¿®æ”¹Raftï¼Œä½¿å…¶ä¸é‚£äº›ä¸æ—¶æŒä¹…æ€§åœ°å­˜å‚¨å…¶çŠ¶æ€çš„ &quot;å¿«ç…§ &quot;çš„æœåŠ¡åˆä½œï¼Œæ­¤æ—¶Raftä¼šä¸¢å¼ƒå¿«ç…§ä¹‹å‰çš„æ—¥å¿—æ¡ç›®ã€‚å…¶ç»“æœæ˜¯æŒä¹…æ€§æ•°æ®é‡æ›´å°ï¼Œé‡å¯é€Ÿåº¦æ›´å¿«ã€‚ç„¶è€Œï¼Œç°åœ¨è¿½éšè€…æœ‰å¯èƒ½è½åå¤ªå¤šï¼Œä»¥è‡³äºé¢†å¯¼è€…ä¸¢å¼ƒäº†å®ƒéœ€è¦è¿½èµ¶çš„æ—¥å¿—æ¡ç›®ï¼›ç„¶åé¢†å¯¼è€…å¿…é¡»å‘é€ä¸€ä¸ªå¿«ç…§ï¼ŒåŠ ä¸Šå¿«ç…§æ—¶é—´å¼€å§‹çš„æ—¥å¿—ã€‚æ‰©å±•çš„Raftè®ºæ–‡çš„ç¬¬7èŠ‚æ¦‚è¿°äº†è¯¥æ–¹æ¡ˆï¼›ä½ å¿…é¡»è®¾è®¡ç»†èŠ‚ã€‚</p>
<p>You may find it helpful to refer to the diagram of Raft interactions to understand how the replicated service and Raft communicate.</p>
<p>ä½ å¯èƒ½ä¼šå‘ç°å‚è€ƒRaftçš„äº¤äº’å›¾å¯¹äº†è§£å¤åˆ¶çš„æœåŠ¡å’ŒRaftçš„é€šä¿¡æ–¹å¼å¾ˆæœ‰å¸®åŠ©ã€‚</p>
<p>Your Raft must provide the following function that the service can call with a serialized snapshot of its state:</p>
<p>ä½ çš„Raftå¿…é¡»æä¾›ä»¥ä¸‹å‡½æ•°ï¼ŒæœåŠ¡å¯ä»¥ç”¨å…¶çŠ¶æ€çš„åºåˆ—åŒ–å¿«ç…§æ¥è°ƒç”¨ã€‚</p>
<pre><code>Snapshot(index int, snapshot []byte)
</code></pre>
<p>In Lab 2D, the tester calls Snapshot() periodically. In Lab 3, you will write a key/value server that calls Snapshot(); the snapshot will contain the complete table of key/value pairs. The service layer calls Snapshot() on every peer (not just on the leader).</p>
<p>åœ¨Lab 2Dä¸­ï¼Œæµ‹è¯•è€…å®šæœŸè°ƒç”¨Snapshot()ã€‚åœ¨å®éªŒå®¤3ä¸­ï¼Œä½ å°†ç¼–å†™ä¸€ä¸ªè°ƒç”¨Snapshot()çš„é”®/å€¼æœåŠ¡å™¨ï¼›å¿«ç…§å°†åŒ…å«é”®/å€¼å¯¹çš„å®Œæ•´è¡¨æ ¼ã€‚æœåŠ¡å±‚åœ¨æ¯ä¸ªå¯¹ç­‰ä½“ä¸Šè°ƒç”¨Snapshot()ï¼ˆè€Œä¸ä»…ä»…æ˜¯åœ¨é¢†å¯¼è€…ä¸Šï¼‰ã€‚</p>
<p>The index argument indicates the highest log entry that's reflected in the snapshot. Raft should discard its log entries before that point. You'll need to revise your Raft code to operate while storing only the tail of the log.</p>
<p>indexå‚æ•°è¡¨ç¤ºåœ¨å¿«ç…§ä¸­åæ˜ çš„æœ€é«˜æ—¥å¿—æ¡ç›®ã€‚Raft åº”è¯¥ä¸¢å¼ƒåœ¨è¯¥ç‚¹ä¹‹å‰çš„æ—¥å¿—æ¡ç›®ã€‚ä½ éœ€è¦ä¿®æ”¹ä½ çš„Raftä»£ç ï¼Œä»¥ä¾¿åœ¨æ“ä½œæ—¶åªå­˜å‚¨æ—¥å¿—çš„å°¾éƒ¨ã€‚</p>
<p>You'll need to implement the InstallSnapshot RPC discussed in the paper that allows a Raft leader to tell a lagging Raft peer to replace its state with a snapshot. You will likely need to think through how InstallSnapshot should interact with the state and rules in Figure 2.</p>
<p>ä½ éœ€è¦å®ç°è®ºæ–‡ä¸­è®¨è®ºçš„ InstallSnapshot RPCï¼Œå®ƒå…è®¸ Raft é¢†å¯¼å‘Šè¯‰è½åçš„ Raft å¯¹ç­‰ä½“ç”¨å¿«ç…§æ›¿æ¢å…¶çŠ¶æ€ã€‚ä½ å¯èƒ½éœ€è¦è€ƒè™‘InstallSnapshotåº”è¯¥å¦‚ä½•ä¸å›¾2ä¸­çš„çŠ¶æ€å’Œè§„åˆ™äº’åŠ¨ã€‚</p>
<p>When a follower's Raft code receives an InstallSnapshot RPC, it can use the applyCh to send the snapshot to the service in an ApplyMsg. The ApplyMsg struct definition already contains the fields you will need (and which the tester expects). Take care that these snapshots only advance the service's state, and don't cause it to move backwards.</p>
<p>å½“è·Ÿéšè€…çš„ Raft ä»£ç æ”¶åˆ° InstallSnapshot RPC æ—¶ï¼Œå®ƒå¯ä»¥ä½¿ç”¨ applyCh åœ¨ ApplyMsg ä¸­å‘æœåŠ¡å‘é€å¿«ç…§ã€‚ApplyMsg ç»“æ„å®šä¹‰å·²ç»åŒ…å«äº†æ‚¨éœ€è¦çš„å­—æ®µï¼ˆä¹Ÿæ˜¯æµ‹è¯•äººå‘˜æ‰€æœŸæœ›çš„ï¼‰ã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å¿«ç…§åªèƒ½æ¨è¿›æœåŠ¡çš„çŠ¶æ€ï¼Œè€Œä¸ä¼šå¯¼è‡´å®ƒå‘åç§»åŠ¨ã€‚</p>
<p>If a server crashes, it must restart from persisted data. Your Raft should persist both Raft state and the corresponding snapshot. Use persister.SaveStateAndSnapshot(), which takes separate arguments for the Raft state and the corresponding snapshot. If there's no snapshot, pass nil as the snapshot argument.</p>
<p>å¦‚æœä¸€ä¸ªæœåŠ¡å™¨å´©æºƒäº†ï¼Œå®ƒå¿…é¡»ä»æŒä¹…åŒ–çš„æ•°æ®ä¸­é‡æ–°å¯åŠ¨ã€‚ä½ çš„Raftåº”è¯¥åŒæ—¶ä¿å­˜RaftçŠ¶æ€å’Œç›¸åº”çš„å¿«ç…§ã€‚ä½¿ç”¨ persister.SaveStateAndSnapshot()ï¼Œå®ƒä¸º Raft çŠ¶æ€å’Œç›¸åº”çš„å¿«ç…§æ¥å—å•ç‹¬çš„å‚æ•°ã€‚å¦‚æœæ²¡æœ‰å¿«ç…§ï¼Œåˆ™ä¼ é€’nilä½œä¸ºå¿«ç…§å‚æ•°ã€‚</p>
<p>When a server restarts, the application layer reads the persisted snapshot and restores its saved state.</p>
<p>å½“æœåŠ¡å™¨é‡æ–°å¯åŠ¨æ—¶ï¼Œåº”ç”¨å±‚ä¼šè¯»å–æŒä¹…åŒ–çš„å¿«ç…§å¹¶æ¢å¤å…¶ä¿å­˜çš„çŠ¶æ€ã€‚</p>
<p>Previously, this lab recommended that you implement a function called CondInstallSnapshot to avoid the requirement that snapshots and log entries sent on applyCh are coordinated. This vestigal API interface remains, but you are discouraged from implementing it: instead, we suggest that you simply have it return true.</p>
<p>ä»¥å‰ï¼Œæœ¬å®éªŒå®¤å»ºè®®ä½ å®ç°ä¸€ä¸ªå«åšCondInstallSnapshotçš„å‡½æ•°ï¼Œä»¥é¿å…åœ¨applyChä¸Šå‘é€çš„å¿«ç…§å’Œæ—¥å¿—æ¡ç›®è¢«åè°ƒçš„è¦æ±‚ã€‚è¿™ä¸ªæ®‹å­˜çš„APIæ¥å£ä»ç„¶å­˜åœ¨ï¼Œä½†æˆ‘ä»¬ä¸é¼“åŠ±ä½ å»å®ç°å®ƒï¼šç›¸åï¼Œæˆ‘ä»¬å»ºè®®ä½ åªéœ€è®©å®ƒè¿”å›trueã€‚</p>
<p>Implement Snapshot() and the InstallSnapshot RPC, as well as the changes to Raft to support these (e.g, operation with a trimmed log). Your solution is complete when it passes the 2D tests (and all the previous Lab 2 tests).</p>
<p>å®ç°Snapshot()å’ŒInstallSnapshot RPCï¼Œä»¥åŠå¯¹Raftçš„ä¿®æ”¹ä»¥æ”¯æŒè¿™äº›åŠŸèƒ½ï¼ˆä¾‹å¦‚ï¼Œç”¨ä¿®å‰ªåçš„æ—¥å¿—è¿›è¡Œæ“ä½œï¼‰ã€‚å½“ä½ çš„è§£å†³æ–¹æ¡ˆé€šè¿‡2Dæµ‹è¯•ï¼ˆä»¥åŠä¹‹å‰æ‰€æœ‰çš„Lab 2æµ‹è¯•ï¼‰æ—¶ï¼Œå°±å®Œæˆäº†ã€‚</p>
<p>git pull to make sure you have the latest software.</p>
<p>git pullä»¥ç¡®ä¿ä½ æœ‰æœ€æ–°çš„è½¯ä»¶ã€‚</p>
<p>A good place to start is to modify your code to so that it is able to store just the part of the log starting at some index X. Initially you can set X to zero and run the 2B/2C tests. Then make Snapshot(index) discard the log before index, and set X equal to index. If all goes well you should now pass the first 2D test.</p>
<p>ä¸€ä¸ªå¥½çš„å¼€å§‹æ˜¯ä¿®æ”¹ä½ çš„ä»£ç ï¼Œä½¿å…¶èƒ½å¤Ÿåªå­˜å‚¨ä»æŸä¸ªç´¢å¼•Xå¼€å§‹çš„æ—¥å¿—éƒ¨åˆ†ã€‚æœ€åˆä½ å¯ä»¥å°†Xè®¾ç½®ä¸ºé›¶ï¼Œå¹¶è¿è¡Œ2B/2Cæµ‹è¯•ã€‚ç„¶åè®©Snapshot(index)ä¸¢å¼ƒç´¢å¼•ä¹‹å‰çš„æ—¥å¿—ï¼Œå¹¶å°†Xè®¾ç½®ä¸ºç­‰äºç´¢å¼•ã€‚å¦‚æœä¸€åˆ‡é¡ºåˆ©ï¼Œä½ ç°åœ¨åº”è¯¥é€šè¿‡ç¬¬ä¸€ä¸ª2Dæµ‹è¯•ã€‚</p>
<p>You won't be able to store the log in a Go slice and use Go slice indices interchangeably with Raft log indices; you'll need to index the slice in a way that accounts for the discarded portion of the log.</p>
<p>ä½ ä¸èƒ½å°†æ—¥å¿—å­˜å‚¨åœ¨Goåˆ†ç‰‡ä¸­ï¼Œå¹¶å°†Goåˆ†ç‰‡ç´¢å¼•ä¸Raftæ—¥å¿—ç´¢å¼•äº’æ¢ä½¿ç”¨ï¼›ä½ éœ€è¦å¯¹åˆ†ç‰‡è¿›è¡Œç´¢å¼•ï¼Œä»¥è¯´æ˜æ—¥å¿—ä¸­è¢«ä¸¢å¼ƒçš„éƒ¨åˆ†ã€‚</p>
<p>Next: have the leader send an InstallSnapshot RPC if it doesn't have the log entries required to bring a follower up to date.</p>
<p>ä¸‹ä¸€æ­¥ï¼šå¦‚æœé¢†å¯¼è€…æ²¡æœ‰ä½¿è¿½éšè€…æ›´æ–°æ‰€éœ€çš„æ—¥å¿—æ¡ç›®ï¼Œå°±è®©å®ƒå‘é€InstallSnapshot RPCã€‚</p>
<p>Send the entire snapshot in a single InstallSnapshot RPC. Don't implement Figure 13's offset mechanism for splitting up the snapshot.</p>
<p>åœ¨å•ä¸ª InstallSnapshot RPC ä¸­å‘é€æ•´ä¸ªå¿«ç…§ã€‚ä¸è¦å®ç°å›¾13çš„åç§»æœºåˆ¶æ¥åˆ†å‰²å¿«ç…§ã€‚</p>
<p>Raft must discard old log entries in a way that allows the Go garbage collector to free and re-use the memory; this requires that there be no reachable references (pointers) to the discarded log entries.</p>
<p>Raftå¿…é¡»ä»¥å…è®¸Goåƒåœ¾æ”¶é›†å™¨é‡Šæ”¾å’Œé‡æ–°ä½¿ç”¨å†…å­˜çš„æ–¹å¼ä¸¢å¼ƒæ—§çš„æ—¥å¿—æ¡ç›®ï¼›è¿™è¦æ±‚å¯¹è¢«ä¸¢å¼ƒçš„æ—¥å¿—æ¡ç›®æ²¡æœ‰å¯åŠçš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰ã€‚</p>
<p>Even when the log is trimmed, your implemention still needs to properly send the term and index of the entry prior to new entries in AppendEntries RPCs; this may require saving and referencing the latest snapshot's lastIncludedTerm/lastIncludedIndex (consider whether this should be persisted).</p>
<p>å³ä½¿æ—¥å¿—è¢«ä¿®å‰ªï¼Œä½ çš„å®ç°ä»ç„¶éœ€è¦åœ¨AppendEntries RPCsä¸­çš„æ–°æ¡ç›®ä¹‹å‰æ­£ç¡®å‘é€æ¡ç›®çš„æœ¯è¯­å’Œç´¢å¼•ï¼›è¿™å¯èƒ½éœ€è¦ä¿å­˜å’Œå¼•ç”¨æœ€æ–°å¿«ç…§çš„lastIncludedTerm/lastIncludedIndexï¼ˆè€ƒè™‘è¿™æ˜¯å¦åº”è¯¥è¢«æŒç»­ä¿å­˜ï¼‰ã€‚</p>
<p>A reasonable amount of time to consume for the full set of Lab 2 tests (2A+2B+2C+2D) without -race is 6 minutes of real time and one minute of CPU time. When running with -race, it is about 10 minutes of real time and two minutes of CPU time.</p>
<p>åœ¨æ²¡æœ‰-raceçš„æƒ…å†µä¸‹ï¼Œå®éªŒå®¤2çš„å…¨å¥—æµ‹è¯•ï¼ˆ2A+2B+2C+2Dï¼‰çš„åˆç†è€—æ—¶æ˜¯6åˆ†é’Ÿçš„çœŸå®æ—¶é—´å’Œ1åˆ†é’Ÿçš„CPUæ—¶é—´ã€‚å½“ç”¨-raceè¿è¡Œæ—¶ï¼Œå¤§çº¦æ˜¯10åˆ†é’Ÿçš„çœŸå®æ—¶é—´å’Œ2åˆ†é’Ÿçš„CPUæ—¶é—´ã€‚</p>
<p>Your code should pass all the 2D tests (as shown below), as well as the 2A, 2B, and 2C tests.</p>
<p>ä½ çš„ä»£ç åº”è¯¥é€šè¿‡æ‰€æœ‰çš„2Dæµ‹è¯•ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ï¼Œä»¥åŠ2Aã€2Bå’Œ2Cæµ‹è¯•ã€‚</p>
<pre><code>$ go test -run 2D
Test (2D): snapshots basic ...
... Passed --  11.6  3  176   61716  192
Test (2D): install snapshots (disconnect) ...
... Passed --  64.2  3  878  320610  336
Test (2D): install snapshots (disconnect+unreliable) ...
... Passed --  81.1  3 1059  375850  341
Test (2D): install snapshots (crash) ...
... Passed --  53.5  3  601  256638  339
Test (2D): install snapshots (unreliable+crash) ...
... Passed --  63.5  3  687  288294  336
Test (2D): crash and restart all servers ...
... Passed --  19.5  3  268   81352   58
PASS
ok      6.824/raft      293.456s
</code></pre>
<p>Again, a reminder that when we grade your submissions, we will run the tests without the -race flag but you should also make sure that your code consistently passes the tests with the -race flag.</p>
<p>å†æ¬¡æé†’æ‚¨ï¼Œå½“æˆ‘ä»¬å¯¹æ‚¨æäº¤çš„æ–‡ä»¶è¿›è¡Œè¯„åˆ†æ—¶ï¼Œæˆ‘ä»¬å°†åœ¨æ²¡æœ‰-raceæ ‡å¿—çš„æƒ…å†µä¸‹è¿è¡Œæµ‹è¯•ï¼Œä½†æ‚¨ä¹Ÿåº”è¯¥ç¡®ä¿æ‚¨çš„ä»£ç åœ¨æœ‰-raceæ ‡å¿—çš„æƒ…å†µä¸‹å§‹ç»ˆé€šè¿‡æµ‹è¯•ã€‚</p>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../6.824/1-lab1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../6.824/2-lab2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../6.824/1-lab1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../6.824/2-lab2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "6.824/2-lab2-cn.md"
    </script>


    <!-- Custom JS scripts -->


</body>
</html>