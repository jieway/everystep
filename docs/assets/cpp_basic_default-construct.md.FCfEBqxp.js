import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/default-construct.md","filePath":"cpp/basic/default-construct.md"}'),l={name:"cpp/basic/default-construct.md"},t=n(`<p>在C++中，如果你只定义了一个析构函数而没有定义任何构造函数，编译器会为你的类自动生成几个特殊的成员函数。具体来说，编译器将自动生成默认构造函数、拷贝构造函数和拷贝赋值运算符。从C++11开始，还会生成移动构造函数和移动赋值运算符。这些自动生成的函数是为了确保类的对象可以被正常构造、复制、移动和销毁。</p><p>让我们通过一个例子来说明这一点：</p><h3 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">iostream</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> namespace</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> MyClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 自定义析构函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    ~MyClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">析构函数被调用</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    MyClass a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">           // 调用自动生成的默认构造函数</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    MyClass b </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">       // 调用自动生成的拷贝构造函数</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    MyClass </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">MyClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 调用自动生成的移动构造函数（C++11及以后）</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    b </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               // 调用自动生成的拷贝赋值运算符</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    c </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">move</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 调用自动生成的移动赋值运算符（C++11及以后）</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><h3 id="解释" tabindex="-1">解释 <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释&quot;">​</a></h3><ul><li><p><strong>默认构造函数</strong>：当<code>MyClass a;</code>被执行时，自动生成的默认构造函数被调用，用于初始化对象<code>a</code>。</p></li><li><p><strong>拷贝构造函数</strong>：当<code>MyClass b = a;</code>被执行时，自动生成的拷贝构造函数被调用，用于创建对象<code>b</code>作为<code>a</code>的副本。</p></li><li><p><strong>移动构造函数（C++11及以后）</strong>：当<code>MyClass c(MyClass());</code>被执行时，由于使用了临时对象，自动生成的移动构造函数被调用（如果你使用的是C++11或更高版本）。</p></li><li><p><strong>拷贝赋值运算符</strong>：当执行<code>b = a;</code>时，自动生成的拷贝赋值运算符被调用，用于将<code>a</code>的内容复制到<code>b</code>。</p></li><li><p><strong>移动赋值运算符（C++11及以后）</strong>：当执行<code>c = std::move(a);</code>时，自动生成的移动赋值运算符被调用（在C++11及以后），用于将<code>a</code>的内容移动到<code>c</code>。</p></li></ul><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h3><ul><li>如果你定义了自己的拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符，编译器将不会自动生成这些函数。</li><li>自C++11起，如果你显式定义了析构函数，编译器仍然会自动生成移动构造函数和移动赋值运算符，但这种行为在某些情况下可能会被抑制（比如当你也定义了拷贝构造函数或拷贝赋值运算符时）。</li></ul>`,8),h=[t];function p(k,e,d,r,c,o){return a(),i("div",null,h)}const A=s(l,[["render",p]]);export{y as __pageData,A as default};
