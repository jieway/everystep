import{_ as s,c as i,o as a,R as t}from"./chunks/framework.2bglP9T5.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"alg/linklist/lc-1206.md","filePath":"alg/linklist/lc-1206.md"}'),n={name:"alg/linklist/lc-1206.md"},h=t(`<p>跳表存在的场景还是蛮多了，例如 Redis 和 LevelDB 中都有跳表，面试的时候被问到的频率不低。看完下面的内容就能写这道题了：力扣 1206. 设计跳表 <a href="https://leetcode.cn/problems/design-skiplist/description/" target="_blank" rel="noreferrer">https://leetcode.cn/problems/design-skiplist/description/</a></p><p>跳表是一种数据结构，可以被看作是对标准链表的一种改进，使得查找数据的速度变得更快。</p><p>接下来会逐层展示跳表的遍历过程，并在每一层都画出相应的图。下面的例子跳表有 4 层，存储的整数值如下，目标值 <code>target = 50</code>。</p><h3 id="初始跳表" tabindex="-1">初始跳表 <a class="header-anchor" href="#初始跳表" aria-label="Permalink to &quot;初始跳表&quot;">​</a></h3><p>跳表在链表的基础上增加了多层额外的链表，每一层都跳过一些元素，从而加快搜索速度。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 -------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><ul><li><strong>Level 0</strong> 是原始链表，包含所有元素。</li><li><strong>Level 1</strong> 是第二层，它跳过了一些元素（例如，它可能只包含每两个元素中的一个）。</li><li><strong>Level 3</strong> 是顶层，跳过更多的元素（例如，它可能只包含每四个元素中的一个）。</li></ul><p>当进行搜索时，你会从最顶层开始，这允许你跳过大部分元素。一旦你到达了需要下降到更低层继续搜索的点，就向下移动一层，再继续搜索。这个过程一直持续到找到目标元素或到达最底层链表。</p><p>这种结构使得跳表在查找元素时比普通链表更加高效，因为它减少了需要遍历的节点数量。同时，跳表在插入和删除操作时也保持了较高的效率，因为只需更新相对较少的链接。</p><h3 id="遍历-level-3" tabindex="-1">遍历 Level 3 <a class="header-anchor" href="#遍历-level-3" aria-label="Permalink to &quot;遍历 Level 3&quot;">​</a></h3><ul><li><code>p</code> 从 <code>Head</code> 开始。</li><li><code>p</code> 移动到 <code>11</code> -&gt; <code>33</code>。</li><li><code>p</code> 到达 <code>55</code>，停止（因为 <code>55 &gt; 50</code>）。<code>pre[3] = 33</code>。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 (pre[3]) ----------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><h3 id="遍历-level-2" tabindex="-1">遍历 Level 2 <a class="header-anchor" href="#遍历-level-2" aria-label="Permalink to &quot;遍历 Level 2&quot;">​</a></h3><ul><li><code>p</code> 继续从 <code>33</code> 开始。</li><li><code>p</code> 移动到 <code>44</code>。</li><li><code>p</code> 到达 <code>55</code>，停止（因为 <code>55 &gt; 50</code>）。<code>pre[2] = 44</code>。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 -------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 (pre[2]) ----------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><h3 id="遍历-level-1" tabindex="-1">遍历 Level 1 <a class="header-anchor" href="#遍历-level-1" aria-label="Permalink to &quot;遍历 Level 1&quot;">​</a></h3><ul><li><code>p</code> 从 <code>44</code> 开始。</li><li><code>p</code> 移动到 <code>48</code>。</li><li><code>p</code> 到达 <code>55</code>，停止（因为 <code>55 &gt; 50</code>）。<code>pre[1] = 48</code>。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 ----------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 ----------------------&gt; 55 ----------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 (pre[1]) -&gt; 55 ---&gt; 59 --------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><h3 id="遍历-level-0" tabindex="-1">遍历 Level 0 <a class="header-anchor" href="#遍历-level-0" aria-label="Permalink to &quot;遍历 Level 0&quot;">​</a></h3><ul><li><code>p</code> 从 <code>48</code> 开始。</li><li><code>p</code> 到达 <code>51</code>，停止（因为 <code>51 &gt; 50</code>）。<code>pre[0] = 48</code>。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 ----------------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 ----------------------------&gt; 55 ----------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 ----------------&gt; 55 -------&gt; 59 ----&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 (pre[0]) -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><h3 id="结果" tabindex="-1">结果 <a class="header-anchor" href="#结果" aria-label="Permalink to &quot;结果&quot;">​</a></h3><p>最终 <code>pre</code> 数组中的节点如下，这些节点表示在每个层级中最后一个小于 <code>50</code> 的节点：</p><ul><li><code>pre[3]</code> = 节点 33</li><li><code>pre[2]</code> = 节点 44</li><li><code>pre[1]</code> = 节点 48</li><li><code>pre[0]</code> = 节点 48</li></ul><p>在这个过程中，我们可以看到 <code>find</code> 函数是如何在每个层级中逐步靠近目标值的位置，从而高效地定位目标值可能存在的地方。</p><h3 id="数据结构设计" tabindex="-1">数据结构设计 <a class="header-anchor" href="#数据结构设计" aria-label="Permalink to &quot;数据结构设计&quot;">​</a></h3><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 跳表节点的结构定义</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    struct</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 节点存储的值</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 存储到下一个节点的指针数组，next[i] 表示当前节点在第 i 层的下一个节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 构造函数，初始化节点值和 next 数组</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">resize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> NULL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将 next 数组的大小初始化为 level，并全部指向 NULL</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 跳表的头节点，初始化时指向一个虚拟节点</span></span></code></pre></div><h3 id="find" tabindex="-1">find <a class="header-anchor" href="#find" aria-label="Permalink to &quot;find&quot;">​</a></h3><p>结合一个具体的例子讲解 <code>find</code> 函数，我们假设目标值 (<code>target</code>) 是 36。我们的目标是找到跳表中每个层级上小于 36 的最大节点。以下是跳表的当前状态和 <code>find</code> 函数的执行步骤。</p><p><strong>跳表当前状态:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 -------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p><strong>执行 <code>find(36, p)</code> 的步骤:</strong></p><ol><li><p><strong>开始于 Level 3</strong>:</p><ul><li>从 Head 开始，寻找小于 36 的最大节点。</li><li>移动到 33（因为 33 &lt; 36），然后移动到 55（因为 55 &gt; 36），停止。</li><li>在 Level 3，小于 36 的最大节点是 33。</li></ul></li><li><p><strong>下降至 Level 2</strong>:</p><ul><li>从 Level 3 中找到的最后一个节点（33）开始。</li><li>在 Level 2 中，33 已经是小于 36 的最大节点，因此无需移动。</li><li>在 Level 2，小于 36 的最大节点仍然是 33。</li></ul></li><li><p><strong>下降至 Level 1</strong>:</p><ul><li>从 Level 2 中找到的节点（33）开始。</li><li>33 后面是 37，但因为 37 &gt; 36，停止移动。</li><li>在 Level 1，小于 36 的最大节点是 33。</li></ul></li><li><p><strong>下降至 Level 0</strong>:</p><ul><li>从 Level 1 中找到的节点（33）开始。</li><li>33 后面是 35（35 &lt; 36），移动到 35。</li><li>35 后面是 37，但因为 37 &gt; 36，停止移动。</li><li>在 Level 0，小于 36 的最大节点是 35。</li></ul></li></ol><p><strong><code>find</code> 结果</strong>:</p><ul><li>Level 3 中小于 36 的最大节点是 33。</li><li>Level 2 中小于 36 的最大节点是 33。</li><li>Level 1 中小于 36 的最大节点是 33。</li><li>Level 0 中小于 36 的最大节点是 35。</li></ul><p>通过这个过程，<code>find</code> 函数有效地确定了在每个层级中小于目标值 36 的最大节点。这个信息可以用于后续的插入、搜索或删除操作，因为它提供了每个层级中开始这些操作的正确节点。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 辅助函数：找到小于目标值 target 的每一层的最大节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> vector</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> node </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">--</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                node </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在第 i 层向前移动，直到找到小于 target 的最大节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 存储每一层找到的节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre></div><h3 id="search" tabindex="-1">search <a class="header-anchor" href="#search" aria-label="Permalink to &quot;search&quot;">​</a></h3><p>为了说明如何在给定的跳表中查找值为 18 的节点。</p><p><strong>初始跳表状态:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 -------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p><strong>执行 <code>search(18)</code> 的步骤:</strong></p><ol><li><p><strong>开始于 Level 3</strong>:</p><ul><li>从 Head 开始，寻找小于 18 的最大节点。</li><li>移动到 11（因为 11 &lt; 18），然后到 33（因为 33 &gt; 18），停止。</li><li>在 Level 3，小于 18 的最大节点是 11。</li></ul></li><li><p><strong>下降至 Level 2</strong>:</p><ul><li>从 Level 3 中找到的最后一个节点（11）开始。</li><li>在 Level 2 中，11 后面是 22，但因为 22 &gt; 18，停止。</li><li>在 Level 2，小于 18 的最大节点是</li></ul></li></ol><p>11。</p><ol start="3"><li><p><strong>下降至 Level 1</strong>:</p><ul><li>从 Level 2 中找到的节点（11）开始。</li><li>11 后面是 15（15 &lt; 18），移动到 15。</li><li>15 后面是 22，但因为 22 &gt; 18，停止。</li><li>在 Level 1，小于 18 的最大节点是 15。</li></ul></li><li><p><strong>下降至 Level 0</strong>:</p><ul><li>从 Level 1 中找到的节点（15）开始。</li><li>15 后面是 18，我们找到了目标节点。</li><li>在 Level 0，找到了值为 18 的节点。</li></ul></li></ol><p><strong><code>search</code> 结果</strong>:</p><ul><li>在 Level 0 中找到了值为 18 的节点，所以 <code>search(18)</code> 返回 <code>true</code>。</li></ul><p>通过这个过程，<code>search</code> 函数在跳表的不同层级中高效地定位了值为 18 的节点。它首先在高层级中快速移动，快速跳过那些不满足条件的节点，然后逐层下降，直到在最底层找到了目标节点。通过这种方式，跳表提供了比普通链表更快的搜索性能。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 查找函数：判断跳表中是否存在值为 target 的节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    bool</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> search</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 target 的最大节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在最底层判断是否存在 target</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 如果存在且值相等，返回 true</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre></div><h3 id="add" tabindex="-1">add <a class="header-anchor" href="#add" aria-label="Permalink to &quot;add&quot;">​</a></h3><p>接下来结合具体的例子讲解如何在跳表中插入值为 36 的节点，我们将遵循 <code>add</code> 方法的步骤，并展示每个步骤如何在跳表的各层中影响链接。下面是跳表的当前状态，以及插入值为 36 的节点后的状态。</p><p><strong>当前跳表状态（插入值为 36 的节点前）:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 -------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p><strong>步骤 1: 查找前驱节点</strong></p><ul><li><code>find</code> 函数被调用以找到跳表中每个层级上小于 36 的最大节点。</li><li>例如，在 Level 1 中，值为 33 的节点是 36 的前驱节点。</li></ul><p><strong>步骤 2: 插入新节点</strong></p><ul><li>创建一个新节点 <code>p</code>，值为 36。</li><li>在每个层级中，将新节点插入到前驱节点之后。</li><li>随机决定新节点出现在哪些层级中。假设随机选择它只出现在 Level 0 和 Level 1。</li></ul><p><strong>插入后的跳表状态:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 ---------------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 ---------------------------&gt; 44 -------------------&gt; 55 --------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; [36] -&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 --------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; [36] -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 --&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p>在这个图形化的表示中：</p><ul><li><code>[36]</code> 表示新插入的节点，值为 36。</li><li>在 Level 1 中，新节点 <code>[36]</code> 被插入在值为 33 的节点和值为 37 的节点之间。即，<code>33 -&gt; [36] -&gt; 37</code>。</li><li>在 Level 0 中，同样的插入操作发生，将 <code>[36]</code> 插入在值为 35 和值为 37 的节点之间。</li><li>在更高层级（Level 2 和 Level 3），由于 <code>[36]</code> 没有被包含（基于随机选择），这些层级的链接保持不变。</li></ul><p>通过这种方式，值为 36 的节点被有效地插入到跳表中，并且跳表的结构被适当地更新以保持其快速搜索的特性。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 插入函数：向跳表中插入一个值为 num 的新节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 num 的最大节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 创建新节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> )</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 新节点的 next 指向前驱节点的 next</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 前驱节点的 next 指向新节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">rand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> %</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> break</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 有 50% 的概率停止向上层插入</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre></div><h3 id="erase" tabindex="-1">erase <a class="header-anchor" href="#erase" aria-label="Permalink to &quot;erase&quot;">​</a></h3><p>当我们以文本图形化的方式来讲解如何从跳表中删除一个值为 33 的节点时，我们会展示在各个层级中节点是如何被更新和移除的。以下是您提供的跳表示例，并标记了如何删除值为 33 的节点。</p><p>假设的跳表结构（删除值为 33 的节点前）:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------&gt; 33 ----------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------&gt; 33 -------------------&gt; 44 ----------------------&gt; 55 ----------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------&gt; 33 -------&gt; 37 -------&gt; 44 -------&gt; 48 (pre[1]) -&gt; 55 ---&gt; 59 --------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 33 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p><strong>删除步骤:</strong></p><ol><li><p><strong>查找前驱节点</strong>:</p><ul><li>使用 <code>find</code> 函数在每个层级找到值为 33 的节点的前驱节点。</li><li>在 Level 1 中，前驱节点是值为 27 的节点。</li><li>在 Level 2 中，前驱节点是值为 22 的节点。</li><li>在 Level 3 中，前驱节点是值为 11 的节点。</li></ul></li><li><p><strong>更新指针绕过值为 33 的节点</strong>:</p><ul><li>在每个层级，将前驱节点的 <code>next</code> 指针指向值为 33 的节点的下一个节点。</li><li>例如，在 Level 1，将值为 27 的节点的 <code>next</code> 指向值为 37 的节点。</li></ul></li></ol><p>跳表结构（删除值为 33 的节点后）:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span>Level 3:  Head -&gt; 11 -------------------------------------------------------------------------------------&gt; 55 -&gt; NULL</span></span>
<span class="line"><span>Level 2:  Head -&gt; 11 -------------------&gt; 22 -------------------------------------&gt; 44 -------------------&gt; 55 -------------------&gt; 66 -&gt; NULL</span></span>
<span class="line"><span>Level 1:  Head -&gt; 11 -------&gt; 15 -------&gt; 22 -------&gt; 27 -------------&gt; 37 -------&gt; 44 -------&gt; 48 -------&gt; 55 -------&gt; 59 -------&gt; 66 -------&gt; 72 -&gt; NULL</span></span>
<span class="line"><span>Level 0:  Head -&gt; 11 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 22 -&gt; 24 -&gt; 27 -&gt; 30 -&gt; 35 -&gt; 37 -&gt; 40 -&gt; 44 -&gt; 46 -&gt; 48 -&gt; 51 -&gt; 55 -&gt; 57 -&gt; 59 -&gt; 61 -&gt; 66 -&gt; 69 -&gt; 72 -&gt; 75 -&gt; NULL</span></span></code></pre></div><p>在上面的示例中，你可以看到：</p><ul><li>原本指向值为 33 的节点的指针现在直接指向了它在各个层级中的下一个节点。例如，原本在 Level 1 中，值为 27 的节点指向值为 33 的节点，现在直接指向值为 37 的节点。</li><li>这种指针的更新在所有包含值为 33 的节点的层级中发生。因此，在 Level 0 中，值为 30 的节点的 <code>next</code> 现在指向值为 35 的节点，绕过了值为 33 的节点。</li><li>通过这种方式，值为 33 的节点从跳表的所有层级中被移除，而不影响其他节点之间的链接关系。</li></ul><p>这就完成了删除操作。在物理层面上，值为 33 的节点将被释放，以回收内存空间。在逻辑层面上，该节点就像不存在一样，因为没有任何指针再指向它，它也不再指向其他节点。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 删除函数：从跳表中删除值为 num 的节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    bool</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> erase</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 num 的最大节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 检查最底层是否存在要删除的节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">p </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> !=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 如果不存在，返回 false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // 存在则从每一层中删除</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将前驱节点的 next 指向要删除节点的下一个节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        delete</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 释放被删除节点的内存</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre></div><h3 id="code" tabindex="-1">code <a class="header-anchor" href="#code" aria-label="Permalink to &quot;code&quot;">​</a></h3><p>下面是完整代码：</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Skiplist</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> const</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 定义跳表的最大层数为 8，这是一个经验值，太大会造成空间浪费</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 跳表节点的结构定义</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    struct</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 节点存储的值</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 存储到下一个节点的指针数组，next[i] 表示当前节点在第 i 层的下一个节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_val</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 构造函数，初始化节点值和 next 数组</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">resize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> NULL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将 next 数组的大小初始化为 level，并全部指向 NULL</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 跳表的头节点，初始化时指向一个虚拟节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 构造函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    Skiplist</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        head </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 初始化头节点，使用一个不存在的节点值（这里用 -1）</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 析构函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    ~Skiplist</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Node </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">current </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">current</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            Node </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">temp </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> current</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            current </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> current</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 遍历链表，释放每个节点的内存</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            delete</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> temp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 辅助函数：找到小于目标值 target 的每一层的最大节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> vector</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> node </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">--</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                node </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在第 i 层向前移动，直到找到小于 target 的最大节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 存储每一层找到的节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 查找函数：判断跳表中是否存在值为 target 的节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    bool</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> search</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 target 的最大节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在最底层判断是否存在 target</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 如果存在且值相等，返回 true</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 插入函数：向跳表中插入一个值为 num 的新节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 num 的最大节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 创建新节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> )</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 新节点的 next 指向前驱节点的 next</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 前驱节点的 next 指向新节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">rand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> %</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> break</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 有 50% 的概率停止向上层插入</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 删除函数：从跳表中删除值为 num 的节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    bool</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> erase</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Node</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">level</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        find</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 找到每一层小于 num 的最大节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 检查最底层是否存在要删除的节点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">p </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">val</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> !=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 如果不存在，返回 false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // 存在则从每一层中删除</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> level </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            pre</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将前驱节点的 next 指向要删除节点的下一个节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        delete</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 释放被删除节点的内存</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> * Skiplist 对象的实例化和使用：</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> * Skiplist* obj = new Skiplist();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> * bool param_1 = obj-&gt;search(target);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> * obj-&gt;add(num);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> * bool param_3 = obj-&gt;erase(num);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> */</span></span></code></pre></div>`,78),l=[h];function k(p,e,g,d,r,y){return a(),i("div",null,l)}const c=s(n,[["render",k]]);export{D as __pageData,c as default};
