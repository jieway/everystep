import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/rewrite-original.md","filePath":"cpp/basic/rewrite-original.md"}'),l={name:"cpp/basic/rewrite-original.md"},h=n(`<p>了解C++的重载（Overloading）和重写（Overriding）的实现原理，需要深入到编译器如何处理这两种情况的细节。</p><h3 id="重载-overloading-的实现原理" tabindex="-1">重载（Overloading）的实现原理 <a class="header-anchor" href="#重载-overloading-的实现原理" aria-label="Permalink to &quot;重载（Overloading）的实现原理&quot;">​</a></h3><p>当你在C++中进行函数重载时，编译器在内部进行了一些工作以区分这些重载的函数。即使函数名相同，编译器也能根据参数列表的不同来区分它们。</p><p><strong>命名倾轧（Name Mangling）：</strong></p><ul><li>编译器在内部将每个函数的名称转换成一个独一无二的标识符。这通常涉及到函数名称和其参数类型的组合。</li><li>命名倾轧确保了即使在同一个作用域内存在同名的重载函数，每个函数也有一个唯一的标识。</li></ul><p><strong>例子：</strong></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* ... */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">double</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* ... */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span></code></pre></div><p>在这个例子中，虽然两个函数都叫<code>func</code>，但是编译器可能会将它们改编为内部名称，比如<code>func_int</code>和<code>func_double</code>。</p><h3 id="重写-overriding-的实现原理" tabindex="-1">重写（Overriding）的实现原理 <a class="header-anchor" href="#重写-overriding-的实现原理" aria-label="Permalink to &quot;重写（Overriding）的实现原理&quot;">​</a></h3><p>重写涉及到虚函数和动态绑定。当派生类重写基类中的虚函数时，C++通过虚函数表（vtable）来支持运行时多态。</p><p><strong>虚函数表（vtable）：</strong></p><ul><li>每个使用虚函数的类都有一个相应的虚函数表。这个表是一个指针数组，指向类的虚函数。</li><li>每个对象包含一个指针（通常称为vptr），指向其类的虚函数表。</li><li>当调用虚函数时，实际的函数调用是通过vptr和vtable在运行时解析的。</li></ul><p><strong>例子：</strong></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Base</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Base func</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\n</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Derived</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Base</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Derived func</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\n</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Base</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> obj </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Derived</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">obj</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 运行时解析为 Derived::func</span></span></code></pre></div><p>在这个例子中，虽然<code>obj</code>的类型是指向<code>Base</code>的指针，但是调用<code>func</code>时，通过虚函数表解析到了<code>Derived</code>中的<code>func</code>实现。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ul><li><strong>重载</strong>：通过命名倾轧（Name Mangling）在编译阶段处理，编译器根据参数类型和数量创建不同的内部名称。</li><li><strong>重写</strong>：通过虚函数表（vtable）在运行阶段处理，支持动态绑定和运行时多态。</li></ul><p>这两种机制都是C++编译器的核心部分，它们使得C++在支持复杂的面向对象编程时保持高效和灵活。</p>`,18),t=[h];function k(p,e,r,d,g,o){return a(),i("div",null,t)}const A=s(l,[["render",k]]);export{y as __pageData,A as default};
