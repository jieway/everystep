import{_ as o,c as a,o as r,R as e}from"./chunks/framework.2bglP9T5.js";const _=JSON.parse('{"title":"Hash","description":"","frontmatter":{},"headers":[],"relativePath":"aryadb/5-hash.md","filePath":"aryadb/5-hash.md"}'),l={name:"aryadb/5-hash.md"},i=e('<h1 id="hash" tabindex="-1">Hash <a class="header-anchor" href="#hash" aria-label="Permalink to &quot;Hash&quot;">​</a></h1><p>这一章主要研究 <code>util/hash.cc</code> 和 <code>util/hash.h</code> 。</p><p>hash 又用到了 <code>util/coding.cc</code> 和 <code>util/coding.h</code></p><h2 id="_1-coding" tabindex="-1">1. Coding <a class="header-anchor" href="#_1-coding" aria-label="Permalink to &quot;1. Coding&quot;">​</a></h2><p><code>util/coding.cc</code> 和 <code>util/coding.h</code> 提供了一套用于数据编码和解码的功能，特别是针对固定长度和可变长度整数以及字符串数据。它主要实现了：</p><ol><li><p><strong>固定长度整数的编码与解码</strong>：使用小端字节序编码 <code>uint32_t</code> 和 <code>uint64_t</code> 类型的整数，并提供相应的解码功能。</p></li><li><p><strong>可变长度整数（varint）的编码与解码</strong>：对 <code>uint32_t</code> 和 <code>uint64_t</code> 类型的整数进行可变长度编码，称为 varint 编码，同时提供解码这些编码的功能。</p></li><li><p><strong>字符串的长度前缀编码</strong>：将字符串前缀为其长度（使用 varint 编码），然后是字符串本身，提供解析这种格式的字符串的功能。</p></li></ol><p>总的来说，这段代码是一个用于处理不同类型数据（特别是整数和字符串）的端序中立编码和解码库，适用于需要高效存储和传输数据的场景。</p><p>这部分代码比较底层，没有太多可以修改的地方，先略过。</p><h2 id="_2-hash" tabindex="-1">2. Hash <a class="header-anchor" href="#_2-hash" aria-label="Permalink to &quot;2. Hash&quot;">​</a></h2><p>下面研究 <code>util/hash.cc</code> ，这里面是一个 hash 函数。</p><p>Leveldb 的 布隆过滤器中的 Hash 函数采用了一个类似 MurmurHash。MurmurHash是一种非加密型哈希函数，适用于一般的哈希检索操作。这个名称“Murmur”来源于两个基本操作，即乘法（multiply）和旋转（rotate），这是这个算法的关键部分。MurmurHash以其高效性和产生较少哈希碰撞的能力而闻名。它不适用于加密，因为它不是为安全性设计的，而是为速度和效率设计的。</p><p>MurmurHash 的几个关键特点包括：</p><ol><li><p><strong>性能高效</strong>：MurmurHash被设计成在处理大量数据时保持高效和快速。它的算法结构确保了即使是大量的数据也能快速处理。</p></li><li><p><strong>分布均匀</strong>：MurmurHash能生成的哈希值分布非常均匀，这减少了哈希碰撞的可能性，即不同的输入产生相同哈希值的情况。</p></li><li><p><strong>不同版本</strong>：MurmurHash有几个不同的版本，如MurmurHash1、MurmurHash2、MurmurHash3等。每个版本在效率和分布特性方面都有所不同。</p></li><li><p><strong>平台独立</strong>：MurmurHash算法在不同的硬件和操作系统上都能保持一致的性能和结果。</p></li><li><p><strong>非加密用途</strong>：重要的是要记住，MurmurHash不适合用于任何需要加密的场合。它的设计重点是速度和效率，而不是防止逆向工程或抵抗哈希碰撞攻击。</p></li></ol><p>MurmurHash常用于数据存储和处理领域，如哈希表的键值映射、数据分片、负载均衡等。由于其高效的性能特点，它在需要快速哈希运算的场景中非常受欢迎。</p><h3 id="murmurhash-的处理步骤" tabindex="-1">MurmurHash 的处理步骤 <a class="header-anchor" href="#murmurhash-的处理步骤" aria-label="Permalink to &quot;MurmurHash 的处理步骤&quot;">​</a></h3><p>Leveldb 的 MurmurHash 的处理步骤可以简要概述如下：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>使用异或操作将初始种子与数据总大小乘以常数 <code>m</code> 结合起来。</li></ul></li><li><p><strong>处理四字节块</strong>：</p><ul><li>当数据长度足够（剩余至少4字节）时，按4字节为一组处理数据。</li><li>对每4字节： <ul><li>读取4字节数据，并将其加到哈希值 <code>h</code> 上。</li><li>将哈希值 <code>h</code> 乘以常数 <code>m</code>。</li><li>将哈希值 <code>h</code> 右移16位后与自身进行异或操作。</li></ul></li></ul></li><li><p><strong>处理剩余字节</strong>：</p><ul><li>根据剩余字节数（0到3字节），处理每个剩余字节： <ul><li>如果剩余3字节，则将第三个字节左移16位后加到哈希值 <code>h</code> 上。</li><li>如果剩余至少2字节，则将第二个字节左移8位后加到哈希值 <code>h</code> 上。</li><li>如果剩余至少1字节，则将第一个字节直接加到哈希值 <code>h</code> 上。</li></ul></li><li>在处理完剩余字节后，将哈希值 <code>h</code> 乘以常数 <code>m</code>，然后将哈希值 <code>h</code> 右移 <code>r</code>（24位）位后与自身进行异或操作。</li></ul></li><li><p><strong>返回最终哈希值</strong>：</p><ul><li>返回处理完成后的哈希值 <code>h</code>。</li></ul></li></ol>',17),t=[i];function s(c,h,d,u,n,p){return r(),a("div",null,t)}const g=o(l,[["render",s]]);export{_ as __pageData,g as default};
