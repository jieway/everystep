import{_ as s,c as a,o as i,R as l}from"./chunks/framework.2bglP9T5.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/dafult-class.md","filePath":"cpp/basic/dafult-class.md"}'),n={name:"cpp/basic/dafult-class.md"},p=l(`<p>在C++中，如果你显式地定义了某些特殊成员函数，比如移动构造函数，编译器对于其他特殊成员函数的自动生成行为会受到影响。这种行为遵循所谓的“复制/移动构造函数和赋值运算符的规则”，这些规则在C++11标准中被明确。下面是一些基本的准则：</p><ol><li><p><strong>如果你显式定义了移动构造函数或移动赋值运算符</strong>：</p><ul><li>编译器将不会自动生成拷贝构造函数和拷贝赋值运算符。</li><li>默认构造函数仍然会被自动生成（除非有其他原因导致不生成）。</li></ul></li><li><p><strong>如果你显式定义了拷贝构造函数或拷贝赋值运算符</strong>：</p><ul><li>编译器将不会自动生成移动构造函数和移动赋值运算符。</li><li>默认构造函数仍然会被自动生成（除非有其他原因导致不生成）。</li></ul></li><li><p><strong>如果你显式定义了析构函数</strong>：</p><ul><li>在C++11之前，这不会影响拷贝构造函数和拷贝赋值运算符的自动生成。</li><li>在C++11及以后，编译器仍然会自动生成移动构造函数和移动赋值运算符，但这种行为可能会被抑制，特别是如果你也定义了拷贝构造函数或拷贝赋值运算符。</li></ul></li></ol><h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> MyClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 显式定义移动构造函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    MyClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">MyClass</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ... </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 拷贝构造函数和拷贝赋值运算符不会自动生成</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // MyClass(const MyClass&amp;) = default; // 如果需要，可以显式要求编译器生成</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // MyClass&amp; operator=(const MyClass&amp;) = default;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 默认构造函数仍然会自动生成</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> AnotherClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 显式定义析构函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    ~AnotherClass</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ... </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 在C++11及以后，以下成员可能不会自动生成</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // AnotherClass(AnotherClass&amp;&amp;) = default;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // AnotherClass&amp; operator=(AnotherClass&amp;&amp;) = default;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 拷贝构造函数和拷贝赋值运算符仍然会自动生成</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre></div><h3 id="小贴士" tabindex="-1">小贴士 <a class="header-anchor" href="#小贴士" aria-label="Permalink to &quot;小贴士&quot;">​</a></h3><ul><li>如果你需要某个</li></ul><p>特殊成员函数（比如拷贝构造函数）被自动生成，但是由于你已经定义了其他成员函数（比如析构函数），导致它不会被自动生成，你可以使用<code>= default</code>来明确指示编译器为你生成这个函数。</p><ul><li><p>当显式定义了移动构造函数或移动赋值运算符时，通常也意味着你需要处理类中的资源管理（比如动态内存分配）。在这种情况下，通常也需要显式定义拷贝构造函数和拷贝赋值运算符，以正确处理资源的拷贝行为。</p></li><li><p>遵循“三/五法则”：如果你定义了移动构造函数或移动赋值运算符中的任何一个（五法则），你通常也应该定义所有五个特殊成员函数（默认构造函数、析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符）。在C++11之前，这被称为“三法则”，涉及默认构造函数、析构函数、拷贝构造函数和拷贝赋值运算符。</p></li></ul><p>通过理解这些规则，你可以更好地控制类的行为，特别是在涉及对象生命周期管理和资源控制时。</p>`,9),t=[p];function h(e,k,r,d,c,o){return i(),a("div",null,t)}const y=s(n,[["render",h]]);export{g as __pageData,y as default};
