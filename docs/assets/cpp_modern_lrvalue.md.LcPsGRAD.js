import{_ as s,c as i,o as a,R as l}from"./chunks/framework.2bglP9T5.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/modern/lrvalue.md","filePath":"cpp/modern/lrvalue.md"}'),e={name:"cpp/modern/lrvalue.md"},t=l(`<p>在C++中，理解左值（lvalue）和右值（rvalue）是非常重要的，尤其是在涉及到资源管理、移动语义和优化方面。左值和右值是表达式的两种主要类别，它们分别代表了不同的对象类型和存储期限。</p><h3 id="左值-lvalue" tabindex="-1">左值（Lvalue） <a class="header-anchor" href="#左值-lvalue" aria-label="Permalink to &quot;左值（Lvalue）&quot;">​</a></h3><ul><li><strong>定义</strong>：左值是指那些地址可确定并可以持续存在的对象。它们通常可以位于赋值表达式的左侧（因此得名“左值”）。</li><li><strong>特点</strong>：左值有持久的存储地址。它们可以是变量、数组的元素、引用、解引用指针等。</li><li><strong>应用场景</strong>：当你需要一个可以持续存在并可以通过地址访问的对象时，你会使用左值。</li></ul><h4 id="示例-左值" tabindex="-1">示例：左值 <a class="header-anchor" href="#示例-左值" aria-label="Permalink to &quot;示例：左值&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // a 是左值</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ref </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ref 是对左值的引用</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ref </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 正确：左值引用可以被赋值</span></span></code></pre></div><p>在这个例子中，<code>a</code> 是一个左值，因为它有一个确定的地址并且它的值可以改变。<code>ref</code> 是一个左值引用，它引用了左值 <code>a</code>。</p><h3 id="右值-rvalue" tabindex="-1">右值（Rvalue） <a class="header-anchor" href="#右值-rvalue" aria-label="Permalink to &quot;右值（Rvalue）&quot;">​</a></h3><ul><li><strong>定义</strong>：右值是指那些不具有持久存储地址的临时对象或字面量。通常它们只能位于赋值表达式的右侧。</li><li><strong>特点</strong>：右值是临时的，不可以通过地址访问。它们可以是字面量、函数返回的临时对象、表达式的结果等。</li><li><strong>应用场景</strong>：当你需要使用临时对象或值时，你会使用右值。在C++11中，右值引用和移动语义是右值的重要应用，它们允许更有效的资源管理。</li></ul><h4 id="示例-右值" tabindex="-1">示例：右值 <a class="header-anchor" href="#示例-右值" aria-label="Permalink to &quot;示例：右值&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> b </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // a + 2 是右值</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int&amp;&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> rvalueRef </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 右值引用</span></span></code></pre></div><p>这里，<code>a + 2</code> 是一个右值，因为它是一个临时结果，没有固定的存储地址。<code>rvalueRef</code> 是一个右值引用，它引用了右值 <code>a + 2</code>。</p><h3 id="右值引用和移动语义" tabindex="-1">右值引用和移动语义 <a class="header-anchor" href="#右值引用和移动语义" aria-label="Permalink to &quot;右值引用和移动语义&quot;">​</a></h3><p>在C++11中引入了右值引用（使用 <code>&amp;&amp;</code> 表示），它是移动语义的基础。移动语义允许资源（如动态分配的内存）从一个对象转移到另一个对象，这可以大大提高性能，特别是对于大型对象。</p><h4 id="示例-移动语义" tabindex="-1">示例：移动语义 <a class="header-anchor" href="#示例-移动语义" aria-label="Permalink to &quot;示例：移动语义&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">vector</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">iostream</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> process</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">vector</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> vec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;int&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> localVec </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">move</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 使用移动语义</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 进行处理</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    process</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vector</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;int&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">}</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 临时对象作为右值</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在这个例子中，我们创建了一个临时的 <code>std::vector</code> 对象，并将其作为右值传递给 <code>process</code> 函数。通过使用 <code>std::move</code>，我们可以有效地将资源从右值（临时对象）移动到 <code>localVec</code>，而不是进行成本较高的复制操作。</p><h3 id="如何判断左值右值" tabindex="-1">如何判断左值右值？ <a class="header-anchor" href="#如何判断左值右值" aria-label="Permalink to &quot;如何判断左值右值？&quot;">​</a></h3><p>在C++中，判断一个表达式是左值（lvalue）还是右值（rvalue）通常依据表达式的特性和行为。以下是一些基本的准则和示例来帮助你判断：</p><h4 id="左值-lvalue-1" tabindex="-1">左值（Lvalue） <a class="header-anchor" href="#左值-lvalue-1" aria-label="Permalink to &quot;左值（Lvalue）&quot;">​</a></h4><ol><li><strong>标识符</strong>：变量名、函数名、数组名通常都是左值。 <ul><li>示例：<code>int a;</code>（<code>a</code> 是左值）</li></ul></li><li><strong>引用</strong>：对左值的引用（包括普通引用和左值引用）也是左值。 <ul><li>示例：<code>int&amp; ref = a;</code>（<code>ref</code> 是左值）</li></ul></li><li><strong>可取地址</strong>：如果你可以对表达式使用 <code>&amp;</code> 运算符取地址，那么它通常是左值。 <ul><li>示例：<code>&amp;a</code>（<code>a</code> 是左值，因为你可以取得它的地址）</li></ul></li><li><strong>持久存储</strong>：分配了持久存储空间的对象是左值。 <ul><li>示例：局部变量、全局变量</li></ul></li></ol><h4 id="右值-rvalue-1" tabindex="-1">右值（Rvalue） <a class="header-anchor" href="#右值-rvalue-1" aria-label="Permalink to &quot;右值（Rvalue）&quot;">​</a></h4><ol><li><strong>临时对象</strong>：在表达式中创建的临时对象是右值。 <ul><li>示例：<code>std::string(&quot;hello&quot;)</code>（一个临时字符串对象）</li></ul></li><li><strong>字面量</strong>：除了字符串字面量之外的所有字面量都是右值。 <ul><li>示例：<code>42</code>、<code>3.14</code>、<code>true</code></li></ul></li><li><strong>返回临时对象的表达式</strong>：函数返回非引用类型或表达式的结果是右值。 <ul><li>示例：<code>int sum() { return a + b; }</code>（<code>sum()</code> 返回一个右值）</li></ul></li><li><strong>右值引用</strong>：对右值的引用（<code>&amp;&amp;</code>）是右值。 <ul><li>示例：<code>int&amp;&amp; rvalueRef = 5;</code>（<code>5</code> 是右值）</li></ul></li></ol><h4 id="右值引用和std-move" tabindex="-1">右值引用和<code>std::move</code> <a class="header-anchor" href="#右值引用和std-move" aria-label="Permalink to &quot;右值引用和\`std::move\`&quot;">​</a></h4><ul><li><code>std::move</code> 可以将左值显式转换为右值引用，这常用于移动语义和强制调用接受右值引用的重载函数。 <ul><li>示例：<code>std::vector&lt;int&gt; vec; auto newVec = std::move(vec);</code>（<code>std::move(vec)</code> 是右值）</li></ul></li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>左值</strong>：如果它代表一个具体的、可寻址的、持久的对象，它是左值。</li><li><strong>右值</strong>：如果它代表一个临时的、不可寻址的值或对象，它是右值。</li></ul><p>在实际编码中，这种区分通常与函数重载（特别是对左值引用和右值引用的重载）和优化（如移动语义）相关。通过理解和正确使用左值和右值，你可以更有效地编写C++代码，特别是在涉及资源管理和性能优化的场景中。</p><p>左值和右值在C++中代表了不同类型的对象和表达式。左值具有持久的地址，而右值是临时的、不可地址化的。理解这两者的区别对于高效地使用C++的现代特性（如移动语义和右值引用）是非常重要的。</p>`,28),h=[t];function n(k,p,d,r,o,c){return a(),i("div",null,h)}const y=s(e,[["render",n]]);export{A as __pageData,y as default};
