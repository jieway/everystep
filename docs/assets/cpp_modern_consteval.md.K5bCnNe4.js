import{_ as s,c as i,o as a,R as n}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"C++ 20 consteval 的作用？","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/modern/consteval.md","filePath":"cpp/modern/consteval.md"}'),e={name:"cpp/modern/consteval.md"},t=n(`<h1 id="c-20-consteval-的作用" tabindex="-1">C++ 20 consteval 的作用？ <a class="header-anchor" href="#c-20-consteval-的作用" aria-label="Permalink to &quot;C++ 20 consteval 的作用？&quot;">​</a></h1><p>讲 <code>consteval</code> 之前要先讲解 <code>constexpr</code> ，<code>constexpr</code> 是 C++11 引入的一个关键字，用于定义常量表达式。<code>constexpr</code> 的主要作用是指示编译器在编译时计算表达式的值，从而使得该值在编译时就已经确定。使用 <code>constexpr</code> 可以创建编译时的常量，还可以定义能够在编译时计算结果的函数。</p><h3 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h3><ol><li><p><strong>编译时常量</strong>：使用 <code>constexpr</code> 定义的变量必须在编译时就能确定其值。</p></li><li><p><strong>编译时函数求值</strong>：<code>constexpr</code> 函数能够在编译时进行计算，只要其所有参数都是编译时常量。</p></li><li><p><strong>模板和类型安全</strong>：<code>constexpr</code> 在模板编程和元编程中非常有用，它确保了类型安全，并能在编译时进行复杂的计算。</p></li><li><p><strong>性能优化</strong>：<code>constexpr</code> 可以减少运行时的计算，因为相关计算已经在编译时完成。</p></li></ol><h3 id="编译时常量" tabindex="-1">编译时常量 <a class="header-anchor" href="#编译时常量" aria-label="Permalink to &quot;编译时常量&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> max_size </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 编译时常量</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> array</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">max_size</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">           // 使用常量定义数组大小</span></span></code></pre></div><p>这里，<code>max_size</code> 是一个编译时常量，可以用作数组的大小，这是因为其值在编译时就已经确定了。</p><h3 id="编译时函数" tabindex="-1">编译时函数 <a class="header-anchor" href="#编译时函数" aria-label="Permalink to &quot;编译时函数&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ?</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> :</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> fac_5 </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 编译时计算 5 的阶乘</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> array</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">fac_5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                  // 使用结果作为数组大小</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>这个示例中的 <code>factorial</code> 函数是一个 <code>constexpr</code> 函数，能够在编译时计算阶乘。因此，<code>fac_5</code> 是一个编译时常量，其值为 <code>5!</code>（即 120），可以用于定义数组的大小。</p><h3 id="constexpr-总结" tabindex="-1">constexpr 总结 <a class="header-anchor" href="#constexpr-总结" aria-label="Permalink to &quot;constexpr 总结&quot;">​</a></h3><p><code>constexpr</code> 是 C++ 中的一个强大特性，允许在编译时进行计算，从而提供性能优化和类型安全。它对于编写高效、类型安全的模板代码尤为重要。通过在编译时执行更多的计算，<code>constexpr</code> 可以减少运行时的负担，使得程序更加高效。</p><p>要判断一个表达式是否能在编译时计算，关键在于检查其是否完全由常量、常量表达式、constexpr 变量/函数构成，并且其操作符也支持在编译时求值。编译器的具体实现和优化策略也会影响是否能在编译时计算表达式。</p><h2 id="consteval-的作用-和-constexpr-的区别" tabindex="-1">consteval 的作用，和 constexpr 的区别？ <a class="header-anchor" href="#consteval-的作用-和-constexpr-的区别" aria-label="Permalink to &quot;consteval 的作用，和 constexpr 的区别？&quot;">​</a></h2><p><code>consteval</code> 和 <code>constexpr</code> 都是 C++ 中用于编译时计算的关键字，但它们有一些重要的区别。</p><h3 id="consteval" tabindex="-1">consteval <a class="header-anchor" href="#consteval" aria-label="Permalink to &quot;consteval&quot;">​</a></h3><ol><li><strong>引入时间</strong>: <code>consteval</code> 是在 C++20 引入的。</li><li><strong>含义</strong>: <code>consteval</code> 指定的函数必须在编译时进行求值。</li><li><strong>限制</strong>: 如果一个 <code>consteval</code> 函数在编译时不能被求值，那么会产生一个编译错误。</li><li><strong>用途</strong>: <code>consteval</code> 用于创建那些一定需要在编译时求值的函数，比如用于元编程或者生成编译时常量。</li></ol><h3 id="constexpr" tabindex="-1">constexpr <a class="header-anchor" href="#constexpr" aria-label="Permalink to &quot;constexpr&quot;">​</a></h3><ol><li><strong>引入时间</strong>: <code>constexpr</code> 是在 C++11 引入的，后续的标准中进行了扩展。</li><li><strong>含义</strong>: <code>constexpr</code> 指示一个函数或对象可能在编译时求值。</li><li><strong>灵活性</strong>: <code>constexpr</code> 函数或对象可以在编译时也可以在运行时求值。如果编译器能够在编译时求值，它通常会这样做；否则，该函数或对象就会在运行时求值。</li><li><strong>用途</strong>: <code>constexpr</code> 用于创建可以在编译时或运行时求值的函数或对象，提供了更大的灵活性。</li></ol><h3 id="区别总结" tabindex="-1">区别总结 <a class="header-anchor" href="#区别总结" aria-label="Permalink to &quot;区别总结&quot;">​</a></h3><ul><li><strong>编译时求值的强制性</strong>: <code>consteval</code> 强制其函数在编译时求值，而 <code>constexpr</code> 则不强制。</li><li><strong>应用场景</strong>: <code>consteval</code> 用于那些必须在编译时求值的场景，而 <code>constexpr</code> 更适用于那些编译时求值能带来性能优化但非必需的情况。</li><li><strong>错误处理</strong>: 如果 <code>consteval</code> 函数不能在编译时求值，将导致编译错误；而 <code>constexpr</code> 函数则会退化为普通函数，在运行时求值。</li></ul><p>简而言之，<code>consteval</code> 保证了函数必定在编译时求值，而 <code>constexpr</code> 提供了在编译时求值的可能性，但并非强制性的。</p><h2 id="如何区分在编译期求值还是在运行期求值" tabindex="-1">如何区分在编译期求值还是在运行期求值？ <a class="header-anchor" href="#如何区分在编译期求值还是在运行期求值" aria-label="Permalink to &quot;如何区分在编译期求值还是在运行期求值？&quot;">​</a></h2><p>要理解 <code>constexpr</code> 和 <code>consteval</code> 的区别，关键在于区分哪些情况下一个表达式或函数是在编译期能确定的（即完全由编译时常量和操作组成），以及哪些情况下需要到运行期才能确定。以下是一些例子，帮助区分这两种情况：</p><h3 id="例子-1-纯编译期计算" tabindex="-1">例子 1: 纯编译期计算 <a class="header-anchor" href="#例子-1-纯编译期计算" aria-label="Permalink to &quot;例子 1: 纯编译期计算&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">consteval</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> compileTimeResult </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确: 编译期可以计算</span></span></code></pre></div><p>在这里，<code>Square</code> 是 <code>consteval</code> 函数，必须在编译期计算。传递给 <code>Square</code> 函数的参数 <code>4</code> 是一个编译期常量，因此整个表达式可以在编译期计算。</p><h3 id="例子-2-运行期输入" tabindex="-1">例子 2: 运行期输入 <a class="header-anchor" href="#例子-2-运行期输入" aria-label="Permalink to &quot;例子 2: 运行期输入&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> runtimeValue </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> runtimeResult </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">runtimeValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确: 运行期计算</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>此处 <code>Square</code> 是 <code>constexpr</code> 函数，它可以在编译期或运行期计算。<code>runtimeValue</code> 是一个运行期变量，因此 <code>Square(runtimeValue)</code> 必须在运行期计算。</p><h3 id="例子-3-编译期和运行期混合" tabindex="-1">例子 3: 编译期和运行期混合 <a class="header-anchor" href="#例子-3-编译期和运行期混合" aria-label="Permalink to &quot;例子 3: 编译期和运行期混合&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> compileTimeResult </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确: 编译期计算</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> runtimeValue </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    constexpr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> compileTimeResult2 </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Square</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">runtimeValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 错误: 尝试在编译期计算运行期变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在 <code>main</code> 函数中，尝试将运行期变量 <code>runtimeValue</code> 传递给 <code>constexpr</code> 函数并期望其在编译期计算，这是不允许的，因为 <code>runtimeValue</code> 的值只有在运行期才确定。</p><h3 id="例子-4-consteval-强制编译期计算" tabindex="-1">例子 4: <code>consteval</code> 强制编译期计算 <a class="header-anchor" href="#例子-4-consteval-强制编译期计算" aria-label="Permalink to &quot;例子 4: \`consteval\` 强制编译期计算&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">consteval</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> x </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> result </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">x</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 20</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 错误: \`consteval\` 函数不能使用运行期变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在这个例子中，尽管 <code>20</code> 是编译期常量，<code>x</code> 是运行期变量。因为 <code>Add</code> 是 <code>consteval</code> 函数，它不能接受运行期变量作为参数。</p><ul><li>代码中的 <code>x</code> 赋值为 <code>10</code> 看似是一个常量，但它仍然被视为运行期变量。为什么？</li></ul><p>在 C++ 中，即使变量 <code>x</code> 在代码中被赋予了一个字面值（例如 <code>10</code>），它仍然被视为运行期变量。这是因为：</p><ol><li><p><strong>编译器视角</strong>：尽管 <code>x</code> 被赋予了一个固定的值，但从编译器的角度来看，它是一个普通变量，其值可以在程序运行时更改。编译器在处理 <code>x</code> 时，并不会将其视为一个编译期常量。</p></li><li><p><strong>变量存储</strong>：<code>x</code> 被存储在程序的栈上或其他非静态存储区域，这意味着它在程序执行时才被分配和初始化。即便它的初始值是常量，它的存储和生命周期特性使得它是一个运行期变量。</p></li><li><p><strong>常量与变量的区别</strong>：在 C++ 中，<code>const</code> 关键字用于定义常量，而非 <code>const</code> 的普通变量即使被赋予常量值也仍被视为变量。例如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> constValue </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 编译期常量</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> x </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                 // 运行期变量</span></span></code></pre></div><p>在这个例子中，<code>constValue</code> 是一个编译期常量，而 <code>x</code> 是一个运行期变量，尽管它们都被赋予了同样的值。</p></li><li><p><strong><code>consteval</code> 的要求</strong>：<code>consteval</code> 函数要求所有参数必须是字面量或编译期常量。即使 <code>x</code> 被赋予了一个常量值，它在定义时并没有被标记为 <code>constexpr</code> 或 <code>const</code>，因此不能满足 <code>consteval</code> 函数的要求。</p></li></ol><p>因此，即使 <code>x</code> 的值在某种意义上是“已知的”，在 C++ 的类型系统和编译器规则下，它仍然是一个运行期变量。</p><ul><li><p>在 <code>consteval</code> 函数中，所有的参数必须是编译期常量，即它们的值必须在编译时就已经完全确定，不仅仅是赋值为常量。换句话说，即使 <code>x</code> 被赋予了一个字面量（如 <code>10</code>），在编译器看来，它仍然是一个普通的运行期变量，因为它有可能在程序运行时被改变。</p></li><li><p>对于 <code>constexpr</code> 函数，如果所有的参数在编译时都是常量，那么函数可以在编译时执行。但如果参数中包含运行时才能确定的变量，函数调用就会被推迟到运行时。</p></li></ul><p>上述例子中，即使 <code>x</code> 的值被设置为 <code>10</code>，它仍然是在运行时被分配和初始化的。因此，尽管其赋值看起来像常量，它在 <code>consteval</code> 函数中的使用仍然是非法的，因为 <code>consteval</code> 要求所有输入必须是编译时常量。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><code>constexpr</code> 允许函数或对象在编译期或运行期求值。如果所有输入都是编译期常量，<code>constexpr</code> 函数会在编译期求值。</li><li><code>consteval</code> 强制函数必须在编译期求值。任何包含运行期变量的 <code>consteval</code> 函数调用都会导致编译错误。</li><li>识别一个表达式是编译期还是运行期可以确定，关键在于它的所有组成部分（包括参数和操作符）是否都是编译期常量。</li></ul>`,44),h=[t];function l(p,k,d,r,o,c){return a(),i("div",null,h)}const A=s(e,[["render",l]]);export{y as __pageData,A as default};
