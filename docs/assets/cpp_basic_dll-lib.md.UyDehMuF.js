import{_ as i,c as l,o as s,R as e}from"./chunks/framework.2bglP9T5.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/basic/dll-lib.md","filePath":"cpp/basic/dll-lib.md"}'),a={name:"cpp/basic/dll-lib.md"},o=e('<p>动态链接库（DLL，Dynamic Link Library）和静态链接库（通常为 .lib 或 .a 文件）是两种不同类型的代码库，它们在程序编译和运行时的行为上有着显著的区别：</p><ol><li><p><strong>链接时机</strong>：</p><ul><li><strong>动态链接库</strong>：在程序运行时被加载和链接。这意味着程序在编译时并不包含这些库的代码，而是在运行时从外部文件中加载。</li><li><strong>静态链接库</strong>：在程序编译时就被完全集成到程序中。静态库的代码在编译时被复制到最终的可执行文件中。</li></ul></li><li><p><strong>文件大小和内存占用</strong>：</p><ul><li>使用<strong>动态链接库</strong>的程序通常具有更小的文件大小，因为库代码不包含在可执行文件中。但如果多个程序使用相同的库，这些程序可以共享内存中的同一份库副本，从而减少总体内存占用。</li><li><strong>静态链接库</strong>会增加最终可执行文件的大小，因为每一个使用该库的程序都包含了一份完整的库代码副本。这可能导致更高的磁盘空间和内存占用，尤其是在多个程序使用相同库的情况下。</li></ul></li><li><p><strong>部署和更新</strong>：</p><ul><li><strong>动态链接库</strong>使得部署和更新变得更加简单。当库需要更新时，只需替换掉系统中的DLL文件，而不需要重新编译使用该库的每个程序。</li><li><strong>静态链接库</strong>中的代码更新需要重新编译所有使用该库的程序。</li></ul></li><li><p><strong>兼容性和依赖问题</strong>：</p><ul><li><strong>动态链接库</strong>可能导致所谓的“DLL地狱”，即版本冲突和缺失问题，因为不同的程序可能依赖于同一DLL的不同版本。</li><li><strong>静态链接库</strong>由于是编译到程序中的，不会有版本冲突的问题，但这也意味着更新库版本需要重新编译程序。</li></ul></li><li><p><strong>平台和语言限制</strong>：</p><ul><li><strong>动态链接库</strong>在不同的操作系统平台（如Windows的DLL和Linux的SO文件）和不同的编程语言间可能存在兼容性问题。</li><li><strong>静态链接库</strong>通常与特定的编译器和平台紧密相关，可能在跨平台时遇到限制。</li></ul></li></ol><p>根据具体的应用场景和需求，开发者会选择使用动态链接库或静态链接库。动态链接库更适用于需要频繁更新或者多个程序共享代码的情况，而静态链接库更适用于小型、独立的应用程序，或者对性能有特别要求的场合。</p><h2 id="静态库-a-和动态库-so-的不同" tabindex="-1">静态库 <code>.a</code> 和动态库 <code>.so</code> 的不同 <a class="header-anchor" href="#静态库-a-和动态库-so-的不同" aria-label="Permalink to &quot;静态库 `.a` 和动态库 `.so` 的不同&quot;">​</a></h2><p><code>.a</code> 和 <code>.so</code> 文件分别是在 Unix-like 系统（如 Linux）上常见的静态库和动态库的格式。它们在功能、使用方式和效果上有一些关键区别：</p><ol><li><p><strong>文件类型</strong>：</p><ul><li><code>.a</code> 文件是静态库（Static Library）的文件格式。这种格式的文件包含了一系列已编译的对象代码，这些代码在程序编译时会被完整地复制到最终的可执行文件中。</li><li><code>.so</code> 文件是动态链接共享库（Shared Object）的文件格式，类似于 Windows 上的 DLL。这些文件包含的代码和数据在运行时动态地被程序加载和链接。</li></ul></li><li><p><strong>链接时机</strong>：</p><ul><li>静态库（<code>.a</code>）是在编译时链接的。编译器将库中需要的代码和数据复制到最终的可执行文件中。</li><li>动态库（<code>.so</code>）是在程序运行时（或加载时）链接的。应用程序只需知道所需函数的位置，实际的代码和数据则存储在外部的 <code>.so</code> 文件中。</li></ul></li><li><p><strong>程序大小</strong>：</p><ul><li>使用静态库（<code>.a</code>）的程序通常体积更大，因为库的所有内容都被包含在最终的可执行文件中。</li><li>使用动态库（<code>.so</code>）的程序体积较小，因为库代码不包含在程序内部。</li></ul></li><li><p><strong>内存占用和共享</strong>：</p><ul><li>使用静态库的不同程序会在内存中保留多个相同库的副本。</li><li>使用动态库的程序可以共享内存中同一个库的副本，从而节省内存。</li></ul></li><li><p><strong>部署和更新</strong>：</p><ul><li>静态库的更新需要重新编译所有使用该库的程序。</li><li>动态库可以独立于应用程序更新。只需替换 <code>.so</code> 文件，所有使用该库的程序在下次运行时都会使用新版本。</li></ul></li><li><p><strong>兼容性问题</strong>：</p><ul><li>静态库较少遇到兼容性问题，因为所有必要的代码和数据都包含在应用程序中。</li><li>动态库可能导致“地狱依赖”问题，特别是当不同的应用程序需要不同版本的同一库时。</li></ul></li><li><p><strong>跨平台</strong>：</p><ul><li>静态库在不同平台间的移植可能需要重新编译。</li><li>动态库可以为不同平台提供特定的版本，但同样需要考虑平台兼容性。</li></ul></li></ol><p>总的来说，<code>.a</code> 和 <code>.so</code> 文件各有优劣，选择使用哪一种通常取决于应用程序的特定需求和部署环境。静态库更适合体积不是问题，对性能要求高，或者更新不频繁的场合。动态库更适合需要减少程序体积，共享代码，或者频繁更新库代码的情况。</p><h2 id="怎么查看使用到的动态链接库" tabindex="-1">怎么查看使用到的动态链接库？ <a class="header-anchor" href="#怎么查看使用到的动态链接库" aria-label="Permalink to &quot;怎么查看使用到的动态链接库？&quot;">​</a></h2><p>查看程序使用的动态链接库（动态库）的方法取决于操作系统。以下是针对常见操作系统的几种方法：</p><h3 id="在-linux-或-unix-like-系统上" tabindex="-1">在 Linux 或 Unix-like 系统上 <a class="header-anchor" href="#在-linux-或-unix-like-系统上" aria-label="Permalink to &quot;在 Linux 或 Unix-like 系统上&quot;">​</a></h3><ol><li><p><strong>ldd 命令</strong>：</p><ul><li>这是最常用的方法。使用 <code>ldd</code> 命令 followed by the executable file&#39;s name，可以列出程序运行时需要的所有动态库。</li><li>例如，要查看名为 <code>program</code> 的可执行文件使用的动态库，你可以在终端中运行：<div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ldd</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> program</span></span></code></pre></div></li></ul></li><li><p><strong>objdump 命令</strong>：</p><ul><li><code>objdump</code> 是另一个工具，它提供了更详细的信息。使用 <code>-p</code> 选项可以显示动态链接信息。</li><li>示例命令：<div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">objdump</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> program</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> |</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> grep</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> NEEDED</span></span></code></pre></div></li></ul></li><li><p><strong>readelf 命令</strong>：</p><ul><li><code>readelf</code> 也是一个有用的工具，特别是用 <code>-d</code> 选项来查看动态段（dynamic section）。</li><li>示例命令：<div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">readelf</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> program</span></span></code></pre></div></li></ul></li></ol><h3 id="在-windows-系统上" tabindex="-1">在 Windows 系统上 <a class="header-anchor" href="#在-windows-系统上" aria-label="Permalink to &quot;在 Windows 系统上&quot;">​</a></h3><ol><li><p><strong>依赖查看器（Dependency Walker）</strong>：</p><ul><li>Dependency Walker（或称为 depends.exe）是一个可视化工具，可以在图形界面中展示出所有依赖的动态链接库。</li><li>它可以显示哪些 DLL 被程序直接或间接地依赖。</li></ul></li><li><p><strong>ListDLLs</strong>：</p><ul><li>这是 Sysinternals 提供的一个命令行工具，可以显示当前运行进程所加载的 DLL 列表。</li><li>示例命令：<div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ListDLLs process_name</span></span></code></pre></div></li></ul></li><li><p><strong>任务管理器</strong>：</p><ul><li>在较新版本的 Windows 中，任务管理器可以显示某个进程加载的 DLL。</li><li>你可以在“详细信息”标签页中找到进程，右击选择“转到详细信息”，然后查看“模块”标签页。</li></ul></li><li><p><strong>Visual Studio</strong>：</p><ul><li>如果你在使用 Visual Studio，可以在调试过程中查看“模块”窗口，它会列出当前进程加载的所有模块（包括 DLL）。</li></ul></li></ol><p>不同的方法可能提供不同程度的详细信息。在实际操作中，可以根据具体需求选择最合适的工具。</p>',14),t=[o];function n(d,r,p,c,h,g){return s(),l("div",null,t)}const b=i(a,[["render",n]]);export{u as __pageData,b as default};
