import{_ as s,c as i,o as a,R as e}from"./chunks/framework.2bglP9T5.js";const y=JSON.parse('{"title":"C++17 结构化绑定","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/modern/structured-binding.md","filePath":"cpp/modern/structured-binding.md"}'),t={name:"cpp/modern/structured-binding.md"},n=e(`<h1 id="c-17-结构化绑定" tabindex="-1">C++17 结构化绑定 <a class="header-anchor" href="#c-17-结构化绑定" aria-label="Permalink to &quot;C++17 结构化绑定&quot;">​</a></h1><p>结构化绑定（Structured Bindings）是在 C++17 标准中引入的一项特性，它代表了C++语言在现代化和提升代码可读性方面的一个重要步骤。这项特性的引入背景和历史可以概括如下：</p><h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h3><ol><li><p><strong>C++的演进</strong>：随着C++标准的发展，社区一直在寻求简化语言的方法，以提高代码的可读性和编写效率。C++11和C++14标准分别带来了许多现代化的特性，例如自动类型推断（<code>auto</code>）和范围循环（range-based for loops），这些特性极大地简化了代码。</p></li><li><p><strong>现代编程实践的需求</strong>：在现代编程中，经常需要从函数返回多个值或处理复合数据。在C++17之前，这通常通过返回<code>std::pair</code>、<code>std::tuple</code>或自定义结构来实现。但这种方法在使用时往往代码比较繁琐。</p></li></ol><h3 id="引入结构化绑定" tabindex="-1">引入结构化绑定 <a class="header-anchor" href="#引入结构化绑定" aria-label="Permalink to &quot;引入结构化绑定&quot;">​</a></h3><ol><li><p><strong>C++17标准</strong>：结构化绑定在C++17中被正式引入。这项特性允许程序员通过一个简单、清晰的语法直接解包<code>tuple</code>、<code>pair</code>或结构体中的元素到局部变量中。</p></li><li><p><strong>提案和讨论</strong>：结构化绑定的引入是基于多个提案和社区内的广泛讨论。这个特性的目标是简化代码，减少样板代码，并提高代码的表达能力。</p></li><li><p><strong>灵感来源</strong>：C++的结构化绑定在一定程度上受到了其他语言中类似特性的启发，例如Python中的元组解包（tuple unpacking）和Go语言中的多返回值。这些语言中的这些特性被证明在实际编程中非常有用和受欢迎。</p></li></ol><h3 id="结构化绑定的影响" tabindex="-1">结构化绑定的影响 <a class="header-anchor" href="#结构化绑定的影响" aria-label="Permalink to &quot;结构化绑定的影响&quot;">​</a></h3><p>结构化绑定的引入，改善了C++语言在多值返回和复杂数据处理方面的能力。它降低了语言的使用门槛，同时也提高了代码的可读性和编写效率。这一特性的加入是C++标准演进过程中的一个重要里程碑，体现了C++社区对于现代化和用户友好性的持续追求。</p><p>C++的结构化绑定是一种简化代码和提高可读性的语言特性。为了更好地解释这一点，让我们通过一个具体的例子来看看在没有结构化绑定之前和引入结构化绑定之后的情况。</p><h3 id="如何使用结构化绑定" tabindex="-1">如何使用结构化绑定 <a class="header-anchor" href="#如何使用结构化绑定" aria-label="Permalink to &quot;如何使用结构化绑定&quot;">​</a></h3><p>假设你有一个函数，它返回一个包含姓名和年龄的 <code>std::pair</code>：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">pair</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">string</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getPerson</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Alice</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 30</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 返回一个包含姓名和年龄的pair</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在 C++17 之前，你需要分别访问这个 <code>pair</code> 的 <code>first</code> 和 <code>second</code> 成员来获取姓名和年龄：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> person </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getPerson</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">string name </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">first</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">second</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre></div><p>但是使用 C++17 的结构化绑定，你可以更简洁地这样写：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">auto</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">name</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getPerson</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // name绑定到first，age绑定到second</span></span></code></pre></div><p>这里，<code>name</code> 和 <code>age</code> 被自动绑定到 <code>getPerson</code> 返回的 <code>pair</code> 的 <code>first</code> 和 <code>second</code> 上，使得代码更简洁易懂。结构化绑定不仅可以用于 <code>pair</code>，还可以用于 <code>tuple</code>、结构体和数组。</p><p>这种方式大大简化了从复合数据类型中提取数据的代码，使其更加清晰和易于维护。</p><h3 id="结构化绑定解决的问题" tabindex="-1">结构化绑定解决的问题 <a class="header-anchor" href="#结构化绑定解决的问题" aria-label="Permalink to &quot;结构化绑定解决的问题&quot;">​</a></h3><p>结构化绑定主要解决了以下问题：</p><ol><li><strong>代码简洁性</strong>：不再需要为每个从<code>pair</code>或<code>tuple</code>中提取的元素单独声明变量。</li><li><strong>可读性提高</strong>：直接在一行中声明所有变量，易于理解变量与其来源之间的关系。</li><li><strong>减少错误</strong>：在提取多个元素时减少了出错的可能性，因为不需要单独访问每个元素。</li></ol><p>通过结构化绑定，C++程序员可以编写出更加简洁和易于维护的代码。这是C++17标准中一个非常有用的特性。</p>`,22),h=[n];function p(l,k,d,r,o,c){return a(),i("div",null,h)}const u=s(t,[["render",p]]);export{y as __pageData,u as default};
