import{_ as e,c as a,o,R as t}from"./chunks/framework.2bglP9T5.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cpp/coreguide/i/i5.md","filePath":"cpp/coreguide/i/i5.md"}'),r={name:"cpp/coreguide/i/i5.md"},c=t(`<h3 id="i-5-说明前条件-如果有" tabindex="-1"><a name="Ri-pre"></a>I.5: 说明前条件（如果有） <a class="header-anchor" href="#i-5-说明前条件-如果有" aria-label="Permalink to &quot;&lt;a name=&quot;Ri-pre&quot;&gt;&lt;/a&gt;I.5: 说明前条件（如果有）&quot;">​</a></h3><h5 id="理由" tabindex="-1">理由 <a class="header-anchor" href="#理由" aria-label="Permalink to &quot;理由&quot;">​</a></h5><p>在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。</p><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><p>考虑：</p><pre><code>double sqrt(double x);
</code></pre><p>这里 <code>x</code> 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：</p><pre><code>double sqrt(double x); // x 必须是非负数
</code></pre><p>一些前条件可以表示为断言。例如：</p><pre><code>double sqrt(double x) { Expects(x &gt;= 0); /* ... */ }
</code></pre><p>理想情况下，这个 <code>Expects(x &gt;= 0)</code> 应当是 <code>sqrt()</code> 的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。</p><p><strong>参考</strong>: <code>Expects()</code> 在 <a href="#gsl-guidelines-support-library">GSL</a> 中有说明。</p><h5 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>优先使用正式的必要条件说明，比如 <code>Expects(!p);</code>。 如果这样不可行，就在注释中使用文字来说明，比如 <code>// 序列 [p:q) 根据 &lt; 排序</code>。</p><h5 id="注解-1" tabindex="-1">注解 <a class="header-anchor" href="#注解-1" aria-label="Permalink to &quot;注解&quot;">​</a></h5><p>许多成员函数都以某个类所保持的不变式作为一项前条件。 这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。 我们并不需要对每个成员函数都说明这个不变式。</p><h5 id="强制实施" tabindex="-1">强制实施 <a class="header-anchor" href="#强制实施" aria-label="Permalink to &quot;强制实施&quot;">​</a></h5><p>【无法强制实施】</p><p><strong>参见</strong>: 有关传递指针的规则。???</p>`,19),d=[c];function i(p,s,n,l,h,u){return o(),a("div",null,d)}const b=e(r,[["render",i]]);export{x as __pageData,b as default};
