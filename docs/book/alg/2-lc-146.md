# 2. 146. LRU ç¼“å­˜

è¿›åº¦ï¼š

* ğŸ¦„ å­¦ä¼šäº†
* ğŸ¦„ 20min æå®š ä¸å¤ªç†Ÿç»ƒã€‚ 
* 

https://leetcode-cn.com/problems/lru-cache/


é“¾è¡¨çš„æ’å…¥å’Œåˆ é™¤çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼Œmap æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1) ï¼ŒäºŒè€…ç»“åˆï¼ŒæŸ¥æ‰¾çš„æ—¶å€™ç”¨ mapï¼Œåˆ é™¤çš„æ—¶å€™ç”¨é“¾è¡¨ã€‚

ç°åœ¨è¦å®ç° get å’Œ put æ–¹æ³•ã€‚å…¶ä¸­ get æ–¹æ³•æ˜¯æŸ¥æ‰¾å…¶ä¸­æ˜¯å¦å­˜åœ¨ key ï¼Œå­˜åœ¨å°±è¿”å›å¯¹åº”çš„ value ï¼Œä¸å­˜åœ¨å°±è¿”å› -1ï¼Œç”¨ map æ¥å®ç°å°±å¥½ã€‚

put æ–¹æ³•ï¼Œå¦‚æœ key å·²ç»å­˜åœ¨å°±æ›´æ–° valueï¼Œå¦‚æœ key ä¸å­˜åœ¨å°±æ’å…¥ï¼Œå¦‚æœæ’å…¥å¯¼è‡´å®¹é‡ä¸å¤Ÿå°±åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ k/v ï¼Œç”¨ é“¾è¡¨æ¥å®ç°ã€‚åœ¨é“¾è¡¨ä¸­ï¼Œå¤´éƒ¨è¡¨ç¤ºç»å¸¸ä½¿ç”¨çš„ï¼Œå°¾éƒ¨ç›¸åï¼Œé‚£ä¹ˆåˆ é™¤çš„æ—¶å€™ä¼˜å…ˆåˆ é™¤å°¾éƒ¨ã€‚

```java
class DoubleLinkedList {
    public Node head;
    public Node tail;
    public DoubleLinkedList() {
        head = new Node(0 , 0);
        tail = new Node(0 , 0);
        head.next = tail;
        tail.prev = head;
    }

    // å¤´éƒ¨æ’å…¥
    public void addFirt(Node node) {
        node.next = head.next;
        node.prev = head;

        head.next.prev = node;
        head.next      = node;
    }

    // åˆ é™¤æŒ‡å®š Node
    public int delete(Node n) {
        int key = n.key;
        n.next.prev = n.prev;
        n.prev.next = n.next;
        return key;
    }

    // åˆ é™¤ tail
    public int deleteLast() {
        if (head.next == tail) return -1;
       return delete(tail.prev);
    }

}

class Node {
    public int key;
    public int val;
    public Node next;
    public Node prev;
    public Node(int key, int val) {
        this.key = key;
        this.val = val;
    }
}

class LRUCache {

    int cap;

    HashMap<Integer , Node> map;

    DoubleLinkedList cache;

    public LRUCache(int capacity) {
        this.cap    = capacity;
        this.cache  = new DoubleLinkedList();
        map         = new HashMap<>();

    }

    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        int val = map.get(key).val;
        // get è¡¨ç¤ºä½¿ç”¨äº†ä¸€æ¬¡ï¼Œæ‰€ä»¥éœ€è¦æ›´æ–°é¢‘ç‡
        // é‚£ä¹ˆæ’åœ¨é˜Ÿå°¾ï¼Œä¹Ÿå°±æ˜¯æ›´æ–°ï¼Œè€Œ put åŒ…å«äº†æ›´æ–°æ“ä½œ
        put(key , val);
        return val;
    }

    public void put(int key, int value) {
        Node newNode = new Node(key , value);

        // update
        if (map.containsKey(key)) {
            // åˆ é™¤æ—§çš„ï¼Œåœ¨å¤´éƒ¨æ·»åŠ æ–°çš„ï¼Œå› ä¸ºé¢‘ç‡å˜äº†ï¼ï¼ï¼
            cache.delete(map.get(key));
            cache.addFirt(newNode);
            map.put(key, newNode);
        }else {
            // delete
            if (map.size() == cap) {
                int k = cache.deleteLast();
                map.remove(k);
            }
                cache.addFirt(newNode);
                map.put(key, newNode);
        }
    }
}
```