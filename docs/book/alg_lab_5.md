# æ¦‚è¿°
åŸºç¡€æ¦‚å¿µå¾ˆé‡è¦ï¼Œä¸‹é¢æ˜¯ä¸€äº›åŸºç¡€æ€§çš„çŸ¥è¯†æ€»ç»“ã€‚

å›¾å¯ä»¥æ ¹æ®æ˜¯å¦æœ‰å‘å’Œå¸¦æƒåˆ†æˆä»¥ä¸‹å››ç§ã€‚

* æ— å‘å›¾
* æœ‰å‘å›¾
* åŠ æƒæ— å‘å›¾
* åŠ æƒæœ‰å‘å›¾

## æ— å‘å›¾

> æ— å‘å›¾å®šä¹‰ï¼š ä¸€ç»„é¡¶ç‚¹å’Œä¸€ç»„å¯ä»¥å°†é¡¶ç‚¹è¿æ¥åœ¨ä¸€èµ·è¾¹ç»„æˆã€‚
 
ç‰¹æ®Šçš„å›¾ï¼š è‡ªç¯ï¼Œå¹³è¡Œè¾¹ã€‚

è‡ªç¯ï¼š å°±æ˜¯è‡ªå·±è¿è‡ªå·±ï¼Œåƒè´ªåƒè›‡ä¸€æ ·ï¼Œä¸€ä¸ªç‚¹å½¢æˆäº†ç¯ã€‚

å¹³è¡Œè¾¹ï¼š åŒä¸€å¯¹é¡¶ç‚¹ä¸Šæœ‰å¤šæ¡è¾¹ç›¸è¿ã€‚å°±åƒå®¶å’Œå­¦æ ¡ä¸¤ä¸ªç‚¹ä¹‹é—´å­˜åœ¨å¾ˆå¤šæ¡è·¯å¯ä»¥é€‰æ‹©ï¼Œè€Œè·¯ä¸è·¯ä¹‹é—´ç§°ä¸ºå¹³è¡Œè¾¹ã€‚

## æœ¯è¯­è¡¨
è¿™ä¸€æœ¯è¯­å¾ˆå¤šéƒ½æ˜¯ä¸€ä¸ªå¥—ä¸€ä¸ªï¼Œå‰é¢å‡ ä¸ªåŸºç¡€æ€§çš„å¼„æ˜ç™½äº†ï¼Œåé¢çš„æ¦‚å¿µå°±ä¼šç†è§£çš„éå¸¸å¿«ï¼

* ç›¸é‚»ï¼šä¸¤ä¸ªé¡¶ç‚¹å’ŒåŒä¸€æ¡è¾¹ç›¸è¿ç§°ä¸ºç›¸é‚»ã€‚åŒæ—¶ä¹Ÿç§°è¿™æ¡è¾¹**ä¾é™„**ä¸è¿™ä¸¤ä¸ªé¡¶ç‚¹ã€‚
* é¡¶ç‚¹çš„åº¦ï¼šä¸è¯¥é¡¶ç‚¹ç›¸é‚»è¾¹çš„ä¸ªæ•°ã€‚
* å­å›¾ï¼šä¸€å¹…å›¾ä¸­æ‰€æœ‰è¾¹çš„å­é›†ä»¥åŠè¿™äº›è¾¹ç›¸å…³çš„ç‚¹æ‰€ç»„æˆçš„å›¾ã€‚
* è·¯å¾„ï¼šè¾¹é¡ºåºè¿æ¥èµ·æ¥çš„ä¸€ç³»åˆ—çš„é¡¶ç‚¹ã€‚
* ç®€å•è·¯å¾„ï¼šæ²¡æœ‰é‡å¤é¡¶ç‚¹çš„è·¯å¾„ã€‚
* ç¯ï¼šè‡³å°‘å«æœ‰ä¸€æ¡èµ·ç‚¹å’Œç»ˆç‚¹ç›¸åŒçš„è·¯å¾„ã€‚
* ç®€å•ç¯ï¼šä¸å«æœ‰é‡å¤é¡¶ç‚¹å’Œè¾¹çš„ç¯ã€‚
* è¿é€šå›¾ï¼šä»»æ„ä¸€ä¸ªé¡¶ç‚¹éƒ½å­˜åœ¨ä¸€æ¡è·¯å¾„åˆ°è¾¾å¦ä¸€ä¸ªä»»æ„é¡¶ç‚¹ã€‚
* æå¤§è¿é€šå­å›¾ï¼šéè¿é€šå›¾æ˜¯ç”±è‹¥å¹²ä¸ªè¿é€šå­å›¾ç»„æˆï¼Œè¿™äº›è¿é€šå­å›¾ç§°ä¸ºæå¤§è¿é€šå­å›¾ã€‚
* è¿é€šåˆ†é‡ï¼šæå¤§è¿é€šå­å›¾çš„ä¸ªæ•°ç§°ä¸ºéè¿é€šå›¾çš„è¿é€šåˆ†é‡ã€‚
* æ ‘ï¼šæ— ç¯**è¿é€šå›¾**ã€‚
* æ£®æ—ï¼šäº’ä¸ç›¸è¿çš„**æ ‘**ç»„æˆ**æ£®æ—**ã€‚
* ç”Ÿæˆæ ‘ï¼š**è¿é€šå›¾**çš„**å­å›¾**ï¼Œå«æœ‰å›¾ä¸­çš„æ‰€æœ‰**é¡¶ç‚¹**å¹¶ä¸”è¿˜å¾—æ˜¯ä¸€æ£µ**æ ‘**ã€‚
* ç”Ÿæˆæ£®æ—ï¼š**ç”Ÿæˆæ ‘**çš„é›†åˆï¼Œä¹Ÿå°±æ˜¯è¯¥å›¾çš„æ‰€æœ‰**è¿é€šå­å›¾**çš„**ç”Ÿæˆæ ‘**çš„é›†åˆã€‚
* ç¨€ç–å›¾ï¼šè¢«è¿æ¥çš„é¡¶ç‚¹å¯¹å¾ˆå°‘ï¼Œä¹Ÿå°±æ˜¯è¾¹æ¯”è¾ƒå°‘çš„å›¾ã€‚
* ç¨ å¯†å›¾ï¼šå¤§éƒ¨åˆ†çš„é¡¶ç‚¹å¯¹éƒ½æœ‰è¾¹ç›¸è¿ï¼Œåªæœ‰å°‘éƒ¨åˆ†çš„é¡¶ç‚¹å¯¹ä¹‹é—´æ²¡æœ‰è¾¹è¿æ¥ã€‚
* äºŒåˆ†å›¾ï¼šé¡¶ç‚¹é›†å¯ä»¥åˆ†å‰²æˆä¸¤ä¸ªäº’ä¸ç›¸äº¤çš„å­é›†ã€‚

## å›¾çš„è¡¨ç¤ºæ–¹æ³•
* é‚»æ¥çŸ©é˜µï¼Œé‚»æ¥è¡¨æ•°ç»„ï¼Œè¾¹çš„æ•°ç»„

# 283. ç§»åŠ¨é›¶

[ä¼ é€é—¨](https://leetcode-cn.com/problems/move-zeroes/)

## é¢˜æ„

- å°†é›¶å…¨éƒ¨ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ã€‚
- ç§»åŠ¨é›¶çš„åŒæ—¶ä¿è¯éé›¶æ•°å­—çš„ç›¸å¯¹ä½ç½®ä¸å˜ã€‚

## åˆ†æ
- åˆ©ç”¨é€‰æ‹©æ’åºçš„æ€æƒ³ä¼šæ‰“ä¹±éé›¶æ•°å­—çš„ç›¸å¯¹ä½ç½®ã€‚

- å…ˆå°†éé›¶å…ƒç´ æŒ‘æ‹£å‡ºæ¥ï¼Œå‘ç°ä¸€ä¸ªå°±å­˜èµ·æ¥ï¼Œå°†é›¶å…ƒç´ æŠ¹æ‰ï¼Œè€Œå‰©ä¸‹çš„å°±æ˜¯é›¶å…ƒç´ ï¼Œç›´æ¥å¡«å……å³å¯ã€‚

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[index++] = nums[i];
            }
        }
        while (index < nums.length) {
            nums[index++] = 0;
        }
    }
}
```

```java
class Solution {
    public void moveZeroes(int[] nums) {
        for(int i = 0 , j = 0 ; i < nums.length; i++){
            if(nums[i] != 0) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                j++;
            }
        }
    }
}
```

# 566. é‡å¡‘çŸ©é˜µ

[ä¼ é€é—¨](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

## é¢˜æ„

- å°†çŸ©é˜µä¸­çš„æ•°å­—æŒ‰ç…§åŸæ¥çš„é¡ºåºé‡æ–°å¡«å…¥ä¸€ä¸ªæ–°çš„çŸ©é˜µä¸­ï¼Œæ–°æ—§ä¸¤ä¸ªçŸ©é˜µçš„è¡Œåˆ—å€¼ä¹˜ç§¯ç›¸ç­‰æ‰å¯ä»¥å¡«å……ã€‚

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int m = nums.length;
        int n = nums[0].length;
        int[][]  newMatrix = new int[r][c];
        if ( m * n != r * c ) {
            return nums;
        }
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                q.add(nums[i][j]);
            }
        }
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                newMatrix[i][j] = q.remove();
            }
        }
        return newMatrix;
    }
}
```

1. æ—¶é—´å¤æ‚åº¦ï¼šO($n^2$) ä¸¤ä¸ª for å¾ªç¯ m * n
2. ç©ºé—´å¤æ‚åº¦ï¼šO($n^2$) é˜Ÿåˆ—çš„å¤§å°ä¸º m * n 

- åŸåœ°å¡«å……ï¼Œè®¡ç®—å¯¹åº”å¡«å……ä½ç½®çš„ä¸‹æ ‡ï¼Œä¸éœ€è¦å†å»ºé˜Ÿåˆ—ã€‚
äºŒç»´æ•°ç»„çš„æœ¬è´¨è¿˜æ˜¯ä¸€ä½æ•°ç»„ï¼Œåœ¨å­˜å‚¨æ—¶è¿˜æ˜¯ä¸€è¡Œæ•°å­—ï¼Œæ¯è¡Œæ•°å­—ä¸ªæ•°ä¸º c ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ c ä¸ºå•ä½å°†è¿™ä¸€è¡Œæ•°å­—æˆªæ–­å¼€æ¥ã€‚
åˆ†åˆ«è®¡ç®—ä¸‹æ ‡ç´¢å¼•ï¼Œindex/c ç”¨æ¥è®¡ç®—è¡Œæ•°ï¼Œ index%c ç”¨æ¥è®¡ç®—åˆ—æ•°ã€‚å½’çº³ä¸€ä¸‹ä¹Ÿå¯ä»¥å‘ç°è¿™ä¸ªè§„å¾‹ã€‚
éœ€è¦æ–°å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œåœ¨åŸç´ ç»„ä¸Šæ“ä½œå­˜åœ¨å°†åŸæ¥æ•°æ®æŠ¹é™¤çš„å¯èƒ½ã€‚
é‡å¡‘å¹¶æ²¡æœ‰æ”¹å˜æ•°ç»„å…ƒç´ çš„ç›¸å¯¹ä½ç½®ï¼Œåªæ˜¯å»ºç«‹äº†æ–°çš„ç´¢å¼•ã€‚

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int m = nums.length;
        int n = nums[0].length;
        int index = 0;
        int[][]  newMatrix = new int[r][c];
        if ( m * n != r * c || m == 0) {
            return nums;
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                newMatrix[index/c][index%c] = nums[i][j];
                index++;
            }
        }
        return newMatrix;
    }
}
```

# 485. æœ€å¤§è¿ç»­1çš„ä¸ªæ•°
[ä¼ é€é—¨](https://leetcode-cn.com/problems/max-consecutive-ones/)

## é¢˜æ„
è®¡ç®—è¿ç»­çš„ 1 çš„é•¿åº¦ã€‚
## æ€è€ƒ
- å°†æ‰€æœ‰ 1 çš„é•¿åº¦éƒ½ç»Ÿè®¡ï¼Œå–æœ€å¤§å€¼ã€‚
```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int cnt = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                cnt++;
            }else{
                cnt = 0;
            }
            max = Math.max(max,cnt);
        }
        return max;
    }
}
```

# 240. æœç´¢äºŒç»´çŸ©é˜µ II
[ä¼ é€é—¨](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)
## æ€è·¯
- ç›´æ¥æœç´¢
- ä»å·¦ä¸‹è§’æˆ–è€…å³ä¸Šè§’å‡ºå‘ï¼Œå¦‚æœä»å·¦ä¸Šè§’æˆ–å³ä¸‹è§’å‡ºå‘çš„è¯æœ€åçš„æƒ…å†µå¯èƒ½ä¼šå…¨å±€éƒ½æœä¸€éï¼Œè€Œå³ä¸Šè§’å‡ºå‘æœæœ€åä¼šæœä¸€åŠã€‚
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int m = matrix.length, n = matrix[0].length;
        int row = 0, col = n - 1;
        while (row < m && col >= 0) {
            if (target == matrix[row][col]) return true;
            else if (target < matrix[row][col]) col--;
            else row++;
        }
        return false;
    }
}
```
# 378. æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ 
[ä¼ é€é—¨](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)
## é¢˜æ„
æ•°ç»„ç±»å‹å’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œåªæ˜¯å˜æˆäº†æœç´¢ç¬¬ k å°çš„å…ƒç´ ã€‚
## æ€è€ƒ
- ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå†…éƒ¨å»ºå †


# 695. å²›å±¿çš„æœ€å¤§é¢ç§¯
[æˆ³æˆ‘](https://leetcode-cn.com/problems/max-area-of-island/)
## æ€è€ƒ
ä»ç½‘æ ¼çš„æ¯ä¸€ä¸ªç‚¹éƒ½è¿›è¡Œä¸€æ¬¡ DFSï¼Œæ¯æ¬¡æœç´¢æ—¶é‡åˆ°é›¶å°±ä¸å†å‘æ ˆå¸§ä¸­å‹æ ˆï¼Œå½“æ— æ³•å†å‹æ ˆæ—¶è¿›è¡Œå›æº¯ã€‚
ä»æ‰€æœ‰çš„ç»“æœä¸­é€‰å‡ºæœ€å¤§å€¼å³ä¸ºæœ€å¤§é¢ç§¯ã€‚
## code
```java
class Solution {
    private int m ; 
    private int n ;
    private int [][]direction = { {-1 , 0}, {1 , 0}, {0 , 1}, {0 , -1}};
    public int maxAreaOfIsland(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        int maxarea = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                maxarea = Math.max(maxarea,dfs(grid, i,j));
            }
        }
        return maxarea;
    }
    public int dfs(int[][]grid, int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) {
            return 0;
        }
        grid[i][j] = 0;
        int area = 1;
        for (int [] d:direction) {
            area += dfs(grid,i + d[0],j + d[1]);
        }
        return area;
    }
}
```



# 547. æœ‹å‹åœˆ

[æˆ³æˆ‘](https://leetcode-cn.com/problems/friend-circles/)
## æ€è€ƒ
é’ˆå¯¹æ¯ä¸€ä¸ªä¸‹æ ‡éƒ½è¿›è¡Œæ·±æœï¼Œä¸€æ—¦ç¬¦åˆé¢˜æ„å°±å‹æ ˆï¼Œç„¶åè®¾ç½®æ ‡è®°è¡¨ç¤ºæ‰«æè¿‡ï¼Œç„¶åç»§ç»­å‹æ ˆï¼Œæ ˆç©ºè®¡æ•°ã€‚
```java
class Solution {
    private int n ;
    public int findCircleNum(int[][] M) {
        int[] visited = new int[M.length];
        int cnt = 0;
        for (int i = 0; i < M.length; i++) {
            if (visited[i] == 0) {
                dfs(M , visited ,i);
                cnt ++;
            }
        }
        return cnt;
    }
    public void dfs(int[][] M , int[] visited , int i) {
        visited[i] = 1;
        for (int j = 0; j < M.length; j++) {
            if (M[i][j] == 1 && visited[j] == 0) {
                visited[j] = 1;
                dfs(M , visited , j);
            }
        }
    }
}
```

## 1. æ¨¡æ¿é¢˜â… 

[102. äºŒå‰æ ‘çš„å±‚æ¬¡éå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### æ€è€ƒ
ç›´æ¥å¥—æ¨¡æ¿ï¼Œç†Ÿæ‚‰ç®—æ³•æ¡†æ¶ã€‚

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            int size = queue.size();
            while (size-- > 0) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            result.add(list);
        }
        return result;
    }
}
```

## 2. æ¨¡æ¿é¢˜â…¡

[107. äºŒå‰æ ‘çš„å±‚æ¬¡éå† II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
### æ€è€ƒ
åœ¨ç¬¬ä¸€é¢˜çš„åŸºç¡€ä¸Šï¼Œå°†åˆ—è¡¨åè½¬å³å¯ï¼

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result1 = new ArrayList<>();
        if(root == null) return result1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> result2 = new ArrayList<>();
            while (size -- > 0) {
                TreeNode node = queue.poll();
                result2.add(node.val);
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            result1.add(result2);
        }
        Collections.reverse(result1);
        return result1;
    }
}
```

## 3. æ¨¡æ¿â…¢
[103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### æ€è€ƒ
å’Œå‰ä¸¤é¢˜çš„ç»“åˆï¼Œå¥‡å¶äº¤æ›¿åè½¬å³å¯

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        Queue<TreeNode> queue = new LinkedList<>();
        int i = 0;
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            i ++;
            while (size -- > 0) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            if (i%2 != 0) {
                result.add(list);
            }else{
                Collections.reverse(list);
                result.add(list);
            }
        }
        return result;
    }
}
```

## 4. æ¯ä¸€å±‚æœ€åçš„å€¼

[199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

### æ€è€ƒ
åªä¿ç•™æ¯ä¸€å±‚æœ€åçš„å€¼å³å¯ï¼Œä¿®æ”¹ç»†èŠ‚å³å¯ã€‚

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == size - 1) result.add(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
        }
        return result;
    }
}
```

## 5. æ±‚æ ‘çš„å±‚æ•°
[559. Nå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)
### æ€è€ƒ
ä¸Šé¢é¢˜ç›®çš„å˜å½¢ï¼Œä¿®æ”¹ç»†èŠ‚å³å¯å®ç°ã€‚

```java
class Solution {
    public int maxDepth(Node root) {
        Queue<Node> queue = new LinkedList<>();
        if (root == null) return 0;
        int high = 0;
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            high++;
            while ( size-- > 0 ) {
                Node node = queue.poll();
                for (Node a : node.children) {
                    queue.add(a);
                }
            }
        }
        return high;
    }
}
```

## 6. æ¨¡æ¿é¢˜å˜å½¢
[429. Nå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

### æ€è€ƒ
æ³¨æ„éå†æ—¶çš„æ¡ä»¶ï¼

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            while (size -- > 0) {
             Node node = queue.poll();
             list.add(node.val);
             if (node != null ) {
                 for (Node a: node.children) {
                     queue.add(a);
                 }
             }
            }
            result.add(list);
        }
        return result;
    }
}
```



---
title: å›¾è®º
date: 2019-08-27 18:08:44
tags: 
- C++
- å›¾è®º

top_img: https://image.135editor.com/files/users/531/5317107/201907/Ec98WQ4W_hAwF.jpg


categories: 
- ACM
---


# å¹¶æŸ¥é›† 
# å¹¶æŸ¥é›†ä¾‹é¢˜
## P3367 ã€æ¨¡æ¿ã€‘å¹¶æŸ¥é›†

å¦‚é¢˜ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œä½ éœ€è¦å®Œæˆåˆå¹¶å’ŒæŸ¥è¯¢æ“ä½œã€‚

**è¾“å…¥æ ¼å¼**
ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°Nã€Mï¼Œè¡¨ç¤ºå…±æœ‰Nä¸ªå…ƒç´ å’ŒMä¸ªæ“ä½œã€‚

æ¥ä¸‹æ¥Mè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•°Ziã€Xiã€Yi

å½“Zi=1æ—¶ï¼Œå°†Xiä¸Yiæ‰€åœ¨çš„é›†åˆåˆå¹¶

å½“Zi=2æ—¶ï¼Œè¾“å‡ºXiä¸Yiæ˜¯å¦åœ¨åŒä¸€é›†åˆå†…ï¼Œæ˜¯çš„è¯è¾“å‡ºYï¼›å¦åˆ™è¯è¾“å‡ºN

**è¾“å‡ºæ ¼å¼**
å¦‚ä¸Šï¼Œå¯¹äºæ¯ä¸€ä¸ªZi=2çš„æ“ä½œï¼Œéƒ½æœ‰ä¸€è¡Œè¾“å‡ºï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œä¸ºYæˆ–è€…N

**è¾“å…¥è¾“å‡ºæ ·ä¾‹**
**è¾“å…¥ #1 å¤åˆ¶**
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4
**è¾“å‡º #1 å¤åˆ¶**
N
Y
N
Y
**è¯´æ˜/æç¤º**
æ—¶ç©ºé™åˆ¶ï¼š1000ms,128M

æ•°æ®è§„æ¨¡ï¼š

å¯¹äº30%çš„æ•°æ®ï¼ŒN<=10ï¼ŒM<=20ï¼›

å¯¹äº70%çš„æ•°æ®ï¼ŒN<=100ï¼ŒM<=1000ï¼›

å¯¹äº100%çš„æ•°æ®ï¼ŒN<=10000ï¼ŒM<=200000ã€‚


```c++
#include<iostream>
using namespace std;
int f[10010]; 
int n,m,a,b,c,i,j;
int find(int x){
	if(f[x] == x) return x;
	return f[x]=find(f[x]);
}
int main(){
	cin>>n>>m;
	for(i=1;i<=n;i++){//åˆå§‹åŒ–ä½¿å¾—æ¯ä¸€ä¸ªå…ƒç´ çš„å¤§å“¥éƒ½æ˜¯æœ¬èº« 
		f[i]=i;
	}
	for(i=1;i<=m;i++){
		cin>>a>>b>>c;
		if(a==1){
			f[find(b)] = find(c);//cçš„å¤§å“¥èµ‹ç»™bçš„å¤§å“¥å®ç°äº†é›†åˆåˆå¹¶ 
		}else{
			if(find(b)==find(c)){//åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ çš„ç¥–å…ˆæ˜¯å¦ä¸€è‡´ 
				cout<<"Y"<<endl;
			}else{
				cout<<"N"<<endl;
			}
		}
	}
	return 0;
} 
```


## XYNU1382: ç•…é€šå·¥ç¨‹1ï¼ˆå¹¶æŸ¥é›†ï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 32 MB
æäº¤: 30  è§£å†³: 20
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
æŸçœè°ƒæŸ¥åŸé•‡äº¤é€šçŠ¶å†µï¼Œå¾—åˆ°ç°æœ‰åŸé•‡é“è·¯ç»Ÿè®¡è¡¨ï¼Œè¡¨ä¸­åˆ—å‡ºäº†æ¯æ¡é“è·¯ç›´æ¥è¿é€šçš„åŸé•‡ã€‚çœæ”¿åºœâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡æ˜¯ä½¿å…¨çœä»»ä½•ä¸¤ä¸ªåŸé•‡é—´éƒ½å¯ä»¥å®ç°äº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„é“è·¯ç›¸è¿ï¼Œåªè¦äº’ç›¸é—´æ¥é€šè¿‡é“è·¯å¯è¾¾å³å¯ï¼‰ã€‚é—®æœ€å°‘è¿˜éœ€è¦å»ºè®¾å¤šå°‘æ¡é“è·¯ï¼Ÿ

**è¾“å…¥**
æµ‹è¯•è¾“å…¥åŒ…å«è‹¥å¹²æµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬1è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯åŸé•‡æ•°ç›®N ( < 1000 )å’Œé“è·¯æ•°ç›®Mï¼›éšåçš„Mè¡Œå¯¹åº”Mæ¡é“è·¯ï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯è¯¥æ¡é“è·¯ç›´æ¥è¿é€šçš„ä¸¤ä¸ªåŸé•‡çš„ç¼–å·ã€‚ä¸ºç®€å•èµ·è§ï¼ŒåŸé•‡ä»1åˆ°Nç¼–å·ã€‚ 
    æ³¨æ„:ä¸¤ä¸ªåŸå¸‚ä¹‹é—´å¯ä»¥æœ‰å¤šæ¡é“è·¯ç›¸é€š,ä¹Ÿå°±æ˜¯è¯´
    3 3
    1 2
    1 2
    2 1
    è¿™ç§è¾“å…¥ä¹Ÿæ˜¯åˆæ³•çš„
    å½“Nä¸º0æ—¶ï¼Œè¾“å…¥ç»“æŸï¼Œè¯¥ç”¨ä¾‹ä¸è¢«å¤„ç†ã€‚

**è¾“å‡º**
å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨1è¡Œé‡Œè¾“å‡ºæœ€å°‘è¿˜éœ€è¦å»ºè®¾çš„é“è·¯æ•°ç›®ã€‚

**æ ·ä¾‹è¾“å…¥**
 5 3
1 2
3 2
4 5
0
**æ ·ä¾‹è¾“å‡º**
1

```c++
#include<iostream>
using namespace std;
int n,m,a[1010],sum,p,q;
int find(int x){
	if(a[x]==x)return x;
	return a[x] = find(a[x]);
}
int main(){
	while(cin>>n>>m&&n!=0){
		for(int i=1;i<=n;i++){
			a[i] = i;
		}
		sum = n-1;//é“è·¯çš„æœ€å¤§ä¸ªæ•°ä¸ºåŸé•‡æ•°å‡ä¸€ 
		for(int i=1;i<=m;i++){
			cin>>p>>q;
			if(find(p)!=find(q)){
				a[find(p)] = find(q);
				sum--;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
}
```

```c++
#include<iostream>
using namespace std;
int pre[1010];
int find(int x){
	if(pre[x]==x) return x;
	return pre[x] = find(pre[x]);
}
int main(){
	int n,m,a,b;
	while(cin>>n>>m&&n!=0){
	for(int i=1;i<=n;i++){
		pre[i] = i;
	}
	int ans = 0;
	for(int i=1;i<=m;i++){
		cin>>a>>b;
		if(find(a)!=find(b)){
			pre[find(b)] = find(a);
		}
	}
	for(int i=1;i<=n;i++){
		if(pre[i]==i){
			ans++;
		}
	}
	cout<<ans-1<<endl;		
	}
	return 0;
} 
```
## HDU1325Is It A Tree?ï¼ˆå¹¶æŸ¥é›†ï¼‰

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 34031    Accepted Submission(s): 7763


**Problem Description**
A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties. 
There is exactly one node, called the root, to which no directed edges point. 

Every node except the root has exactly one edge pointing to it. 

There is a unique sequence of directed edges from the root to each node. 

For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.




In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not. 

 

**Input**
The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero. 
 

**Output**
For each test case display the line ``Case k is a tree." or the line ``Case k is not a tree.", where k corresponds to the test case number (they are sequentially numbered starting with 1). 
 

**Sample Input**
6 8 5 3 5 2 6 4
5 6 0 0
8 1 7 3 6 2 8 9 7 5
7 4 7 8 7 6 0 0
3 8 6 8 6 4
5 3 5 6 5 2 0 0
-1 -1
 

**Sample Output**
Case 1 is a tree.
Case 2 is a tree.
Case 3 is not a tree.
 

```c++
#include<iostream>
#include<cstring>
#define N 11000
using namespace std;
int pre[N],vis[N],flag,maxn;
void Init(){//æ•°ç»„åˆå§‹åŒ– 
	for(int i=0;i<N;i++)
		pre[i] = i;
	memset(vis,0,sizeof(vis));
	flag = 1;
	maxn = 0; 
}
int Find(int x){//æŸ¥æ‰¾è€å¤§ 
	if(pre[x] == x) return x;
	return Find(pre[x]);
}
void Merge(int u,int v){//åˆå¹¶ 
	int t1 = Find(u);
	int t2 = Find(v);
	if(v!=t2||t1==t2)flag = 0;//æ’é™¤äº†ä¸€ä¸ªèŠ‚ç‚¹è¢«ä¸¤æ¡çº¿æŒ‡å‘çš„æƒ…å†µ 
	if(t1!=t2) pre[t2] = t1;//åˆ†æ”¯åˆå¹¶ 
}
int main(){
	int a,b,kase=0;//æƒ…å†µæ•°é‡è¦åˆå§‹åŒ– 
	Init();
	while(cin>>a>>b&&a>=0&&b>=0){ 
		if(a==0&&b==0){	
		int tp=0;
		for(int i=1;i<=maxn;i++)
			if(vis[i]&&i==pre[i])tp++;
			if(tp<=1&&flag){
				printf("Case %d is a tree.\n",++kase);
			}else{
				printf("Case %d is not a tree.\n",++kase);
			}
		Init();
		continue;
		}
		maxn = max(maxn,max(a,b));
		vis[a] = vis[b] = 1;
		Merge(a,b);
	}
	return 0;
}
```
## HDU1213How Many Tablesï¼ˆå¹¶æŸ¥é›†ï¼‰

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 56530    Accepted Submission(s): 28176


**Problem Description**
Today is Ignatius' birthday. He invites a lot of friends. Now it's dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.

One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.

For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.
 

**Input**
The input starts with an integer T(1<=T<=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1<=N,M<=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.
 

**Output**
For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.
 

**Sample Input**
2
5 3
1 2
2 3
4 5

5 1
2 5

```c++
#include<iostream>
using namespace std;
int n,m,a[1010],sum,p,q,t;
int find(int x){
	if(a[x]==x)return x;
	return a[x] = find(a[x]);
}
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			a[i] = i;
		}
		sum = n;//æ¡Œå­çš„æœ€å¤§æ•°ç›®å’Œæœ‹å‹çš„ä¸ªæ•°ç›¸ç­‰ 
		for(int i=1;i<=m;i++){
			cin>>p>>q;
			if(find(p)!=find(q)){
				a[find(p)] = find(q);
				sum--;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
}
```
## XYNU1825: ä¸€ç¬”ç”»é—®é¢˜ï¼ˆå¹¶æŸ¥é›†/è¿é€šå›¾ï¼‰

æ—¶é—´é™åˆ¶: 3 Sec  å†…å­˜é™åˆ¶: 64 MB
æäº¤: 115  è§£å†³: 66
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
zycä»å°å°±æ¯”è¾ƒå–œæ¬¢ç©ä¸€äº›å°æ¸¸æˆï¼Œå…¶ä¸­å°±åŒ…æ‹¬ç”»ä¸€ç¬”ç”»ï¼Œä»–æƒ³è¯·ä½ å¸®ä»–å†™ä¸€ä¸ªç¨‹åºï¼Œåˆ¤æ–­ä¸€ä¸ªå›¾æ˜¯å¦èƒ½å¤Ÿç”¨ä¸€ç¬”ç”»ä¸‹æ¥ã€‚

è§„å®šï¼Œæ‰€æœ‰çš„è¾¹éƒ½åªèƒ½ç”»ä¸€æ¬¡ï¼Œä¸èƒ½é‡å¤ç”»ã€‚

**è¾“å…¥**
ç¬¬ä¸€è¡Œåªæœ‰ä¸€ä¸ªæ­£æ•´æ•°N(N<=10)è¡¨ç¤ºæµ‹è¯•æ•°æ®çš„ç»„æ•°ã€‚
æ¯ç»„æµ‹è¯•æ•°æ®çš„ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•°P,Q(P<=1000,Q<=2000)ï¼Œåˆ†åˆ«è¡¨ç¤ºè¿™ä¸ªç”»ä¸­æœ‰å¤šå°‘ä¸ªé¡¶ç‚¹å’Œå¤šå°‘æ¡è¿çº¿ã€‚ï¼ˆç‚¹çš„ç¼–å·ä»1åˆ°Pï¼‰
éšåçš„Qè¡Œï¼Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•°A,B(0<A,B<P)ï¼Œè¡¨ç¤ºç¼–å·ä¸ºAå’ŒBçš„ä¸¤ç‚¹ä¹‹é—´æœ‰è¿çº¿ã€‚
**è¾“å‡º**
å¦‚æœå­˜åœ¨ç¬¦åˆæ¡ä»¶çš„è¿çº¿ï¼Œåˆ™è¾“å‡º"Yes", å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„è¿çº¿ï¼Œè¾“å‡º"No"ã€‚
**æ ·ä¾‹è¾“å…¥**
 2
4 3
1 2
1 3
1 4
4 5
1 2
2 3
1 3
1 4
3 4
**æ ·ä¾‹è¾“å‡º**
No
Yes
**ä¸€ç¬”ç”»ä¸‹æ¥éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š**

 1. éƒ½åœ¨ä¸€ä¸ªé›†åˆä¸­ã€‚
 2. å¥‡ç‚¹ä¸ªæ•°ä¸ºé›¶æˆ–äºŒã€‚å¥‡ç‚¹æŒ‡è¿™ä¸€ç‚¹æ‰€è¿çº¿æ®µçš„ä¸ªæ•°ï¼Œå¦‚æœèƒ½ä¸€ç¬”ç”»ä¸‹æ¥ï¼Œè¦ä¹ˆæ˜¯ç¯ï¼ˆå¥‡ç‚¹ä¸ºé›¶ï¼‰ï¼Œè¦ä¹ˆèµ·ç‚¹å’Œç»ˆç‚¹åªæœ‰ä¸€å¯¹ï¼ˆå¥‡ç‚¹ä¸ºäºŒï¼‰ã€‚

```c++
#include<iostream>
#include<cstring>
using namespace std;
int pre[2010];
int k[2010];
int find(int x){
	if(pre[x] == x) return x;
	return pre[x] = find(pre[x]);
}
int main(){
	int n,p,q,a,b;
	cin>>n;
	while(n--){
		cin>>p>>q;
		for(int i=1;i<=p;i++){//åˆå§‹åŒ–ï¼Œä½¿èŠ‚ç‚¹æŒ‡å‘å…¶æœ¬èº« 
			pre[i] = i;
		}
		memset(k,0,sizeof(k));
		int ans =0,sum= 0;
		for(int i=1;i<=q;i++){
			cin>>a>>b;
			k[a]++;//è®¡ç®—æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„åº¦æ•° 
			k[b]++; 
			pre[find(a)] = find(b);//åˆ†æ”¯åˆå¹¶ 
		}
		for(int i=1;i<=p;i++){
			if(pre[i] == i){
				ans++;//è®¡ç®—é›†åˆçš„ä¸ªæ•° 
			}
			if(k[i]%2==1){
				sum++;//æ£€æŸ¥å¥‡ç‚¹ä¸ªæ•°ï¼Œè‹¥æ˜¯åˆ™è‡ªå¢ 
			}
		}
		if((ans==1)&&(sum==0||sum==2)){//å¥‡ç‚¹ä¸º0æˆ–2åˆ™è¯´æ˜å¯ä»¥è¿é€šï¼Œåä¹‹ä¸å¯ä»¥ 
			cout<<"Yes"<<endl;
		}else{
			cout<<"No"<<endl;
		}
	}
	return 0;
}
```

# æœ€å°ç”Ÿæˆæ ‘
# æœ€å°ç”Ÿæˆæ ‘ä¾‹é¢˜
## HDU1102Constructing Roadsï¼ˆkruskal/primï¼‰

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 34224    Accepted Submission(s): 12739


**Problem Description**
There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected. 

We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.
 

**Input**
The first line is an integer N (3 <= N <= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.

Then there is an integer Q (0 <= Q <= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 <= a < b <= N), which means the road between village a and village b has been built.
 

**Output**
You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum. 
 

**Sample Input**
3
0 990 692
990 0 179
692 179 0
1
1 2
 

**Sample Output**
179
**kruskal**
```c++
#include<iostream>
#include<algorithm> 
using namespace std;
int pre[100000];//å‚¨å­˜çˆ¶èŠ‚ç‚¹ 
struct node{
	int x,y,len;
}a[10000];
int cmp(node a,node b){//æŒ‰ç…§è·¯ç¨‹å‡åº 
	return a.len < b.len ; 
}
int find(int x){//æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ 
	if(pre[x]==x) return x;
	return pre[x] = find(pre[x]);
}
int main(){
	int n,m,b,c,k;
	while(cin>>n){//æ‘åº„ä¸ªæ•° 
		k = 0;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
			cin>> a[k].len ;//æ‘åº„é•¿åº¦ 
			a[k].x = i; 
			a[k].y = j;
			k++;			
			}
		}
		for(int i=0;i<n;i++){
			pre[i] = i;
		}
		sort(a,a+k,cmp);
		cin>>m;
		for(int i=0;i<m;i++){//å¹¶æŸ¥é›† 
			cin>>b>>c;
			if(find(b-1)!=find(c-1)){//å°†ä¸¤å—åŒºåŸŸè”ç³»èµ·æ¥ 
				pre[find(b-1)] = find(c-1);
			}
		}
		int sum = 0;
		for(int i=0;i<k;i++){
			if(a[i].len > 0){ 
				if(find(a[i].x)!=find(a[i].y)){//åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œå¦‚æœä¸æ˜¯ï¼Œéœ€è¦ä¿®è·¯ 
					sum += a[i].len;//å·²ç»æ’å¥½åºäº†ï¼ŒæŒ‰ç…§è·¯ç¨‹æœ€çŸ­çš„å¼€å§‹ä¿® 
					pre[find(a[i].x)] = find(a[i].y);//ä¿®å¥½è·¯ååˆå¹¶é›†åˆ 
				}
			}
		}
		cout<<sum<<endl;//ç»Ÿè®¡æ‰€ä¿®çš„æœ€çŸ­è·¯ç¨‹ 
	}
} 
```
**prim**
```c++
#include<iostream>
#include<cstring>
#define max_size 100
#define inf 0x3f3f3f3f
using namespace std;
int map[max_size][max_size];
int dis[max_size];
int N,q,a,b;
using namespace std;

//int map[max_size][max_size];    //å›¾çš„é‚»æ¥çŸ©é˜µ
/* é‚»æ¥çŸ©é˜µåœ¨ä½¿ç”¨ä¹‹å‰ä¸€å®šè¦æ˜¯åˆå§‹åŒ–ï¼Œç¡®å®šå½“iå’Œjä¸è¿é€šæ—¶map[i][j]çš„å€¼ */ 

/* primç®—æ³•æ ¸å¿ƒä»£ç ï¼Œä¼ é€’å‚æ•° n æ˜¯èŠ‚ç‚¹ä¸ªæ•°ï¼Œè¿”å›å€¼æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼*/
int prim( int n ) {
	int dis[max_size], sum = 0;    //disä»£è¡¨æ¯ä¸ªèŠ‚ç‚¹ä¸å½“å‰å·²ç»ç”Ÿæˆçš„æ ‘çš„è·ç¦» 
	memset( dis, 0x3f, sizeof( dis ) );    //è¿™å¥è¯ç­‰åŒäºä¸‹é¢æ³¨é‡Šæ‰çš„ä¸€æ®µä»£ç 
	/*
	for( int i = 0; i < max_size; i ++ ) {
		dis[i] = inf;
	}
	*/
	int minn = 0, next = 0;
	/* æ€è€ƒ index == -1 æ—¶ä»£è¡¨äº†ä»€ä¹ˆï¼Ÿ */ 
	for( int index = 0; index != -1; index = next ) {
		sum += minn;
		minn = inf;
		next = -1;
		dis[index] = -1;    //ä»£è¡¨èŠ‚ç‚¹ index å·²ç»åŠ å…¥åˆ°äº†å½“å‰ç”Ÿæˆçš„æœ€å°æ ‘ä¸­ 
		for( int i = 0; i < n; i ++ ) {
			if( map[index][i] < dis[i] ) {
				dis[i] = map[index][i];    //æ›´æ–°èŠ‚ç‚¹iåˆ°å½“å‰ç”Ÿæˆçš„æœ€å°æ ‘çš„è·ç¦» 
			}
			if( minn > dis[i] && dis[i] != -1 ) {    //é€‰å®šä¸‹ä¸€æ¬¡è¦æ·»åŠ çš„èŠ‚ç‚¹ 
				minn = dis[i];
				next = i;
			}
		}
	}
	return sum;
}
int main(){
	while(cin>>N){
		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				cin>>map[i][j];
			}
		}	
		cin>>q;
		for(int i=0;i<q;i++){
			cin>>a>>b;
			map[a-1][b-1] = map[b-1][a-1] = 0;
		}
		int ans = prim(N);
		cout<<ans<<endl;
	}
	return 0;
}
```

**è‡ªå·±å®ç°äº†ä¸€éï¼Œä¸Šé¢çš„å¥—äº†å­¦é•¿æ¨¡æ¿è¯•çš„ï¼ŒåŠ äº†ä¸€äº›æ³¨é‡Šã€‚è‡ªå·±å®ç°çš„æœ‰äº›ç»†èŠ‚æœ‰é—®é¢˜**
```c++
#include<iostream>
#include<cstring>
#define max_size 100
#define inf 0x3f3f3f3f
using namespace std;
int map[max_size][max_size];
int dis[max_size];
int N,q,a,b,c;
using namespace std;
int prim(int x){
	memset(dis,0x3f,sizeof(dis));//åˆå§‹åŒ–
	int next = 0,min = 0,sum = 0;
	for(int index=0;index!=-1;index=next){
		sum += min;//è·å–æƒé‡çš„å’Œ
		next = -1;//å¾ªç¯ç»ˆæ­¢çš„æ¡ä»¶ï¼Œå¦‚æœæ²¡æœ‰ç¬¦åˆä¸‹é¢ä¸¤ä¸ªåˆ¤æ–­çš„æƒ…å†µæ—¶è¯´æ˜æœ€å°ç”Ÿæˆæ ‘å»ºç«‹ï¼Œæ­¤æ—¶å¾ªç¯ç»ˆæ­¢
		min = inf;//åˆå§‹åŒ–
		dis[index] = -1;//æ ‡è®°è¿™ä¸€ç‚¹å·²ç»è¢«ç”¨ 
		for(int i = 0; i < N; i++){
			if(map[index][i] < dis[i]){//å¯ä»¥æ‹¿åˆ°æ‰€æœ‰å’Œè¿™ä¸ªç‚¹æœ‰å…³ç³»ç‚¹çš„è·ç¦»ï¼ŒåŒ…æ‹¬è‡ªèº«å’Œè‡ªèº«ï¼Œå½“ç„¶æ­¤æ—¶ä¸ºé›¶
				dis[i] = map[index][i];
			}
			if(dis[i]!=-1&& min > dis[i]){
				min = dis[i];//è·å–åˆ°è¿™ä¸€ç‚¹å’Œä¸‹ä¸€ç‚¹çš„æœ€çŸ­è·ç¦»
				 next = i;//æ‹¿åˆ°ä¸‹ä¸€ä¸ªç‚¹çš„ä½ç½®
			}
		} 
	}
	return sum;
}
int main(){
	while(cin>>N){
		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				cin>>map[i][j];
			}
		}	
		cin>>q;
		for(int i=0;i<q;i++){
			cin>>a>>b;
			map[a-1][b-1] = map[b-1][a-1] = 0;
		}
		int ans = prim(N);
		cout<<ans<<endl;
	}
	return 0;
}
```

## HDU1863ç•…é€šå·¥ç¨‹ï¼ˆKruskalï¼‰

Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 46147    Accepted Submission(s): 20626


**Problem Description**
çœæ”¿åºœâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡æ˜¯ä½¿å…¨çœä»»ä½•ä¸¤ä¸ªæ‘åº„é—´éƒ½å¯ä»¥å®ç°å…¬è·¯äº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„å…¬è·¯ç›¸è¿ï¼Œåªè¦èƒ½é—´æ¥é€šè¿‡å…¬è·¯å¯è¾¾å³å¯ï¼‰ã€‚ç»è¿‡è°ƒæŸ¥è¯„ä¼°ï¼Œå¾—åˆ°çš„ç»Ÿè®¡è¡¨ä¸­åˆ—å‡ºäº†æœ‰å¯èƒ½å»ºè®¾å…¬è·¯çš„è‹¥å¹²æ¡é“è·¯çš„æˆæœ¬ã€‚ç°è¯·ä½ ç¼–å†™ç¨‹åºï¼Œè®¡ç®—å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚
 

**Input**
æµ‹è¯•è¾“å…¥åŒ…å«è‹¥å¹²æµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬1è¡Œç»™å‡ºè¯„ä¼°çš„é“è·¯æ¡æ•° Nã€æ‘åº„æ•°ç›®M ( < 100 )ï¼›éšåçš„ N 
è¡Œå¯¹åº”æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ªæ‘åº„çš„ç¼–å·ï¼Œä»¥åŠæ­¤ä¸¤æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼ˆä¹Ÿæ˜¯æ­£æ•´æ•°ï¼‰ã€‚ä¸ºç®€å•èµ·è§ï¼Œæ‘åº„ä»1åˆ°Mç¼–å·ã€‚å½“Nä¸º0æ—¶ï¼Œå…¨éƒ¨è¾“å…¥ç»“æŸï¼Œç›¸åº”çš„ç»“æœä¸è¦è¾“å‡ºã€‚
 

**Output**
å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨1è¡Œé‡Œè¾“å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚è‹¥ç»Ÿè®¡æ•°æ®ä¸è¶³ä»¥ä¿è¯ç•…é€šï¼Œåˆ™è¾“å‡ºâ€œ?â€ã€‚
 

**Sample Input**
3 3
1 2 1
1 3 2
2 3 4
1 3
2 3 2
0 100
 

**Sample Output**
3
?

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int pre[110],N,M,k,sum;
struct node{
	int x,y,len;
}a[110];
void Init(){
	for(int i=1;i<=M;i++){
		pre[i] = i;
	}
}
int find(int x){
	return x==pre[x]? x : pre[x] = find(pre[x]);
}
int cmp(node a,node b){
	return a.len < b.len;
}
int main(){
	while(cin>>N>>M&&N!=0){
		Init();
		for(int i=1;i<=N;i++){
			cin>>a[i].x>>a[i].y>>a[i].len;
		}
		k = 0;
		sum = 0;
		sort(a+1,a+N+1,cmp);
		for(int i=1;i<=N;i++){
			if(find(a[i].x) != find(a[i].y)){
				sum += a[i].len;
				pre[find(a[i].x)] = find(a[i].y);
			}
		}
		for(int i=1;i<=M;i++){
			if(pre[i]==i){
				k++;
			}
		}
		if(k>1){
			cout<<"?"<<endl; 
		}else{
			cout<<sum<<endl;
		}
	}
	return 0;
} 
```


## XYNU1384: ç•…é€šå·¥ç¨‹2ï¼ˆKruskalï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 32 MB
æäº¤: 26  è§£å†³: 17
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
çœæ”¿åºœâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡æ˜¯ä½¿å…¨çœä»»ä½•ä¸¤ä¸ªæ‘åº„é—´éƒ½å¯ä»¥å®ç°å…¬è·¯äº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„å…¬è·¯ç›¸è¿ï¼Œåªè¦èƒ½é—´æ¥é€šè¿‡å…¬è·¯å¯è¾¾å³å¯ï¼‰ã€‚ç»è¿‡è°ƒæŸ¥è¯„ä¼°ï¼Œå¾—åˆ°çš„ç»Ÿè®¡è¡¨ä¸­åˆ—å‡ºäº†æœ‰å¯èƒ½å»ºè®¾å…¬è·¯çš„è‹¥å¹²æ¡é“è·¯çš„æˆæœ¬ã€‚ç°è¯·ä½ ç¼–å†™ç¨‹åºï¼Œè®¡ç®—å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚

**è¾“å…¥**
æµ‹è¯•è¾“å…¥åŒ…å«è‹¥å¹²æµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬1è¡Œç»™å‡ºè¯„ä¼°çš„é“è·¯æ¡æ•° Nã€æ‘åº„æ•°ç›®M (N, M < =100 )ï¼›éšåçš„ N è¡Œå¯¹åº”æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ªæ‘åº„çš„ç¼–å·ï¼Œä»¥åŠæ­¤ä¸¤æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼ˆä¹Ÿæ˜¯æ­£æ•´æ•°ï¼‰ã€‚ä¸ºç®€å•èµ·è§ï¼Œæ‘åº„ä»1åˆ°Mç¼–å·ã€‚å½“Nä¸º0æ—¶ï¼Œå…¨éƒ¨è¾“å…¥ç»“æŸï¼Œç›¸åº”çš„ç»“æœä¸è¦è¾“å‡ºã€‚

**è¾“å‡º**
å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨1è¡Œé‡Œè¾“å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚è‹¥ç»Ÿè®¡æ•°æ®ä¸è¶³ä»¥ä¿è¯ç•…é€šï¼Œåˆ™è¾“å‡ºâ€œ?â€ã€‚

**æ ·ä¾‹è¾“å…¥**
 3 4
1 2 1
2 3 2
3 4 3
2 4
1 2 1
3 4 2
0 5
**æ ·ä¾‹è¾“å‡º**
6
?

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int pre[110],N,M,k,sum;
struct node{
	int x,y,len;
}a[110];
void Init(){
	for(int i=1;i<=M;i++){
		pre[i] = i;
	}
}
int find(int x){
	return x==pre[x]? x : pre[x] = find(pre[x]);
}
int cmp(node a,node b){
	return a.len < b.len;
}
int main(){
	while(cin>>N>>M&&N!=0){
		Init();
		for(int i=1;i<=N;i++){
			cin>>a[i].x>>a[i].y>>a[i].len;
		}
		k = 0;
		sum = 0;
		sort(a+1,a+N+1,cmp);
		for(int i=1;i<=N;i++){
			if(find(a[i].x) != find(a[i].y)){
				sum += a[i].len;
				pre[find(a[i].x)] = find(a[i].y);
			}
		}
		for(int i=1;i<=M;i++){
			if(pre[i]==i){
				k++;
			}
		}
		if(k>1){
			cout<<"?"<<endl; 
		}else{
			cout<<sum<<endl;
		}
	}
	return 0;
} 
```
## XYNU1381è¿˜æ˜¯ç•…é€šå·¥ç¨‹ï¼ˆKruskal/primï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 32 MB
æäº¤: 50  è§£å†³: 23
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
        æŸçœè°ƒæŸ¥ä¹¡æ‘äº¤é€šçŠ¶å†µï¼Œå¾—åˆ°çš„ç»Ÿè®¡è¡¨ä¸­åˆ—å‡ºäº†ä»»æ„ä¸¤æ‘åº„é—´çš„è·ç¦»ã€‚çœæ”¿åºœâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡æ˜¯ä½¿å…¨çœä»»ä½•ä¸¤ä¸ªæ‘åº„é—´éƒ½å¯ä»¥å®ç°å…¬è·¯äº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„å…¬è·¯ç›¸è¿ï¼Œåªè¦èƒ½é—´æ¥é€šè¿‡å…¬è·¯å¯è¾¾å³å¯ï¼‰ï¼Œå¹¶è¦æ±‚é“ºè®¾çš„å…¬è·¯æ€»é•¿åº¦ä¸ºæœ€å°ã€‚è¯·è®¡ç®—æœ€å°çš„å…¬è·¯æ€»é•¿åº¦ã€‚

**è¾“å…¥**
        æµ‹è¯•è¾“å…¥åŒ…å«è‹¥å¹²æµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬1è¡Œç»™å‡ºæ‘åº„æ•°ç›®N ( < 100 )ï¼›éšåçš„N(N-1)/2è¡Œå¯¹åº”æ‘åº„é—´çš„è·ç¦»ï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ªæ‘åº„çš„ç¼–å·ï¼Œä»¥åŠæ­¤ä¸¤æ‘åº„é—´çš„è·ç¦»ã€‚ä¸ºç®€å•èµ·è§ï¼Œæ‘åº„ä»1åˆ°Nç¼–å·ã€‚
        å½“Nä¸º0æ—¶ï¼Œè¾“å…¥ç»“æŸï¼Œè¯¥ç”¨ä¾‹ä¸è¢«å¤„ç†ã€‚

**è¾“å‡º**
        å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨1è¡Œé‡Œè¾“å‡ºæœ€å°çš„å…¬è·¯æ€»é•¿åº¦ã€‚

**æ ·ä¾‹è¾“å…¥**
 8
1 2 42
1 3 68
1 4 35
1 5 1
1 6 70
1 7 25
1 8 79
2 3 59
2 4 63
2 5 65
2 6 6
2 7 46
2 8 82
3 4 28
3 5 62
3 6 92
3 7 96
3 8 43
4 5 28
4 6 37
4 7 92
4 8 5
5 6 3
5 7 54
5 8 93
6 7 83
6 8 22
7 8 17
0
**æ ·ä¾‹è¾“å‡º**
82

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int pre[11000],N,k,sum;
struct node{
	int x,y,len;
}a[11000];
void Init(){
	for(int i=1;i<=N;i++){
		pre[i] = i;
	}
}
int find(int x){
	return x==pre[x]? x : pre[x] = find(pre[x]);
}
int cmp(node a,node b){
	return a.len < b.len;
}
int main(){
	while(cin>>N&&N!=0){
		Init();
		for(int i=1;i<=(N*(N-1)/2);i++){
			cin>>a[i].x>>a[i].y>>a[i].len;
		}
		sum = 0;
		sort(a+1,a+(N*(N-1)/2)+1,cmp);
		for(int i=1;i<=(N*(N-1)/2);i++){
			if(find(a[i].x) != find(a[i].y)){
				sum += a[i].len;
				pre[find(a[i].x)] = find(a[i].y);
			}
		}
		cout<<sum<<endl;
	}
	return 0;
} 
```
**prim å·®ç‚¹è¶…æ—¶ï¼**
```c++
Accepted	1233	982MS	1464K	1455 B	G++
#include<iostream>
#include<cstring>
#define max_size 100
#define inf 0x3f3f3f3f
using namespace std;
int map[max_size][max_size];
int dis[max_size];
int N,q,a,b,c;
using namespace std;

//int map[max_size][max_size];    //å›¾çš„é‚»æ¥çŸ©é˜µ
/* é‚»æ¥çŸ©é˜µåœ¨ä½¿ç”¨ä¹‹å‰ä¸€å®šè¦æ˜¯åˆå§‹åŒ–ï¼Œç¡®å®šå½“iå’Œjä¸è¿é€šæ—¶map[i][j]çš„å€¼ */ 

/* primç®—æ³•æ ¸å¿ƒä»£ç ï¼Œä¼ é€’å‚æ•° n æ˜¯èŠ‚ç‚¹ä¸ªæ•°ï¼Œè¿”å›å€¼æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼*/
int prim( int n ) {
	int dis[max_size], sum = 0;    //disä»£è¡¨æ¯ä¸ªèŠ‚ç‚¹ä¸å½“å‰å·²ç»ç”Ÿæˆçš„æ ‘çš„è·ç¦» 
	memset( dis, 0x3f, sizeof( dis ) );    //è¿™å¥è¯ç­‰åŒäºä¸‹é¢æ³¨é‡Šæ‰çš„ä¸€æ®µä»£ç 
	/*
	for( int i = 0; i < max_size; i ++ ) {
		dis[i] = inf;
	}
	*/
	int minn = 0, next = 0;
	/* æ€è€ƒ index == -1 æ—¶ä»£è¡¨äº†ä»€ä¹ˆï¼Ÿ */ 
	for( int index = 0; index != -1; index = next ) {
		sum += minn;
		minn = inf;
		next = -1;
		dis[index] = -1;    //ä»£è¡¨èŠ‚ç‚¹ index å·²ç»åŠ å…¥åˆ°äº†å½“å‰ç”Ÿæˆçš„æœ€å°æ ‘ä¸­ 
		for( int i = 0; i < n; i ++ ) {
			if( map[index][i] < dis[i] ) {
				dis[i] = map[index][i];    //æ›´æ–°èŠ‚ç‚¹iåˆ°å½“å‰ç”Ÿæˆçš„æœ€å°æ ‘çš„è·ç¦» 
			}
			if( minn > dis[i] && dis[i] != -1 ) {    //é€‰å®šä¸‹ä¸€æ¬¡è¦æ·»åŠ çš„èŠ‚ç‚¹ 
				minn = dis[i];
				next = i;
			}
		}
	}
	return sum;
}
int main(){
	while(cin>>N&&N!=0){
		for(int i=0;i<(N*(N-1)/2);i++){
			cin>>a>>b>>c;
			map[a-1][b-1] = map[b-1][a-1] = c;
		}	
//		cin>>q;
//		for(int i=0;i<q;i++){
//			cin>>a>>b;
//			map[a-1][b-1] = map[b-1][a-1] = 0;
//		}
		int ans = prim(N);
		cout<<ans<<endl;
	}
	return 0;
}
```
## XYNU1383: ç»§ç»­ç•…é€šå·¥ç¨‹ï¼ˆKruskal/primï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 32 MB
æäº¤: 20  è§£å†³: 12
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
çœæ”¿åºœâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡æ˜¯ä½¿å…¨çœä»»ä½•ä¸¤ä¸ªæ‘åº„é—´éƒ½å¯ä»¥å®ç°å…¬è·¯äº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„å…¬è·¯ç›¸è¿ï¼Œåªè¦èƒ½é—´æ¥é€šè¿‡å…¬è·¯å¯è¾¾å³å¯ï¼‰ã€‚ç°å¾—åˆ°åŸé•‡é“è·¯ç»Ÿè®¡è¡¨ï¼Œè¡¨ä¸­åˆ—å‡ºäº†ä»»æ„ä¸¤åŸé•‡é—´ä¿®å»ºé“è·¯çš„è´¹ç”¨ï¼Œä»¥åŠè¯¥é“è·¯æ˜¯å¦å·²ç»ä¿®é€šçš„çŠ¶æ€ã€‚ç°è¯·ä½ ç¼–å†™ç¨‹åºï¼Œè®¡ç®—å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚

**è¾“å…¥**
æµ‹è¯•è¾“å…¥åŒ…å«è‹¥å¹²æµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬1è¡Œç»™å‡ºæ‘åº„æ•°ç›®N ( 1< N < 100 )ï¼›éšåçš„ N(N-1)/2 è¡Œå¯¹åº”æ‘åº„é—´é“è·¯çš„æˆæœ¬åŠä¿®å»ºçŠ¶æ€ï¼Œæ¯è¡Œç»™4ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ªæ‘åº„çš„ç¼–å·ï¼ˆä»1ç¼–å·åˆ°Nï¼‰ï¼Œæ­¤ä¸¤æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼Œä»¥åŠä¿®å»ºçŠ¶æ€ï¼š1è¡¨ç¤ºå·²å»ºï¼Œ0è¡¨ç¤ºæœªå»ºã€‚

å½“Nä¸º0æ—¶è¾“å…¥ç»“æŸã€‚

**è¾“å‡º**
æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼Œè¾“å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚

**æ ·ä¾‹è¾“å…¥**
 4
1 2 1 1
1 3 6 0
1 4 2 1
2 3 3 0
2 4 5 0
3 4 4 0
3
1 2 1 1
2 3 2 1
1 3 1 0
0
**æ ·ä¾‹è¾“å‡º**
3
0

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int pre[11000],N,k,sum;
struct node{
	int x,y,len,z;
}a[11000];
void Init(){
	for(int i=1;i<=N;i++){
		pre[i] = i;
	}
}
int find(int x){
	return x==pre[x]? x : pre[x] = find(pre[x]);
}
int cmp(node a,node b){
	return a.len < b.len;
}
int main(){
	while(cin>>N&&N!=0){
		Init();
		for(int i=1;i<=(N*(N-1)/2);i++){
			cin>>a[i].x>>a[i].y>>a[i].len>>a[i].z;
			if(a[i].z){
				if(find(a[i].x)!= find(a[i].y)){
					pre[find(a[i].x)] = find(a[i].y);
				}
			}
		}
		sum = 0;
		sort(a+1,a+(N*(N-1)/2)+1,cmp);
		for(int i=1;i<=(N*(N-1)/2);i++){
			if(find(a[i].x) != find(a[i].y)){
				sum += a[i].len;
				pre[find(a[i].x)] = find(a[i].y);
			}
		}
		cout<<sum<<endl;
	}
	return 0;
} 
```
**prim**
```c++
#include<iostream>
#include<cstring>
#define inf 0x3f3f3f3f
using namespace std;
int map[110][110];
int dis[111110];
int prim(int n){
	memset(dis,0x3f,sizeof(dis));
	int sum = 0,min = 0,next = 0;
	for(int index=1;index!=-1;index = next){//æ³¨æ„èµ·å§‹ç‚¹ä»1å¼€å§‹ 
		sum += min;
		min = inf;
		next = -1;
		dis[index] = -1;
		for(int i=1;i<=n;i++){//ä»1å¼€å§‹ 
			if(dis[i] > map[index][i]){
				dis[i] = map[index][i];
			}
			if(dis[i]!=-1&& min > dis[i]){
				min = dis[i];
				next = i;
			}
		}
	}
	return sum;
}
int main(){
	int n,a,b,c,d;
	while(cin>>n&&n!=0){
		memset(map,0,sizeof(map));
		for(int i=0;i<(n*(n-1)/2);i++){
			scanf("%d%d%d%d",&a,&b,&c,&d);//cinè¶…æ—¶ 
			if(a==b){
				map[a][b] = 0;
			}
			if(d == 0)
			map[a][b] = map [b][a] = c;
			else
			map[a][b] = map [b][a] = 0;
		}
		cout<<prim(n)<<endl;
	}
	return 0;
}
```
## HDU1162Eddy's pictureï¼ˆPrimï¼‰

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 12982    Accepted Submission(s): 6437


**Problem Description**
Eddy begins to like painting pictures recently ,he is sure of himself to become a painter.Every day Eddy draws pictures in his small room, and he usually puts out his newest pictures to let his friends appreciate. but the result it can be imagined, the friends are not interested in his picture.Eddy feels very puzzled,in order to change all friends 's view to his technical of painting pictures ,so Eddy creates a problem for the his friends of you.
Problem descriptions as follows: Given you some coordinates pionts on a drawing paper, every point links with the ink with the straight line, causes all points finally to link in the same place. How many distants does your duty discover the shortest length which the ink draws?
 

**Input**
The first line contains 0 < n <= 100, the number of point. For each point, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the point. 

Input contains multiple test cases. Process to the end of file.
 

**Output**
Your program prints a single real number to two decimal places: the minimum total length of ink lines that can connect all the points. 
 

**Sample Input**
3
1.0 1.0
2.0 2.0
2.0 4.0
 

**Sample Output**
3.41

```c++
//1162 
#include<iostream>
#include<cstring>
#include<cmath>
#define inf 0x3f3f3f3f
using namespace std;
double map[110][110];
double dis[110];
int n;
struct node{
	double x,y;
}a[110];
double prim(int k){
	for(int i=0;i<k;i++){
		dis[i] = inf;
	} 
//	memset(dis,0x3f,sizeof(dis));//æ­¤å¤„ä¸èƒ½ç”¨0x3fæ¥åˆå§‹åŒ–ï¼Œæ­¤æ—¶ä¸ºintå¯¹äºdoubleç”¨forå¾ªç¯æ¥åˆå§‹åŒ– 
	double num = 0,min=0,next = 0;
	for(int index = 0;index!=-1;index = next){
		next = -1;
		num += min;
		min = inf;
		dis[index] = -1;
		for(int i=0;i<k;i++){
			if(map[index][i] < dis[i]){
				dis[i] = map[index][i];
			}
			if(dis[i]!=-1 && min > dis[i]){
				min = dis[i];
				next = i;
			}
		}
	}
	return num;
}
int main(){
	while(cin>>n){	
		for(int i=0;i<n;i++){
			cin>>a[i].x>>a[i].y;
		}
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				if(i==j){
					map[i][j] = 0;
				}else{
				map[i][j] = map[j][i] = sqrt(pow((a[i].x-a[j].x),2)+pow((a[i].y-a[j].y),2));
				}
			}
		}
		printf("%.2lf\n",prim(n));
	}
	return 0;
}
```

```c++
#include<iostream>
#include<cstring>
#include<cmath>
#define inf 0x3f3f3f3f
using namespace std;
double map[110][110];
double dis[110];
int n;
bool vis[105];
struct node{
	double x,y;
}a[110];
double prim(int k)
{
    for(int i=0;i<k;i++)
    {
        dis[i]=map[0][i];
        vis[i]=false;
    }
    dis[0]=0;
    vis[0]=true;
    double ans=0;
    for(int i=1;i<k;i++)
    {
        int p=-1;
        double minn= inf;
        for(int j=0;j<k;j++)
        {
            if(!vis[j]&&dis[j]<minn)
                minn=dis[p=j];
        }
        ans+=minn;
        vis[p]=true;
        for(int j=0;j<k;j++)
        {
            if(!vis[j]&&dis[j]>map[p][j])
                dis[j]=map[p][j];
        }
    }
    return ans;
}
int main(){
	while(cin>>n){	
		for(int i=0;i<n;i++){
			cin>>a[i].x>>a[i].y;
		}
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				if(i==j){
					map[i][j] = 0;
				}else{
				map[i][j] = map[j][i] = sqrt(pow((a[i].x-a[j].x),2)+pow((a[i].y-a[j].y),2));
				}
			}
		}
		printf("%.2lf\n",prim(n));
	}
	return 0;
}
```
## XYNU2177: çˆ±æ—…æ¸¸çš„å°æ˜ï¼ˆdijkstraï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 128 MB
æäº¤: 89  è§£å†³: 39
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
å°æ˜æƒ³å»æ—…æ¸¸ï¼Œä½†æ˜¯äº¤é€šåœ°å›¾ä¸Šçš„è·¯å¤ªå¤šäº†ã€‚è·¯å¤šäº†ä¹Ÿä¸å¥½ï¼Œæ¯æ¬¡è¦ä»ä¸€ä¸ªåŸé•‡åˆ°å¦ä¸€ä¸ªåŸé•‡æ—¶ï¼Œéƒ½æœ‰è®¸å¤šç§é“è·¯æ–¹æ¡ˆå¯ä»¥é€‰æ‹©ï¼Œè€ŒæŸäº›æ–¹æ¡ˆè¦æ¯”å¦ä¸€äº›æ–¹æ¡ˆè¡Œèµ°çš„è·ç¦»è¦çŸ­å¾ˆå¤šã€‚è¿™è®©å°æ˜å¾ˆå›°æ‰°ã€‚

ç°åœ¨ï¼Œå·²çŸ¥èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¯·ä½ è®¡ç®—å‡ºè¦ä»èµ·ç‚¹åˆ°ç»ˆç‚¹ï¼Œæœ€çŸ­éœ€è¦è¡Œèµ°å¤šå°‘è·ç¦»ã€‚
**è¾“å…¥**
æœ¬é¢˜ç›®åŒ…å«å¤šç»„æ•°æ®ï¼Œè¯·å¤„ç†åˆ°æ–‡ä»¶ç»“æŸã€‚
æ¯ç»„æ•°æ®ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°Nå’ŒM(0<N<200,0<M<1000)ï¼Œåˆ†åˆ«ä»£è¡¨ç°æœ‰åŸé•‡çš„æ•°ç›®å’Œå·²ä¿®å»ºçš„é“è·¯çš„æ•°ç›®ã€‚åŸé•‡åˆ†åˆ«ä»¥0ï½N-1ç¼–å·ã€‚
æ¥ä¸‹æ¥æ˜¯Mè¡Œé“è·¯ä¿¡æ¯ã€‚æ¯ä¸€è¡Œæœ‰ä¸‰ä¸ªæ•´æ•°A,B,X(0<=A,B<N,A!=B,0<X<10000),è¡¨ç¤ºåŸé•‡Aå’ŒåŸé•‡Bä¹‹é—´æœ‰ä¸€æ¡é•¿åº¦ä¸ºXçš„åŒå‘é“è·¯ã€‚
å†æ¥ä¸‹ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°S,T(0<=S,T<N)ï¼Œåˆ†åˆ«ä»£è¡¨èµ·ç‚¹å’Œç»ˆç‚¹ã€‚
**è¾“å‡º**
å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¯·åœ¨ä¸€è¡Œé‡Œè¾“å‡ºå°æ˜æœ€çŸ­éœ€è¦è¡Œèµ°çš„è·ç¦»ã€‚å¦‚æœä¸å­˜åœ¨ä»Såˆ°Tçš„è·¯çº¿ï¼Œå°±è¾“å‡º-1.
**æ ·ä¾‹è¾“å…¥**
 3 3
0 1 1
0 2 3
1 2 1
0 2
3 1
0 1 1
1 2
**æ ·ä¾‹è¾“å‡º**
2
-1
**è¿™é“é¢˜æƒ³å¤æ‚äº†ï¼ŒğŸ˜¡**
```c++
#include<iostream>
using namespace std;
int N,M,T,S,a,b,c,ans;
int start[1010];
int end[1010];
#include<memory.h>
#define inf 0x3f3f3f3f
#define max_size 1010

int map[max_size][max_size];

/* dijkstraæ ¸å¿ƒä»£ç ï¼Œå‚æ•°næ˜¯èŠ‚ç‚¹æ€»æ•°ï¼Œstartå’Œendåˆ†åˆ«ä»£è¡¨èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¿”å›èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯ï¼Œèµ·ç‚¹å’Œç»ˆç‚¹ä¸è¿é€šæ—¶è¿”å›-1 */ 
int dijkstra( int start, int end, int n ) {
	int dis[max_size], minn, next;    //disä»£è¡¨å„ä¸ªèŠ‚ç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»ï¼Œinf æ„ä¸ºä¸å¯è¾¾ 
	bool flag[max_size];    //flag[i]==trueè¡¨ç¤ºiåˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»å·²ç»è¢«ç¡®å®š 
	memset( dis, 0x3f, sizeof( dis ) );    // ï¼ï¼ï¼memsetå‡½æ•°ä¸€å®šè¦è°¨æ…ä½¿ç”¨ï¼Œäº†è§£å®ƒçš„è¿è¡Œæœºåˆ¶ï¼ï¼ï¼ 
	memset( flag, false, sizeof( flag ) );
	dis[start] = 0;    //èµ·ç‚¹åˆ°å®ƒæœ¬èº«è·ç¦»ä¸º0
	/*æ€è€ƒä¸€ä¸‹
	ä¸ºä»€ä¹ˆä¸‹é¢çš„forè¯­å¥æ‰§è¡Œæ¡ä»¶æ˜¯ !flag[end] && index != -1
	è¿™ä¸¤ä¸ªæ¡ä»¶éƒ½æ˜¯å¿…é¡»çš„å—
	å¦‚æœè¦å»æ‰ä¸€ä¸ªè¯¥å»æ‰å“ªä¸€ä¸ª
	*/ 
	for( int index = start; !flag[end] && index != -1; index = next ) {
		flag[index] = true;
		minn = inf;
		next = -1;
		for( int i = 0; i <= n; i ++ ) {
			if( dis[i] > dis[index] + map[index][i] ) {
				dis[i] = dis[index] + map[index][i];
			}
			if( dis[i] < minn && !flag[i] ) {
				minn = dis[i];
				next = i;
			}
		}
	}
	if( dis[end] == inf ) {
		return -1;
	}
	return dis[end];
}
int main(){
	while(cin>>N>>M){
		memset(map,inf,sizeof(map));
		for(int i=0;i<M;i++){
			cin>>a>>b>>c;
			if(a==b) map[a][b] = 0;
			map[a][b] = min(map[a][b],c);
			map[b][a] = min(map[b][a],c);
//			map[a][b] = map[b][a] =  c;
		}
		cin>>S>>T;
		ans = dijkstra(S,T,N);
		cout<<ans<<endl;
	}
	return 0;
} 
```
## XYNU1392: æœ€ä¼˜å¸ƒçº¿é—®é¢˜ï¼ˆprimï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 128 MB
æäº¤: 18  è§£å†³: 12
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
å­¦æ ¡æœ‰nå°è®¡ç®—æœºï¼Œä¸ºäº†æ–¹ä¾¿æ•°æ®ä¼ è¾“ï¼Œç°è¦å°†å®ƒä»¬ç”¨æ•°æ®çº¿è¿æ¥èµ·æ¥ã€‚ä¸¤å°è®¡ç®—æœºè¢«è¿æ¥æ˜¯æŒ‡å®ƒä»¬é—´æœ‰æ•°æ®çº¿è¿æ¥ã€‚ç”±äºè®¡ç®—æœºæ‰€å¤„çš„ä½ç½®ä¸åŒï¼Œå› æ­¤ä¸åŒçš„ä¸¤å°è®¡ç®—æœºçš„è¿æ¥è´¹ç”¨å¾€å¾€æ˜¯ä¸åŒçš„ã€‚

    å½“ç„¶ï¼Œå¦‚æœå°†ä»»æ„ä¸¤å°è®¡ç®—æœºéƒ½ç”¨æ•°æ®çº¿è¿æ¥ï¼Œè´¹ç”¨å°†æ˜¯ç›¸å½“åºå¤§çš„ã€‚ä¸ºäº†èŠ‚çœè´¹ç”¨ï¼Œæˆ‘ä»¬é‡‡ç”¨æ•°æ®çš„é—´æ¥ä¼ è¾“æ‰‹æ®µï¼Œå³ä¸€å°è®¡ç®—æœºå¯ä»¥é—´æ¥çš„é€šè¿‡è‹¥å¹²å°è®¡ç®—æœºï¼ˆä½œä¸ºä¸­è½¬ï¼‰æ¥å®ç°ä¸å¦ä¸€å°è®¡ç®—æœºçš„è¿æ¥ã€‚

ç°åœ¨ç”±ä½ è´Ÿè´£è¿æ¥è¿™äº›è®¡ç®—æœºï¼Œä»»åŠ¡æ˜¯ä½¿ä»»æ„ä¸¤å°è®¡ç®—æœºéƒ½è¿é€šï¼ˆä¸ç®¡æ˜¯ç›´æ¥çš„æˆ–é—´æ¥çš„ï¼‰ã€‚
**è¾“å…¥**
è¾“å…¥æ–‡ä»¶wire.inï¼Œç¬¬ä¸€è¡Œä¸ºæ•´æ•°nï¼ˆ2<=n<=100ï¼‰ï¼Œè¡¨ç¤ºè®¡ç®—æœºçš„æ•°ç›®ã€‚æ­¤åçš„nè¡Œï¼Œæ¯è¡Œnä¸ªæ•´æ•°ã€‚ç¬¬x+1è¡Œyåˆ—çš„æ•´æ•°è¡¨ç¤ºç›´æ¥è¿æ¥ç¬¬xå°è®¡ç®—æœºå’Œç¬¬yå°è®¡ç®—æœºçš„è´¹ç”¨ã€‚

**è¾“å‡º**
è¾“å‡ºæ–‡ä»¶wire.outï¼Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å°çš„è¿æ¥è´¹ç”¨ã€‚
**æ ·ä¾‹è¾“å…¥**
 3
0 1 2
1 0 1
2 1 0
**æ ·ä¾‹è¾“å‡º**
2
```c++
#include<iostream>
#include<cstring>
#define max_size 100
#define inf 0x3f3f3f3f
using namespace std;
int map[max_size][max_size];
int dis[max_size];
int N,q,a,b,c;
using namespace std;
int prim(int x){
	memset(dis,0x3f,sizeof(dis));//åˆå§‹åŒ–
	int next = 0,min = 0,sum = 0;
	for(int index=0;index!=-1;index=next){
		sum += min;//è·å–æƒé‡çš„å’Œ
		next = -1;//å¾ªç¯ç»ˆæ­¢çš„æ¡ä»¶ï¼Œå¦‚æœæ²¡æœ‰ç¬¦åˆä¸‹é¢ä¸¤ä¸ªåˆ¤æ–­çš„æƒ…å†µæ—¶è¯´æ˜æœ€å°ç”Ÿæˆæ ‘å»ºç«‹ï¼Œæ­¤æ—¶å¾ªç¯ç»ˆæ­¢
		min = inf;//åˆå§‹åŒ–
		dis[index] = -1;//æ ‡è®°è¿™ä¸€ç‚¹å·²ç»è¢«ç”¨ 
		for(int i = 0; i < x; i++){
			if(map[index][i] < dis[i]){//å¯ä»¥æ‹¿åˆ°æ‰€æœ‰å’Œè¿™ä¸ªç‚¹æœ‰å…³ç³»ç‚¹çš„è·ç¦»ï¼ŒåŒ…æ‹¬è‡ªèº«å’Œè‡ªèº«ï¼Œå½“ç„¶æ­¤æ—¶ä¸ºé›¶
				dis[i] = map[index][i];
			}
			if(dis[i]!=-1&& min > dis[i]){
				min = dis[i];//è·å–åˆ°è¿™ä¸€ç‚¹å’Œä¸‹ä¸€ç‚¹çš„æœ€çŸ­è·ç¦»
				 next = i;//æ‹¿åˆ°ä¸‹ä¸€ä¸ªç‚¹çš„ä½ç½®
			}
		} 
	}
	return sum;
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cin>>map[i][j];
		}
	}
	int ans = prim(n);
	cout<<ans<<endl;
	return 0;
}
```
## XYNU1393: æœ€çŸ­ç½‘ç»œAgri-Netï¼ˆprimï¼‰

æ—¶é—´é™åˆ¶: 1 Sec  å†…å­˜é™åˆ¶: 128 MB
æäº¤: 14  è§£å†³: 11
æ‚¨è¯¥é¢˜çš„çŠ¶æ€ï¼šå·²å®Œæˆ
[æäº¤][çŠ¶æ€][è®¨è®ºç‰ˆ]
**é¢˜ç›®æè¿°**
å†œæ°‘çº¦ç¿°è¢«é€‰ä¸ºä»–ä»¬é•‡çš„é•‡é•¿ï¼ä»–å…¶ä¸­ä¸€ä¸ªç«é€‰æ‰¿è¯ºå°±æ˜¯åœ¨é•‡ä¸Šå»ºç«‹èµ·äº’è”ç½‘ï¼Œå¹¶è¿æ¥åˆ°æ‰€æœ‰çš„å†œåœºã€‚å½“ç„¶ï¼Œä»–éœ€è¦ä½ çš„å¸®åŠ©ã€‚çº¦ç¿°å·²ç»ç»™ä»–çš„å†œåœºå®‰æ’äº†ä¸€æ¡é«˜é€Ÿçš„ç½‘ç»œçº¿è·¯ï¼Œä»–æƒ³æŠŠè¿™æ¡çº¿è·¯å…±äº«ç»™å…¶ä»–å†œåœºã€‚ä¸ºäº†ç”¨æœ€å°çš„æ¶ˆè´¹ï¼Œä»–æƒ³é“ºè®¾æœ€çŸ­çš„å…‰çº¤å»è¿æ¥æ‰€æœ‰çš„å†œåœºã€‚ä½ å°†å¾—åˆ°ä¸€ä»½å„å†œåœºä¹‹é—´è¿æ¥è´¹ç”¨çš„åˆ—è¡¨ï¼Œä½ å¿…é¡»æ‰¾å‡ºèƒ½è¿æ¥æ‰€æœ‰å†œåœºå¹¶æ‰€ç”¨å…‰çº¤æœ€çŸ­çš„æ–¹æ¡ˆã€‚æ¯ä¸¤ä¸ªå†œåœºé—´çš„è·ç¦»ä¸ä¼šè¶…è¿‡100000ã€‚

**è¾“å…¥**
ç¬¬ä¸€è¡Œï¼šå†œåœºçš„ä¸ªæ•°ï¼ŒNï¼ˆ3<=N<=100ï¼‰ã€‚
ç¬¬äºŒè¡Œ..ç»“å°¾:åæ¥çš„è¡ŒåŒ…å«äº†ä¸€ä¸ªN*Nçš„çŸ©é˜µ,è¡¨ç¤ºæ¯ä¸ªå†œåœºä¹‹é—´çš„è·ç¦»ã€‚ç†è®ºä¸Šï¼Œä»–ä»¬æ˜¯Nè¡Œï¼Œæ¯è¡Œç”±Nä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ•°ç»„æˆï¼Œå®é™…ä¸Šï¼Œä»–ä»¬é™åˆ¶åœ¨80ä¸ªå­—ç¬¦ï¼Œå› æ­¤ï¼ŒæŸäº›è¡Œä¼šç´§æ¥ç€å¦ä¸€äº›è¡Œã€‚å½“ç„¶ï¼Œå¯¹è§’çº¿å°†ä¼šæ˜¯0ï¼Œå› ä¸ºä¸ä¼šæœ‰çº¿è·¯ä»ç¬¬iä¸ªå†œåœºåˆ°å®ƒæœ¬èº«ã€‚
è¾“å‡º
åªæœ‰ä¸€ä¸ªè¾“å‡ºï¼Œå…¶ä¸­åŒ…å«è¿æ¥åˆ°æ¯ä¸ªå†œåœºçš„å…‰çº¤çš„æœ€å°é•¿åº¦ã€‚

**æ ·ä¾‹è¾“å…¥**
 4
0 4 9 21
4 0 8 17
9 8 0 16
21 17 16 0
**æ ·ä¾‹è¾“å‡º**
28

```c++
#include<iostream>
#include<cstring>
#define max_size 100
#define inf 0x3f3f3f3f
using namespace std;
int map[max_size][max_size];
int dis[max_size];
int N,q,a,b,c;
using namespace std;
int prim(int x){
	memset(dis,0x3f,sizeof(dis));//åˆå§‹åŒ–
	int next = 0,min = 0,sum = 0;
	for(int index=0;index!=-1;index=next){
		sum += min;//è·å–æƒé‡çš„å’Œ
		next = -1;//å¾ªç¯ç»ˆæ­¢çš„æ¡ä»¶ï¼Œå¦‚æœæ²¡æœ‰ç¬¦åˆä¸‹é¢ä¸¤ä¸ªåˆ¤æ–­çš„æƒ…å†µæ—¶è¯´æ˜æœ€å°ç”Ÿæˆæ ‘å»ºç«‹ï¼Œæ­¤æ—¶å¾ªç¯ç»ˆæ­¢
		min = inf;//åˆå§‹åŒ–
		dis[index] = -1;//æ ‡è®°è¿™ä¸€ç‚¹å·²ç»è¢«ç”¨ 
		for(int i = 0; i < x; i++){
			if(map[index][i] < dis[i]){//å¯ä»¥æ‹¿åˆ°æ‰€æœ‰å’Œè¿™ä¸ªç‚¹æœ‰å…³ç³»ç‚¹çš„è·ç¦»ï¼ŒåŒ…æ‹¬è‡ªèº«å’Œè‡ªèº«ï¼Œå½“ç„¶æ­¤æ—¶ä¸ºé›¶
				dis[i] = map[index][i];
			}
			if(dis[i]!=-1&& min > dis[i]){
				min = dis[i];//è·å–åˆ°è¿™ä¸€ç‚¹å’Œä¸‹ä¸€ç‚¹çš„æœ€çŸ­è·ç¦»
				 next = i;//æ‹¿åˆ°ä¸‹ä¸€ä¸ªç‚¹çš„ä½ç½®
			}
		} 
	}
	return sum;
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cin>>map[i][j];
		}
	}
	int ans = prim(n);
	cout<<ans<<endl;
	return 0;
}
```
# æœ€çŸ­è·¯å¾„
# æœ€çŸ­è·¯å¾„ä¾‹é¢˜
## HDU2544æœ€çŸ­è·¯ï¼ˆdijkstralï¼‰

Time Limit: 5000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 109819    Accepted Submission(s): 47233


**Problem Description**
åœ¨æ¯å¹´çš„æ ¡èµ›é‡Œï¼Œæ‰€æœ‰è¿›å…¥å†³èµ›çš„åŒå­¦éƒ½ä¼šè·å¾—ä¸€ä»¶å¾ˆæ¼‚äº®çš„t-shirtã€‚ä½†æ˜¯æ¯å½“æˆ‘ä»¬çš„å·¥ä½œäººå‘˜æŠŠä¸Šç™¾ä»¶çš„è¡£æœä»å•†åº—è¿å›åˆ°èµ›åœºçš„æ—¶å€™ï¼Œå´æ˜¯éå¸¸ç´¯çš„ï¼æ‰€ä»¥ç°åœ¨ä»–ä»¬æƒ³è¦å¯»æ‰¾æœ€çŸ­çš„ä»å•†åº—åˆ°èµ›åœºçš„è·¯çº¿ï¼Œä½ å¯ä»¥å¸®åŠ©ä»–ä»¬å—ï¼Ÿ

 

**Input**
è¾“å…¥åŒ…æ‹¬å¤šç»„æ•°æ®ã€‚æ¯ç»„æ•°æ®ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°Nã€Mï¼ˆN<=100ï¼ŒM<=10000ï¼‰ï¼ŒNè¡¨ç¤ºæˆéƒ½çš„å¤§è¡—ä¸Šæœ‰å‡ ä¸ªè·¯å£ï¼Œæ ‡å·ä¸º1çš„è·¯å£æ˜¯å•†åº—æ‰€åœ¨åœ°ï¼Œæ ‡å·ä¸ºNçš„è·¯å£æ˜¯èµ›åœºæ‰€åœ¨åœ°ï¼ŒMåˆ™è¡¨ç¤ºåœ¨æˆéƒ½æœ‰å‡ æ¡è·¯ã€‚N=M=0è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚æ¥ä¸‹æ¥Mè¡Œï¼Œæ¯è¡ŒåŒ…æ‹¬3ä¸ªæ•´æ•°Aï¼ŒBï¼ŒCï¼ˆ1<=A,B<=N,1<=C<=1000ï¼‰,è¡¨ç¤ºåœ¨è·¯å£Aä¸è·¯å£Bä¹‹é—´æœ‰ä¸€æ¡è·¯ï¼Œæˆ‘ä»¬çš„å·¥ä½œäººå‘˜éœ€è¦Cåˆ†é’Ÿçš„æ—¶é—´èµ°è¿‡è¿™æ¡è·¯ã€‚
è¾“å…¥ä¿è¯è‡³å°‘å­˜åœ¨1æ¡å•†åº—åˆ°èµ›åœºçš„è·¯çº¿ã€‚
 

**Output**
å¯¹äºæ¯ç»„è¾“å…¥ï¼Œè¾“å‡ºä¸€è¡Œï¼Œè¡¨ç¤ºå·¥ä½œäººå‘˜ä»å•†åº—èµ°åˆ°èµ›åœºçš„æœ€çŸ­æ—¶é—´
 

**Sample Input**
2 1
1 2 3
3 3
1 2 5
2 3 5
3 1 2
0 0
 

**Sample Output**
3
2
```c++
#include<iostream>
#include<cstring>
#define max_size 110//æ•°ç»„ä¸è¦å¼€å¤ªå¤§ï¼Œç¬¬ä¸€æ¬¡æ²¡ä»”ç»†çœ‹å¼€äº†10010ï¼Œç„¶åå†…å­˜è¶…é™ 
#define inf 0x3f3f3f3f 
using namespace std; 
int map[max_size][max_size];
int dijkstral(int start,int end,int n){
	int dis[max_size],min,next;
	bool flag[max_size];
	memset(dis,0x3f,sizeof(dis));
	memset(flag,false,sizeof(flag));
	dis [start] = 0;
	for(int index = start; index != -1 ; index = next){
		flag [index] = true;
		min = inf;
		next = -1;
		for(int i = 1;i <= n;i++){
			if(dis[i] > map[index][i] + dis[index]){
				dis[i] = map[index][i] + dis [index];
			}
			if(!flag[i] && dis[i] < min){
				min  = dis[i];
				next = i;
			}
		}
		}
		if(dis[end] == inf){
			return -1;
		}
		return dis[end];
	}
	int main(){
		int N,M,a,b,c;
		while(cin>> N >> M && N!=0 && M!=0){
			memset(map,0x3f,sizeof(map));
			for ( int i= 1 ; i <= M ; i++){
				cin >> a >> b >> c ;
				if(a==b){ 
				map [a][b] = 0;
				}
				else {
				map [a][b] = min(map[a][b],c);
				map [b][a] = min(map[b][a],c);				
				}
			}
			cout<<dijkstral(1,N,N)<<endl;
		}
		return 0;
	} 
```
