
# 操作系统

## 操作系统的基本特征

并发，共享，虚拟，异步。

* **并发**是指在一段时间内同时运行多个程序。
* **共享**是分为同时共享和互斥共享，互斥共享也被称为临界资源，也就是同一时刻内只允许一个进程访问。
* **虚拟**分为时分复用技术和空分复用技术。

时分复用是指每个进程可以占用 CPU 一段时间，交替执行。实现了一个处理器上并发执行。

对于空分复用，例如虚拟内存，每个进程都有独立的地址空间，地址空间被映射到物理地址上。如果内存不够用就执行页面置换算法(LRU)。

* **异步**是指交错执行，走走停停向前推进，双方没有同步的时钟。


## 死锁

死锁的四个条件

1. 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
3. 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
4. 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

> 首先是资源是互斥的，也就是资源只能被一个进程占用，其次占用了后想要别的进程的资源于是等待，资源不能被抢占，最后是环路等待，资源形成了一个环。

死锁处理主要有以下四种方法：

1. 鸵鸟策略：也就是忽略。
2. 死锁检测与死锁恢复：通过检测有向图是否存在环来实现，深搜，访问过后就标记一下，一旦访问到标记过的那么一定有环。可以通过抢占，回滚，杀死进程来实现恢复。
3. 死锁预防：
   1. 破坏互斥：例如假脱机技术。
   2. 破坏占有和等待条件，在进程开始之前一口气把资源都要完。
4. 死锁避免：银行家算法。


## 静态链接、动态链接的区别
- 静态链接：在编译时将所有需要的库和程序代码一起打包，生成可执行文件。这意味着，如果需要更新或修改库，必须重新编译整个程序。
- 动态链接：程序在运行时加载所需的库，并与程序代码进行链接。这意味着，如果需要更新或修改库，可以直接替换动态链接库，而不必重新编译整个程序。
- 总的来说，动态链接更灵活，但可执行文件体积较大，而静态链接则相反。

## 操作系统如何处理中断？

操作系统处理中断的过程通常包括以下几个步骤：
- 中断响应：当外部设备需要处理时，会发送一个中断信号给处理器，处理器通过中断控制器获取中断请求，并将中断请求发送给操作系统。操作系统通过中断描述符表中的中断处理程序地址来响应中断请求。
- 中断处理程序执行：中断处理程序是由操作系统提供的，用于处理中断请求。在响应中断请求后，操作系统会将处理器的控制权转移到中断处理程序，并保存处理器的状态。中断处理程序执行的任务包括保存中断现场，执行中断处理程序的逻辑，处理中断设备的数据，恢复处理器状态等。
- 中断处理程序结束：中断处理程序执行完后，操作系统将处理器的控制权交还给被中断的进程，通过状态恢复来恢复被中断进程的执行现场，继续执行原来的程序流程。

需要注意的是，不同类型的中断有不同的中断处理程序，操作系统需要根据不同类型的中断来执行不同的中断处理程序。同时，在执行中断处理程序的过程中，操作系统需要保证操作的原子性和正确性，避免出现不一致的现象。


## 一个进程切换到另一个进程，如何找到另一个进程要执行的地址？

在进行进程切换时，操作系统需要找到另一个进程要执行的地址，一般有两种方式：

- 使用进程控制块（Process Control Block, PCB）：PCB是操作系统维护进程信息的数据结构，其中保存了当前进程的状态、寄存器内容、堆栈指针等信息。当进行进程切换时，操作系统会根据另一个进程的PCB来恢复该进程的状态，包括其要执行的地址。因此，可以通过访问另一个进程的PCB来获取该进程要执行的地址。

- 使用调度算法：操作系统还可以通过调度算法来选择要切换的进程，并确定该进程要执行的地址。调度算法是操作系统为了实现进程调度而采用的一系列算法，包括先来先服务、时间片轮转、优先级调度等。当进程切换时，操作系统会根据当前的调度算法来选择要执行的下一个进程，并确定该进程要执行的地址。例如，在时间片轮转算法中，操作系统会按照一定的时间片来轮流执行各个进程，在进行进程切换时，操作系统会根据时间片结束的状态来确定下一个进程要执行的地址。

## 进程间通信方式？
- 管道
- 消息队列
- 共享内存
- 信号量
- socket通信
- 信号
- 匿名管道

## 进程中的一个线程崩了，会引发进程崩吗？
- 有可能崩溃，也有可能不崩溃。
- 如果线程和线程独立不会崩溃，如果线程是主线程或负责其他关键任务会导致进程奔溃。
- 如果进程存在错误处理机制，在线程崩溃时保护其他线程，可以防止进程崩溃。

## 互斥锁，信号量使用的场景区别
- 前者线程互斥，后者线程同步
同步和互斥的区别并举例
同步和互斥是多线程编程中常用的概念，它们的区别如下：

同步（Synchronization）：指协调多个线程的执行顺序，以确保它们按照一定的逻辑顺序执行，从而避免竞争条件和死锁等问题。同步机制的主要目的是为了保证线程之间的数据一致性。

互斥（Mutual Exclusion）：指限制某些共享资源在同一时刻只能被一个线程访问，以避免出现多个线程同时修改同一个资源的问题。互斥机制的主要目的是为了避免多个线程同时访问同一个临界资源而导致数据的不一致性。

下面举个例子来说明它们的区别：

假设有两个线程 A 和 B 都要对一个变量 x 进行修改。如果不加任何同步或互斥机制，那么可能会出现以下情况：

线程 A 和 B 同时读取 x 的值；
线程 A 计算新值 x+1；
线程 B 计算新值 x+2；
线程 A 将新值写回变量 x；
线程 B 将新值写回变量 x。
在这种情况下，最终变量 x 的值可能是 x+1 或 x+2，具体取决于线程的执行顺序。为了避免这种问题，可以使用互斥锁来限制同时只能有一个线程访问变量 x，这样就可以避免数据不一致的问题。而为了确保线程 A 和 B 的执行顺序符合预期，可以使用信号量或条件变量等同步机制来实现。


## 互斥锁，读写锁，自旋锁的区别

- 互斥锁、读写锁和自旋锁是多线程编程中常用的同步机制，它们的区别如下：
  - 互斥锁（Mutex）：用于保护临界区，同一时间只允许一个线程访问共享资源。当一个线程持有互斥锁时，其他线程需要等待锁被释放后才能访问共享资源。
  - 读写锁（Reader-Writer Lock）：与互斥锁类似，用于保护共享资源。但与互斥锁不同的是，读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这样可以提高读取共享资源的并发性能。
  - 自旋锁（Spin Lock）：与互斥锁类似，也用于保护共享资源。但与互斥锁不同的是，当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，它会不断地循环等待，直到获取到锁为止。自旋锁适用于短时间内需要保护的共享资源，可以避免线程上下文切换的开销。
  - 简单来说，互斥锁和读写锁主要区别在于读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源，而自旋锁则是一种特殊的互斥锁，它避免了线程上下文切换的开销，适用于短时间内需要保护的共享资源。
  - 需要注意的是，使用不当或者过度使用这些同步机制可能会导致性能下降或死锁等问题，因此在使用时需要谨慎考虑。

## 互斥锁和自旋锁的区别？ 
- 互斥锁和自旋锁的区别？
  - 自旋锁（Spinlock）则是在用户空间中实现的一种锁，它不会将线程阻塞，而是让线程在一个循环中自旋等待锁的释放。因此，自旋锁适用于锁的持有时间短，等待锁的时间短的情况，比如对共享数据结构进行简短的修改。
  - 总的来说，互斥锁适用于等待锁的时间较长，而自旋锁适用于等待锁的时间较短。
- 自旋锁和互斥锁异同？
  - 自旋锁和互斥锁都是用来实现多线程同步的机制，但它们有一些区别：
  - 相同点：都是用来保护临界区，防止多个线程同时访问或修改共享资源。
  - 不同点：
    - 实现方式不同：互斥锁使用操作系统提供的原语（如信号量、互斥量等）实现，自旋锁是基于忙等待的实现方式，不涉及操作系统的调度机制。
    - 等待机制不同：当锁被其他线程占用时，互斥锁会让线程进入睡眠状态，等待锁被释放，而自旋锁则会一直占用 CPU 资源自旋等待锁被释放。
    - 适用场景不同：自旋锁适用于锁竞争不激烈、临界区执行时间短的情况，而互斥锁适用于锁竞争激烈、临界区执行时间长的情况。

总的来说，自旋锁和互斥锁各有优劣，具体使用哪种锁要根据具体的应用场景进行选择。

- 怎么实现自旋锁
  - 说了原子操作 test and set 指令（tsl）

## 进程，线程，协程优缺点分析？

- 进程产生的原因？
  - 在没有进程之前是无法实现进程调度的，也就是一个程序必须执行完才能切换到下一个程序。
  - 进程实现了多道程序并发运行，也就是程序运行到一半可以暂停，从而实现调度。通过时分复用从而实现并发。
  - 进程切换开销大，进程和进程之间都是独立的地址空间，需要复制并保存大量数据。

- 线程产生的原因？
  - 为了解决进程开销大，从而引入了线程。线程是进程内的执行单元，一个进程中包含多个线程，线程切换只需要切换栈，寄存器和 PC 等少量信息即可。
  - 此外线程提供了更细粒度的资源管理和并发控制，可以充分利用多核 CPU 的性能。
  - 并且线程切换涉及到内核态。因为线程切换需要切换上下文信息，这些操作需要访问内核资源。

- 协程产生的原因？
  - 协程进一步降低了线程的开销，调度不受 OS 影响，由应用程序控制，可以在一个线程内部实现并发。
  - 在一个线程内部实现并发避免了线程之间的竞争和死锁问题，同时协程之间的切换开销下。
  - 协程是如何降低线程开销的？
    - 协程切换不涉及内核上下文切换，不用转为内核态。
    - 协程可以避免线程之间的锁竞争，提高程序的并发性。

- 从线程解决了进程的缺点的角度来看，线程可以共享进程的资源，避免了创建和销毁进程的开销，同时线程的切换开销比进程小，可以更加高效地实现并发操作。从协程解决了线程的缺点的角度来看，协程可以在同一线程中实现并发操作，避免了线程之间的竞争和死锁等问题，同时协程之间的切换开销也非常小，避免了线程上下文切换的开销。

## 进程和线程的区别？

- 进程是资源分配的最小单位，线程是独立调度的最小单位。

- 线程是独立调度的基本单位，线程的开销远小于进程的开销，线程内通信共享，线程外通信需要借助 OS 。

## 线程间共享什么资源？
- 内存：所有线程都可以共享进程的地址空间，可以访问同一份数据和代码。
- 文件描述符：在一个进程中打开的文件描述符可以在多个线程之间共享，因此可以实现多个线程对同一个文件的访问。
- 共享变量：多个线程可以同时访问同一个共享变量，需要通过同步机制来避免竞争条件，如互斥锁、条件变量等。
- 共享资源：多个线程可以共享许多系统资源，如套接字、数据库连接等。
- 需要注意的是，在多线程编程中，线程间共享的资源需要考虑同步和互斥问题，否则可能会导致数据不一致、死锁等问题。因此，在设计多线程程序时需要注意同步和互斥机制的设计，确保线程之间的安全并发访问。

虚拟内存和物理内存的差别，为什么要用虚拟内存？
-   虚拟内存有哪些部分？
    -   八股文
    -   内核区、用户区
    -   用户区有代码段、数据段、堆栈段（中间还有个文件映射区）
-   虚拟内存的查询流程
    -   说了下二级页表查询



4．进程调度。switch函数、调度器线程、时间片、优先级、CFS、红黑树。



## 哪些场景下不能用线程只能用进程？

尽管多线程可以在很多情况下提高程序的性能和响应性，但是有些情况下需要使用进程来代替线程。以下是一些不能使用线程只能使用进程的场景：

- 安全性要求高的场景：如果多个线程需要访问同一块内存空间，可能会出现数据竞争和死锁等问题，这些问题可以使用同步机制解决，但是线程之间的同步机制往往比较复杂，如果安全性要求比较高，那么使用多个进程更好，因为进程之间是相互独立的，不会出现数据竞争和死锁问题。
- 资源隔离要求高的场景：如果需要在程序中隔离不同的资源，例如网络连接、文件描述符等，那么使用多个进程比使用多个线程更好，因为进程可以使用操作系统提供的隔离机制，而线程之间共享进程的资源，无法进行隔离。
- 可伸缩性要求高的场景：在某些情况下，程序需要在多台机器上运行，这就需要程序具有良好的可伸缩性。在这种情况下，使用多个进程比使用多个线程更好，因为进程可以在不同的机器上运行，而线程只能在同一台机器上运行。
- 并发处理任务不相关的场景：如果并发处理的任务之间没有关系，也就是说它们是独立的，那么使用多个进程比使用多个线程更好，因为进程之间是相互独立的，可以利用多核CPU提高处理效率。

总之，在选择线程或进程时，需要根据具体的场景和需求来做出选择。如果安全性、资源隔离和可伸缩性要求高，或者任务之间相互独立，那么使用进程更好。如果需要在同一块内存空间中并发执行任务，并且任务之间需要共享数据，那么使用线程更好。