# 数组




1、给一棵树和一个sum，判断是否存在从root到叶子结点的path之和等于sum？

2、LRU的实现（双向链表+哈希）？

两个字符串求最长公共子串？



1、上面LRU在多线程时存在什么问题？如何解决？用锁来解决，如何提高效率？举个例子：os里的pagecache页面换入换出，多线程下如何提高效率？
存在的问题：

线程不安全：LRUCache类的成员函数get和put在多线程环境下可能会导致数据竞争和不一致性，因为多个线程可能同时访问和修改LRUCache对象的内部状态。
数据竞争：多个线程同时访问和修改LRUCache对象的cache_、head_、tail_等成员变量，可能导致数据竞争和未定义行为。
解决办法：

在LRUCache类中添加一个互斥锁成员变量，用于保护LRUCache对象的访问和修改。
在LRUCache类的成员函数中，使用互斥锁对LRUCache对象的访问和修改进行加锁和解锁操作，确保在任意时刻只有一个线程可以访问和修改LRUCache对象。
在对LRUCache对象进行访问和修改的地方使用互斥锁进行保护，包括对cache_、head_、tail_等成员变量的访问和修改。
提高效率的办法：

细粒度锁：尽量使用细粒度的锁，即只锁定必要的数据，而不是对整个数据结构进行加锁。这样可以减小锁的粒度，提高并发访问性能。
读写锁：针对读多写少的场景，可以考虑使用读写锁（Read-Write Lock），读操作可以并发进行，写操作需要独占锁。这样可以提高读操作的并发性能。
无锁数据结构：对于一些高并发的场景，可以考虑使用无锁数据结构（Lock-Free Data Structures）或者无锁算法（Lock-Free Algorithms）。这些数据结构和算法不依赖锁来实现并发访问，通过原子操作等机制来确保并发访问的正确性，可以提高并发性能。
锁粒度控制：在并发访问时，需要根据实际情况控制锁的粒度，避免过度加锁导致性能下降。可以通过对代码进行分析和优化，减少锁的持有时间，提高并发性能。
合理的并发控制：对于一些共享资源，可以通过合理的并发控制机制来限制并发访问的数量，避免过多的线程竞争导致性能下降。
缓存优化：对于一些计算密集型的任务，可以考虑使用缓存来减少计算量，提高性能。通过缓存的方式，可以避免重复计算，提高并发访问的效率。


4、磁盘IO？什么情况下会发生磁盘IO？
磁盘I/O（Input/Output）指的是计算机系统与磁盘进行数据交换的过程。磁盘I/O通常涉及读取和写入磁盘上的数据，用于存储和检索文件、程序等信息。

文件读取：当应用程序需要访问磁盘上的文件时，会发起文件读取的磁盘I/O操作。例如，打开一个文件、读取文件内容等都会触发磁盘I/O。
文件写入：当应用程序需要向磁盘上的文件写入数据时，会发起文件写入的磁盘I/O操作。例如，向文件中写入新数据、修改文件内容等都会触发磁盘I/O。
虚拟内存交换：当系统的物理内存不足以容纳当前运行的所有进程和数据时，操作系统会使用磁盘作为虚拟内存的交换空间。在内存页被交换到磁盘或从磁盘交换回内存时，会发生磁盘I/O。
系统启动和关闭：在计算机启动或关闭时，会涉及到读取和写入系统配置信息、日志文件等操作，这些都会触发磁盘I/O。
数据库操作：数据库系统经常需要读取和写入大量的数据到磁盘上的数据库文件中，因此数据库操作通常会频繁地触发磁盘I/O。



5、Direct IO？
Direct IO（直接I/O）是一种绕过操作系统缓存（页缓存）直接访问磁盘的I/O方式。在使用Direct IO时，数据直接从应用程序的内存缓冲区（用户空间）直接读取到磁盘或者从磁盘直接写入到应用程序的内存缓冲区，而不经过操作系统的页缓存。这种方式可以避免数据在用户空间和内核空间之间的复制，从而提高I/O操作的效率和响应速度。

Direct IO的主要特点包括：

绕过页缓存：使用Direct IO时，数据直接在应用程序的用户空间和磁盘之间传输，不经过操作系统的页缓存。这意味着每次I/O操作都需要直接访问磁盘，而不会利用操作系统的缓存机制。
减少数据复制：由于Direct IO避免了数据在用户空间和内核空间之间的复制，因此可以减少数据复制的开销，提高I/O操作的效率。
适用于大量数据的读写：Direct IO适用于需要大量数据读写的场景，例如数据库系统、文件服务器等，这些场景需要高效地处理大量数据而不受到操作系统缓存的影响。
需要特权权限：由于Direct IO绕过了操作系统的缓存，因此通常需要特权权限（如root权限）才能够使用。这是因为直接访问磁盘可能会绕过操作系统的权限控制，存在一定的安全风险。
适用性限制：Direct IO并不适用于所有场景，它通常在对I/O性能要求较高、需要绕过操作系统缓存、对数据一致性要求较高的场景下使用。在一些需要利用操作系统缓存提高性能的场景下，Direct IO并不适用。



6、buffer read？
"Buffered read"（缓冲读取）是一种通过在内存中设置缓冲区来提高读取操作效率的技术。在进行文件或数据读取时，通常会涉及到频繁的I/O操作，而这些操作可能会对性能产生一定的影响。通过使用缓冲读取，可以减少实际的I/O操作次数，从而提高读取的效率。

缓冲读取的工作原理如下：

设置缓冲区：在进行读取操作之前，先在内存中分配一块缓冲区，用于临时存储从文件或数据源中读取的数据。
批量读取：通过适当的缓冲区大小设置，可以实现批量读取的操作。即使是需要读取大量数据的情况下，也可以将数据分批次读取到缓冲区中，减少了对磁盘的频繁访问，提高了读取效率。
减少系统调用：缓冲读取可以减少系统调用的次数。在没有缓冲的情况下，每次读取都会导致系统调用，而使用缓冲读取可以将多个读取操作合并为一次系统调用，减少了系统调用的开销。
顺序读取优化：缓冲读取可以优化顺序读取的性能。当进行顺序读取时，缓冲读取可以预先读取一定量的数据到缓冲区中，以便后续的读取操作能够直接从缓冲区中获取数据，而不需要再次访问磁盘。


7、有两个文件，key文件和record文件，key文件2G，record文件很大无法读入内存，如何做到随机访问记录？
由于record文件很大无法一次性读入内存，我们可以通过索引的方式实现随机访问记录。

具体步骤：

创建索引文件：首先，我们可以针对record文件创建一个索引文件，索引文件中存储着每个记录在record文件中的位置信息（偏移量）。这样，我们就可以通过索引文件快速定位到某个记录在record文件中的位置。
索引结构设计：索引文件的结构可以根据实际需求设计，常见的索引结构包括哈希表、B树、B+树等。选择合适的索引结构可以提高随机访问的效率。
读取记录：当需要随机访问某个记录时，我们首先根据索引文件找到对应记录在record文件中的位置（偏移量），然后通过文件随机访问的方式读取该记录。由于索引文件通常较小且能够加载到内存中，因此可以快速定位到记录在record文件中的位置，实现随机访问。
更新索引：如果record文件中的记录发生变化（新增、删除、修改等操作），需要同步更新索引文件，保持索引与record文件的一致性。
性能考虑：在设计索引时需要考虑性能因素，如索引文件的大小、索引结构的选择、索引文件的存储方式（如内存缓存、磁盘存储）、索引的更新频率等，以提高随机访问记录的效率和性能。



10、高效进程通信？
管道（Pipe）：管道是一种单向通信机制，常用于父子进程之间或者具有亲缘关系的进程之间的通信。管道通过操作系统提供的内核缓冲区进行数据传输，性能较高，但只能用于具有亲缘关系的进程之间。
命名管道（Named Pipe）：命名管道是一种具有名称的管道，允许不具有亲缘关系的进程之间进行通信。它通过文件系统提供的特殊文件实现通信，可以在文件系统中创建，提供了一种高效的进程间通信方式。
信号量（Semaphore）：信号量是一种用于进程间同步和互斥的机制，可以用于控制多个进程对共享资源的访问。信号量通常用于实现进程之间的互斥访问和同步操作，保证多个进程之间的数据一致性和安全性。
消息队列（Message Queue）：消息队列是一种可以实现进程间通信的机制，允许进程通过消息传递进行通信。消息队列可以实现进程之间的异步通信，适用于需要高效传递大量数据的场景。
共享内存（Shared Memory）：共享内存是一种进程间通信的方式，允许多个进程共享同一块内存区域，可以实现高效的数据共享和传输。共享内存通常用于需要频繁读写大量数据的场景，能够提供较高的性能和效率。
套接字（Socket）：套接字是一种网络通信的接口，也可以用于进程间通信。套接字通常用于网络编程，但也可以在本地进程间进行通信，提供了一种灵活而高效的进程通信方式。




11、如何减少加锁、使用信号量？

使用读写锁：读写锁是一种特殊的锁机制，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁适用于读操作频繁、写操作较少的场景，可以提高并发性能。

使用无锁数据结构：一些特定的数据结构，如无锁队列、无锁栈等，可以在不使用锁的情况下实现并发访问。这些数据结构通常基于原子操作或者比较交换指令实现，并发性能较高。

使用信号量：信号量是一种广泛用于进程间同步和互斥的机制，也可以用于线程间的同步和互斥。通过合理使用信号量，可以控制多个线程对共享资源的访问，避免竞态条件和死锁等问题。

避免长时间持有锁：尽量避免长时间持有锁，可以通过将锁的粒度调整得更小，或者采用非阻塞的锁机制，减少锁的持有时间，提高并发性能。

使用乐观并发控制：乐观并发控制是一种基于版本号或者时间戳的并发控制机制，允许多个线程同时访问共享资源，只在写入时进行互斥控制。这种机制适用于读操作远远多于写操作的场景，可以提高并发性能。


TIME_WAIT？
TIME_WAIT 是 TCP 协议的一种状态，表示连接已经被正常关闭，但是仍然在等待一段时间（称为 TIME_WAIT 时间）才会彻底关闭。TIME_WAIT 状态通常出现在主动关闭连接的一方，在发送了 FIN 报文之后，等待对方确认的阶段。

TIME_WAIT 状态的存在是为了确保已经关闭的连接的最后一个数据包能够被对方正确接收和处理。在这个状态下，连接的一方会保持一段时间的等待，在这段时间内不会再接收到来自对方的数据，但是可以处理对方在关闭连接时可能发送的重传数据包，以确保数据的可靠传输。

TIME_WAIT 状态的持续时间通常由操作系统内核参数决定，一般情况下是 2 倍的最大报文段生存时间（Maximum Segment Lifetime，MSL）。MSL 是一个固定的时间值，通常为 2 分钟，它表示一个 TCP 报文在网络中最长的生存时间。

TIME_WAIT 状态的存在有一些作用和影响：

确保连接的最后数据包能够被正确处理，避免了数据包的丢失或者混乱。
防止旧的重复数据包被误认为是新的连接。
可以让已经关闭的连接在一段时间内不能被重新使用，避免了连接复用时出现的问题。




6、服务端大量连接处于TIME_WAIT状态会影响服务器性能，如何处理？

调整内核参数：可以通过修改操作系统的内核参数来调整 TIME_WAIT 状态的处理。例如，可以调整 net.ipv4.tcp_tw_reuse 参数为 1，表示允许将 TIME_WAIT 状态的连接用于新的连接。这样可以减少 TIME_WAIT 状态连接占用的资源。
调整连接超时时间：可以调整操作系统的 TCP 连接超时时间，减少 TIME_WAIT 状态的持续时间。可以通过修改 net.ipv4.tcp_fin_timeout 参数来调整，默认值为 60 秒，可以根据实际情况进行调整。
增加服务器资源：如果服务器资源允许，可以通过增加服务器的内存和处理器等资源来缓解 TIME_WAIT 状态带来的影响。这样服务器就能够更好地处理大量的 TIME_WAIT 状态连接。
优化应用程序：如果可能的话，可以优化应用程序的设计和实现，减少连接的建立和关闭次数，从而减少 TIME_WAIT 状态连接的数量。
使用连接池：对于需要频繁连接数据库或者其他服务的应用程序，可以考虑使用连接池技术，减少连接的建立和关闭次数，从而减少 TIME_WAIT 状态连接的数量。


8、GDB多线程调试？

给个示例步骤：

编译程序时开启调试信息：在编译程序时，需要使用 -g 参数来开启调试信息，这样 GDB 才能够正确地识别源代码和进行调试。
启动 GDB：在命令行中输入 gdb 命令启动 GDB 调试器，然后使用 file 命令加载要调试的可执行文件。
设置断点：使用 break 命令在要调试的代码行设置断点。如果你知道要调试的函数名，也可以直接使用 break function_name 来设置断点。
启动程序：使用 run 命令启动程序，GDB 会在程序运行到断点处停止。
查看线程信息：使用 info threads 命令查看当前程序中的线程信息，可以查看线程的 ID、状态等信息。
切换线程：使用 thread <thread_id> 命令切换到指定的线程，然后可以使用 backtrace 命令查看该线程的调用栈。
观察变量：在断点处停止后，可以使用 print 命令观察变量的值，也可以使用 watch 命令设置监视点，当变量的值发生变化时自动停止程序。
继续执行：使用 continue 命令继续执行程序，直到下一个断点或者程序结束。
退出 GDB：在调试结束后，使用 quit 命令退出 GDB 调试器。

9、遇到过Coredump吗，怎么排查原因的？
Coredump 是指当一个程序发生严重错误（如段错误、内存访问错误等）时，操作系统会将程序的内存转储（Dump）到一个文件中，这个文件就是 coredump 文件。这个文件包含了程序崩溃时的内存状态，可以通过分析 coredump 文件来定位程序崩溃的原因。

给一个参考的排查 coredump 的步骤：

获取 coredump 文件：当程序发生崩溃时，操作系统会在当前工作目录或者指定的目录下生成一个 coredump 文件。首先需要获取这个文件，可以通过配置系统使其生成 coredump 文件，或者在程序崩溃时手动获取。
分析 coredump 文件：可以使用 GDB 或者其他调试工具来分析 coredump 文件。首先需要加载 coredump 文件到调试器中，然后可以使用 bt 命令查看调用栈，定位程序崩溃的位置。通过查看调用栈可以找到导致崩溃的函数调用链，从而定位问题所在。
查看内存状态：在分析 coredump 文件时，可以查看程序崩溃时的内存状态，包括堆栈、寄存器状态、内存中的变量值等。这些信息可以帮助分析程序崩溃的原因。
重现问题：如果可能的话，可以尝试重现程序崩溃的问题。在开发环境中调试程序，通过输入相同的输入数据或者执行相同的操作，尝试重现程序崩溃的场景，从而更好地分析问题。
排查代码逻辑：根据分析的结果，可以进一步排查代码逻辑，查找可能的 bug。可以通过代码审查、单元测试等方式来找出程序中的问题。
修复问题：一旦找到了程序崩溃的原因，就可以对程序进行修复。修复的方式可能包括修改代码逻辑、增加错误处理代码、优化内存管理等。


10、进程、线程、协程？
进程（Process）：
进程是操作系统分配资源的基本单位，每个进程拥有独立的地址空间、内存、文件描述符等资源。
进程之间的通信需要通过进程间通信（IPC）机制，如管道、信号量、消息队列等。
进程之间的切换开销较大，因为需要切换地址空间、内存映射、文件描述符等资源。
线程（Thread）：
线程是进程中的执行单元，同一进程内的线程共享相同的地址空间和资源。
线程之间的通信比进程间通信更加高效，可以直接访问共享的内存空间。
线程之间的切换开销较小，因为线程共享相同的地址空间和资源，切换时不需要切换这些资源。
协程（Coroutine）：
协程是一种用户态的轻量级线程，可以在同一个线程内实现并发执行。
协程通过 yield 和 resume 操作来实现在不同代码段之间的切换，可以在一个线程内实现多个任务的并发执行。
协程通常比线程更加轻量级，切换开销更小，适合于高并发、高性能的场景。





12、了解RPC、zookeeper吗？
RPC（Remote Procedure Call）

RPC 是一种远程过程调用的机制，允许一个程序调用另一个地址空间（通常是另一台机器上）的过程或方法，就像调用本地的过程一样。RPC 通常用于构建分布式系统，它隐藏了底层通信细节，使得远程调用看起来像是本地调用。

RPC 的基本原理是客户端调用远程过程时，本地的 RPC 客户端代理会将调用封装成网络消息，并发送给远程的 RPC 服务器。远程的 RPC 服务器接收到消息后，执行对应的过程，并将结果返回给客户端。整个过程对于客户端来说就像调用本地函数一样，对于开发者来说隐藏了网络通信的复杂性。

常见的 RPC 框架包括 gRPC、Apache Thrift、Dubbo 等，它们提供了丰富的功能，如多语言支持、序列化协议、负载均衡等，可以帮助开发者构建可靠的分布式系统。

ZooKeeper

ZooKeeper 是一个开源的分布式协调服务，主要用于解决分布式系统中的一致性、配置管理、命名服务、分布式锁等问题。它提供了简单的文件系统接口，可以用于存储和管理分布式系统的配置信息，同时也提供了高性能和可靠的分布式锁服务，用于协调分布式系统中的各个节点。

ZooKeeper 的核心概念包括以下几点：

节点（Node）：ZooKeeper 中的基本数据单元，类似于文件系统中的文件或目录。
ZNode：ZooKeeper 中的节点，每个节点都有一个路径标识，可以包含数据和子节点。
Watcher：Watcher 是一种事件通知机制，可以用于监视节点的状态变化，并在节点状态发生变化时通知客户端。
临时节点（Ephemeral Node）：临时节点是一种特殊的节点，它在创建它的客户端会话结束后自动删除。
ZooKeeper 提供了简单而强大的 API，可以用于创建、删除、读取和更新节点，并且支持事务操作。它还具有高可用性和高性能的特点，适用于构建大规模分布式系统中的协调服务。

13、C++11的function和bind？
std::function

std::function 是一个通用的函数封装器，可以用来包装任何可以调用的目标，例如普通函数、函数指针、成员函数指针、lambda 表达式等。它可以将函数的调用和实现分离，使得函数对象可以像普通对象一样传递、存储和调用。

使用 std::function 需要指定函数的签名，即函数的参数类型和返回类型。以下是 std::function 的基本用法：

#include <functional>
#include <iostream>

// 普通函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 使用 std::function 封装普通函数
    std::function<int(int, int)> func = add;

    // 调用封装的函数
    std::cout << func(1, 2) << std::endl;  // 输出 3

    return 0;
}
例子中，std::function<int(int, int)> 表示一个参数为两个 int 类型，返回类型为 int 的函数对象。func 封装了 add 函数，并可以像普通函数一样进行调用。

std::bind

std::bind 是一个用于参数绑定的函数模板，可以将函数的部分参数绑定到指定的值，生成一个新的可调用对象。它可以用于延迟求值、改变函数的参数顺序等场景。

以下是 std::bind 的基本用法：

#include <functional>
#include <iostream>

// 函数模板
template <typename T>
void print(const T& t) {
    std::cout << t << std::endl;
}

int main() {
    // 使用 std::bind 绑定函数参数
    auto func = std::bind(print<int>, 123);

    // 调用绑定后的函数
    func();  // 输出 123

    return 0;
}

例子中，std::bind(print<int>, 123) 绑定了 print 函数的第一个参数为 123，生成了一个新的可调用对象 func，调用 func() 就相当于调用了 print<int>(123)。



3、拷贝构造函数可以传值吗？
拷贝构造函数是一种特殊的构造函数，用于在创建对象时，通过复制另一个同类型对象的值来初始化新对象。拷贝构造函数通常有一个参数，表示要复制的对象的引用。在 C++ 中，拷贝构造函数的参数可以是值传递或引用传递。

值传递的拷贝构造函数

class MyClass {
public:
    int data;

    // 值传递的拷贝构造函数
    MyClass(int val) : data(val) {}

    // 拷贝构造函数
    MyClass(const MyClass obj) : data(obj.data) {}
};
例子中，MyClass 类有一个拷贝构造函数，它的参数 obj 是按值传递的。这种方式虽然可以正常工作，但是会带来一些性能上的开销，因为在调用拷贝构造函数时会将整个对象进行复制。因此，通常情况下更推荐使用引用传递的方式来定义拷贝构造函数。

引用传递的拷贝构造函数

class MyClass {
public:
    int data;

    // 引用传递的拷贝构造函数
    MyClass(int val) : data(val) {}

    // 拷贝构造函数
    MyClass(const MyClass& obj) : data(obj.data) {}
};
例子中，MyClass 类的拷贝构造函数的参数 obj 是通过引用传递的。这样做的好处是在调用拷贝构造函数时不会产生额外的拷贝开销，因为只是传递了对象的引用，而不是整个对象的副本。



12、智能指针？
std::shared_ptr：

原理：std::shared_ptr是基于引用计数的智能指针，用于管理动态分配的对象。它维护一个引用计数，当计数为零时，释放对象的内存。

使用场景：适用于多个智能指针需要共享同一块内存的情况。例如，在多个对象之间共享某个资源或数据。

std::shared_ptr<int> sharedInt = std::make_shared<int>(42);
std::shared_ptr<int> anotherSharedInt = sharedInt; // 共享同一块内存
std::unique_ptr：

原理：std::unique_ptr是独占式智能指针，意味着它独占拥有所管理的对象，当其生命周期结束时，对象会被自动销毁。

使用场景：适用于不需要多个指针共享同一块内存的情况，即单一所有权。通常用于资源管理，例如动态分配的对象或文件句柄。

std::unique_ptr<int> uniqueInt = std::make_unique<int>(42);
// uniqueInt 的所有权是唯一的
std::weak_ptr：

原理：std::weak_ptr是一种弱引用指针，它不增加引用计数。它通常用于协助std::shared_ptr，以避免循环引用问题。

使用场景：适用于协助解决std::shared_ptr的循环引用问题，其中多个shared_ptr互相引用，导致内存泄漏。

std::shared_ptr<int> sharedInt = std::make_shared<int>(42);
std::weak_ptr<int> weakInt = sharedInt;
std::auto_ptr（已废弃）：

原理：std::auto_ptr是C++98标准引入的智能指针，用于独占地管理对象。但由于其存在潜在的问题，已在C++11中被废弃。

使用场景：在C++98标准中，可用于独占性地管理动态分配的对象。不推荐在现代C++中使用。

std::auto_ptr<int> autoInt(new int(42)); // 已废弃


14、一道shell题目：查询访问时间过长的ip？

要查询访问时间过长的 IP，可以借助 Linux 系统下的 awk 和 sort 命令来实现。假设我们有一个名为 access.log 的日志文件，其中记录了每次访问的 IP 和访问时间。

我们可以通过以下步骤来查询访问时间过长的 IP：

首先使用 awk 命令从日志文件中提取出 IP 和访问时间，并计算访问时间的差值（假设以秒为单位），然后输出到一个临时文件中。假设日志文件的格式为 IP 访问时间，并且访问时间的格式为 YYYY-MM-DD HH:MM:SS，可以使用如下命令：
awk '{split($2, a, /[\[\]:]/); "date -d\""a[2]" "a[3]"\""| getline d; print $1, $2, systime()-mktime(d)}' access.log > temp.log
命令中，split($2, a, /[\[\]:]/) 用于将访问时间按照 [、]、: 进行分割，并将结果保存到数组 a 中；"date -d\""a[2]" "a[3]"\""| getline d 用于将访问时间转换为时间戳；systime()-mktime(d) 用于计算当前时间与访问时间的差值。

然后使用 sort 命令对临时文件中的记录按照访问时间的差值进行排序，并输出到另一个临时文件中：
sort -k3 -n temp.log > sorted_temp.log
命令中，-k3 表示按照第三列进行排序（即访问时间的差值），-n 表示按照数值进行排序。

最后使用 awk 命令输出访问时间超过阈值的 IP：
awk '{if ($3 > 60) print $1}' sorted_temp.log
命令中，if ($3 > 60) 表示筛选出访问时间超过 60 秒的记录，并输出对应的 IP。

三面（25min）
4、10亿条搜索记录，怎么搭建搜索引擎，怎么构建索引
5、10亿条搜索记录能放在同一台机器上吗，怎么解决
6、两道智力题：64匹马赛跑8个赛道最少几次找到前4名；8个电灯开关每次操作3个最少几次关完