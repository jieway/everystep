### 异常、中断、Trap

在 RISC-V 架构中，异常（Exception）、中断（Interrupt）和陷阱（Trap）是三个不同但相关的概念，它们在处理器执行期间处理外部事件时有着不同的角色和机制。

1. **异常（Exception）：**

   - 异常是由程序内部引起的，与执行指令相关的事件。这可能包括除零、访问非法地址、浮点溢出等。异常是同步事件，即与指令的执行直接相关。当异常发生时，处理器会跳转到相应的异常处理例程，执行一系列指定的操作，然后返回到正常的执行流程。

2. **中断（Interrupt）：**

   - 中断是由处理器外部的异步事件引起的，这些事件可能来自外设、时钟等。中断使得处理器能够响应来自外部设备或其他处理器的信号。当中断发生时，处理器会暂停当前执行的指令，保存上下文，然后跳转到中断处理例程执行。处理完中断处理例程后，处理器返回到原先被中断的执行点。

3. **陷阱（Trap）：**
   - 陷阱是一种有意引发的异常，通常用于系统调用或调试目的。陷阱是由执行特殊指令（例如系统调用指令）而产生的，它允许软件请求内核提供某些服务。与异常相似，陷阱也是同步事件，但是它是由软件主动触发的。处理器在执行陷阱指令时会跳转到相应的陷阱处理例程，执行相应的操作，然后返回到正常的执行流程。

总的来说，异常是程序执行中的同步事件，中断是异步事件，而陷阱是由软件主动触发的同步事件。在 RISC-V 中，这三个概念都通过异常处理机制来进行处理，但它们的触发条件和处理方式有所不同。

使用异常来表示 hart 在运行某一条指令时所遇到的异常状况，使用中断来表示能够引起 RISC-V hart 进行控制权转移的外部事件，使用“陷阱”（trap）表示由异常或者中断引起的控制权转移。

### 异常类型

RISC-V 定义了 14 种异常类型，这些异常类型包括各种可能影响程序执行流程的情况。

```cpp
  enum class ExceptionType {
    InstructionAddrMisaligned, // 指令地址未对齐
    InstructionAccessFault, // 指令访问错误
    IllegalInstruction, // 非法指令
    Breakpoint, // 断点
    LoadAccessMisaligned, // 加载访问未对齐
    LoadAccessFault, // 加载访问错误
    StoreAMOAddrMisaligned, // 存储或原子内存操作地址未对齐
    StoreAMOAccessFault, // 存储或原子内存操作访问错误
    EnvironmentCallFromUMode, // 用户模式环境调用
    EnvironmentCallFromSMode, // 监督模式环境调用
    EnvironmentCallFromMMode, // 机器模式环境调用
    InstructionPageFault, // 指令页错误
    LoadPageFault, // 加载页错误
    StoreAMOPageFault, // 存储或原子内存操作页错误
  };
```

上面一个异常对应一个异常值，这个数字会写入 stval 或 mtval 中。

## MTVAL

在 RISC-V 架构中，`mtval`（Memory Trap Value）是一个寄存器，用于存储关于最近一次内存异常的附加信息。具体而言，`mtval` 保存了导致异常的内存访问的地址或者其他相关信息，以便在异常处理过程中提供更多的上下文和帮助软件定位问题。

在异常处理流程中，当发生内存相关的异常（例如加载或存储访问错误）时，异常处理器会将引起异常的内存地址或其他相关信息写入 `mtval` 寄存器。这使得软件能够检查异常的详细情况并采取适当的措施，例如修复错误、记录日志或终止程序的执行。

具体的使用方式和具体信息的存储方式可能会根据异常类型和实际的 RISC-V 实现而有所不同。例如，在加载或存储访问错误的情况下，`mtval` 中可能包含引起错误的内存地址。在其他类型的异常中，`mtval` 可能包含其他有关异常原因的信息。

总体而言，`mtval` 是在异常处理过程中提供额外信息的一种机制，帮助软件更有效地处理和诊断异常情况。在异常处理例程中，程序员可以检查 `mtval` 寄存器以获取导致异常的具体信息，并根据需要采取适当的措施。

### Cpu::handle_exception

在 CPU 中增加一个成员方法 `Cpu::handle_exception` 用于专门处理异常。

当异常发生时，首先获取当前的程序计数器（PC）和模式，然后检查当前模式是否小于或等于 Supervisor （即是否在用户模式或监管者模式中），并且异常是否被委托给监管者模式。如果是，那么在监管者模式中处理异常，否则在机器模式中处理异常。

在处理异常的过程中，会设置相关的寄存器和掩码，更新程序计数器（PC）和异常程序计数器（EPC），并将异常的原因和值存储在相应的寄存器中。最后，它会更新并存储状态寄存器的值。

这个方法的主要目的是根据异常的类型和当前的模式，来决定如何处理异常，以确保 CPU 能够正确地处理异常并继续执行。
