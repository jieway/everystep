<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Lab 5 (Chinese) - everystep</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../../favicon.svg">
    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/style.css">


</head>
<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">ç®€ä»‹</a></li><li class="chapter-item affix "><li class="part-title">ğŸ­ æ“ä½œç³»ç»Ÿ</li><li class="spacer"></li><li class="chapter-item "><a href="../../6.S081/0-summary.html"><strong aria-hidden="true">1.</strong> 6.S081</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../6.S081/1-lab1.html"><strong aria-hidden="true">1.1.</strong> Lab 1</a></li><li class="chapter-item "><a href="../../6.S081/2-lab2.html"><strong aria-hidden="true">1.2.</strong> Lab 2</a></li><li class="chapter-item "><a href="../../6.S081/3-lab3.html"><strong aria-hidden="true">1.3.</strong> Lab 3</a></li><li class="chapter-item "><a href="../../6.S081/4-lab4.html"><strong aria-hidden="true">1.4.</strong> Lab 4</a></li><li class="chapter-item "><a href="../../6.S081/5-lab5.html"><strong aria-hidden="true">1.5.</strong> Lab 5</a></li><li class="chapter-item "><a href="../../6.S081/6-lab6.html"><strong aria-hidden="true">1.6.</strong> Lab 6</a></li><li class="chapter-item "><a href="../../6.S081/7-lab7.html"><strong aria-hidden="true">1.7.</strong> Lab 7</a></li><li class="chapter-item "><a href="../../6.S081/8-lab8.html"><strong aria-hidden="true">1.8.</strong> Lab 8</a></li><li class="chapter-item "><a href="../../6.S081/9-lab9.html"><strong aria-hidden="true">1.9.</strong> Lab 9</a></li><li class="chapter-item "><a href="../../6.S081/10-lab10.html"><strong aria-hidden="true">1.10.</strong> Lab 10</a></li><li class="chapter-item "><a href="../../6.S081/11-lab11.html"><strong aria-hidden="true">1.11.</strong> Lab 11</a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸš€ æ•°æ®åº“</li><li class="spacer"></li><li class="chapter-item "><a href="../../bitcask/index.html"><strong aria-hidden="true">2.</strong> ä»é›¶å®ç° BitCask å­˜å‚¨å¼•æ“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.1.</strong> BitCask ç®€ä»‹</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.2.</strong> åˆ›å»º C++ é¡¹ç›®</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.3.</strong> æ•°æ®åœ¨å†…å­˜ä¸­</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.4.</strong> æ•°æ®åœ¨ç£ç›˜ä¸Š</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.5.</strong> BenchMark</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.6.</strong> å®ç°åˆå¹¶</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.7.</strong> å®ç°åƒåœ¾å›æ”¶</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.8.</strong> hintfile å®ç°</a></li><li class="chapter-item "><a href="../../bitcask/p1.html"><strong aria-hidden="true">2.9.</strong> å“ˆå¸Œè¡¨ä¼˜åŒ–ä¸ºå¤šçº¿ç¨‹</a></li><li class="chapter-item "><a href="../../bitcask/ch1.html"><strong aria-hidden="true">2.10.</strong> æ•°æ®åœ¨ç£ç›˜ä¸Šå¦‚ä½•å­˜æ”¾ï¼Ÿ</a></li><li class="chapter-item "><a href="../../bitcask/ch2.html"><strong aria-hidden="true">2.11.</strong> å­˜å‚¨å¼•æ“çš„æ¥å£è®¾è®¡</a></li><li class="chapter-item "><a href="../../bitcask/ch3.html"><strong aria-hidden="true">2.12.</strong> å®ç° Setã€Get</a></li><li class="chapter-item "><a href="../../bitcask/ch4.html"><strong aria-hidden="true">2.13.</strong> åˆ é™¤é€»è¾‘å’Œ Compact </a></li></ol></li><li class="chapter-item "><a href="../../abyssdb/p0.html"><strong aria-hidden="true">3.</strong> ä»é›¶å®ç°å…³ç³»å‹æ•°æ®åº“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../abyssdb/p1.html"><strong aria-hidden="true">3.1.</strong> ä» Table å¼€å§‹</a></li><li class="chapter-item "><a href="../../abyssdb/p2.html"><strong aria-hidden="true">3.2.</strong> Part 2. å®ç° Tuple</a></li><li class="chapter-item "><a href="../../abyssdb/p3.html"><strong aria-hidden="true">3.3.</strong> Part 3. å®ç° Page</a></li><li class="chapter-item "><a href="../../abyssdb/p4.html"><strong aria-hidden="true">3.4.</strong> Part 4. å®ç° HeapFile</a></li><li class="chapter-item "><a href="../../abyssdb/p5.html"><strong aria-hidden="true">3.5.</strong> Part 5. å®ç° BufferPool</a></li><li class="chapter-item "><a href="../../abyssdb/p6.html"><strong aria-hidden="true">3.6.</strong> Part 6. æ”¯æŒ int å’Œ string ç­‰æ•°æ®ç±»å‹ã€‚</a></li><li class="chapter-item "><a href="../../abyssdb/p7.html"><strong aria-hidden="true">3.7.</strong> Part 7. å®ç° Catalog</a></li></ol></li><li class="chapter-item expanded "><a href="../../6.830/1-lab0.html"><strong aria-hidden="true">4.</strong> 6.830</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../6.830/ans/2-lab1-ans.html"><strong aria-hidden="true">4.1.</strong> Lab 1 Answers</a></li><li class="chapter-item "><a href="../../6.830/ans/3-lab2-ans.html"><strong aria-hidden="true">4.2.</strong> Lab 2 Answers</a></li><li class="chapter-item "><a href="../../6.830/ans/4-lab3-ans.html"><strong aria-hidden="true">4.3.</strong> Lab 3 Answers</a></li><li class="chapter-item "><a href="../../6.830/ans/5-lab4-ans.html"><strong aria-hidden="true">4.4.</strong> Lab 4 Answers</a></li><li class="chapter-item "><a href="../../6.830/ans/6-lab5-ans.html"><strong aria-hidden="true">4.5.</strong> Lab 5 Answers</a></li><li class="chapter-item "><a href="../../6.830/ans/7-lab6-ans.html"><strong aria-hidden="true">4.6.</strong> Lab 6 Answers</a></li><li class="chapter-item "><a href="../../6.830/cn/2-lab1.html"><strong aria-hidden="true">4.7.</strong> Lab 1 (Chinese)</a></li><li class="chapter-item "><a href="../../6.830/cn/3-lab2.html"><strong aria-hidden="true">4.8.</strong> Lab 2 (Chinese)</a></li><li class="chapter-item "><a href="../../6.830/cn/4-lab3.html"><strong aria-hidden="true">4.9.</strong> Lab 3 (Chinese)</a></li><li class="chapter-item "><a href="../../6.830/cn/5-lab4.html"><strong aria-hidden="true">4.10.</strong> Lab 4 (Chinese)</a></li><li class="chapter-item expanded "><a href="../../6.830/cn/6-lab5.html" class="active"><strong aria-hidden="true">4.11.</strong> Lab 5 (Chinese)</a></li><li class="chapter-item "><a href="../../6.830/cn/7-lab6.html"><strong aria-hidden="true">4.12.</strong> Lab 6 (Chinese)</a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸ§Š åˆ†å¸ƒå¼</li><li class="spacer"></li><li class="chapter-item "><a href="../../6.824/0-lab0.html"><strong aria-hidden="true">5.</strong> 6.824</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../6.824/1-lab1-cn.html"><strong aria-hidden="true">5.1.</strong> Lab 1 (Chinese)</a></li><li class="chapter-item "><a href="../../6.824/1-lab1.html"><strong aria-hidden="true">5.2.</strong> Lab 1</a></li><li class="chapter-item "><a href="../../6.824/2-lab2-cn.html"><strong aria-hidden="true">5.3.</strong> Lab 2 (Chinese)</a></li><li class="chapter-item "><a href="../../6.824/2-lab2.html"><strong aria-hidden="true">5.4.</strong> Lab 2</a></li></ol></li><li class="chapter-item "><li class="part-title">ğŸ”¥ å…¶ä»–</li><li class="spacer"></li><li class="chapter-item "><a href="../../6.828/0-sum.html"><strong aria-hidden="true">6.</strong> 6.828</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../6.828/1-env.html"><strong aria-hidden="true">6.1.</strong> Environment Setup</a></li><li class="chapter-item "><a href="../../6.828/1-part1.html"><strong aria-hidden="true">6.2.</strong> Part 1</a></li></ol></li><li class="chapter-item "><a href="../../review/1_go.html"><strong aria-hidden="true">7.</strong> å…«è‚¡</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../review/2_cpp.html"><strong aria-hidden="true">7.1.</strong> C++</a></li><li class="chapter-item "><a href="../../review/3_cn.html"><strong aria-hidden="true">7.2.</strong> Computer Networks</a></li></ol></li><li class="chapter-item "><a href="../../lsm/index.html"><strong aria-hidden="true">8.</strong> ä»é›¶å®ç° LSM-Tree å­˜å‚¨å¼•æ“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lsm/ch1.html"><strong aria-hidden="true">8.1.</strong> Part 1</a></li><li class="chapter-item "><a href="../../lsm/ch2.html"><strong aria-hidden="true">8.2.</strong> Part 2</a></li><li class="chapter-item "><a href="../../lsm/ch3.html"><strong aria-hidden="true">8.3.</strong> Part 3</a></li><li class="chapter-item "><a href="../../lsm/ch4.html"><strong aria-hidden="true">8.4.</strong> Part 4</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">everystep</h1>

                <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/weijiew/everystep" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/weijiew/everystep/edit/master/src/6.830/cn/6-lab5.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                }); 

                // Mark viewed after 30s
                setTimeout(function() {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc"><nav class="pagetoc"></nav></div>
                <main>
                    <h1 id="lab-5-ç¿»è¯‘"><a class="header" href="#lab-5-ç¿»è¯‘">Lab 5 ç¿»è¯‘</a></h1>
<p>Assigned: Wednesday, April 21, 2021
Due: Tuesday, May 4, 2021 11:59 PM EDT</p>
<h2 id="0-introduction"><a class="header" href="#0-introduction">0. Introduction</a></h2>
<p>In this lab you will implement a B+ tree index for efficient lookups and range scans. We supply you with all of the low-level code you will need to implement the tree structure. You will implement searching, splitting pages, redistributing tuples between pages, and merging pages.</p>
<p>åœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œä½ å°†å®ç°ä¸€ä¸ªB+æ ‘å½¢ç´¢å¼•ï¼Œç”¨äºé«˜æ•ˆçš„æŸ¥æ‰¾å’ŒèŒƒå›´æ‰«æã€‚æˆ‘ä»¬ä¸ºä½ æä¾›äº†å®ç°æ ‘å½¢ç»“æ„æ‰€éœ€çš„æ‰€æœ‰åº•å±‚ä»£ç ã€‚ä½ å°†å®ç°æœç´¢ã€æ‹†åˆ†é¡µé¢ã€åœ¨é¡µé¢ä¹‹é—´é‡æ–°åˆ†é… tuple ä»¥åŠåˆå¹¶é¡µé¢ã€‚</p>
<p>You may find it helpful to review sections 10.3--10.7 in the textbook, which provide detailed information about the structure of B+ trees as well as pseudocode for searches, inserts and deletes.</p>
<p>ä½ å¯èƒ½ä¼šå‘ç°å¤ä¹ æ•™ç§‘ä¹¦ä¸­çš„ç¬¬10.3--10.7èŠ‚å¾ˆæœ‰å¸®åŠ©ï¼Œè¿™äº›ç« èŠ‚æä¾›äº†å…³äºB+æ ‘ç»“æ„çš„è¯¦ç»†ä¿¡æ¯ï¼Œä»¥åŠæœç´¢ã€æ’å…¥å’Œåˆ é™¤çš„ä¼ªä»£ç ã€‚</p>
<p>As described by the textbook and discussed in class, the internal nodes in B+ trees contain multiple entries, each consisting of a key value and a left and a right child pointer. Adjacent keys share a child pointer, so internal nodes containing m keys have m+1 child pointers. Leaf nodes can either contain data entries or pointers to data entries in other database files. For simplicity, we will implement a B+tree in which the leaf pages actually contain the data entries. Adjacent leaf pages are linked together with right and left sibling pointers, so range scans only require one initial search through the root and internal nodes to find the first leaf page. Subsequent leaf pages are found by following right (or left) sibling pointers.</p>
<p>æ­£å¦‚æ•™ç§‘ä¹¦æ‰€æè¿°çš„å’Œè¯¾å ‚ä¸Šè®¨è®ºçš„ï¼ŒB+æ ‘çš„å†…éƒ¨èŠ‚ç‚¹åŒ…å«å¤šä¸ªæ¡ç›®ï¼Œæ¯ä¸ªæ¡ç›®ç”±ä¸€ä¸ªé”®å€¼å’Œä¸€ä¸ªå·¦ã€å³å­æŒ‡é’ˆç»„æˆã€‚ç›¸é‚»çš„é”®å…±äº«ä¸€ä¸ªå­æŒ‡é’ˆï¼Œæ‰€ä»¥åŒ…å«mä¸ªé”®çš„å†…éƒ¨èŠ‚ç‚¹æœ‰m+1ä¸ªå­æŒ‡é’ˆã€‚å¶å­èŠ‚ç‚¹å¯ä»¥åŒ…å«æ•°æ®æ¡ç›®æˆ–æŒ‡å‘å…¶ä»–æ•°æ®åº“æ–‡ä»¶çš„æ•°æ®æ¡ç›®çš„æŒ‡é’ˆã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªB+æ ‘ï¼Œå…¶ä¸­å¶å­é¡µå®é™…ä¸ŠåŒ…å«æ•°æ®æ¡ç›®ã€‚ç›¸é‚»çš„å¶å­é¡µç”¨å·¦å³çš„åŒçº§æŒ‡é’ˆè¿æ¥åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥èŒƒå›´æ‰«æåªéœ€è¦é€šè¿‡æ ¹èŠ‚ç‚¹å’Œå†…éƒ¨èŠ‚ç‚¹è¿›è¡Œä¸€æ¬¡åˆå§‹æœç´¢å°±å¯ä»¥æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¶å­é¡µã€‚éšåçš„å¶å­é¡µæ˜¯é€šè¿‡è·Ÿéšå³ï¼ˆæˆ–å·¦ï¼‰åŒçº§æŒ‡é’ˆæ‰¾åˆ°çš„ã€‚</p>
<h2 id="1-getting-started"><a class="header" href="#1-getting-started">1. Getting started</a></h2>
<p>You should begin with the code you submitted for Lab 4 (if you did not submit code for Lab 4, or your solution didn't work properly, contact us to discuss options). Additionally, we are providing extra source and test files for this lab that are not in the original code distribution you received.</p>
<p>ä½ åº”è¯¥ä»ä½ ä¸ºå®éªŒ4æäº¤çš„ä»£ç å¼€å§‹ï¼ˆå¦‚æœä½ æ²¡æœ‰ä¸ºå®éªŒ4æäº¤ä»£ç ï¼Œæˆ–è€…ä½ çš„è§£å†³æ–¹æ¡ˆæ²¡æœ‰æ­£å¸¸å·¥ä½œï¼Œè¯·ä¸æˆ‘ä»¬è”ç³»ï¼Œè®¨è®ºå„ç§æ–¹æ¡ˆï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜ä¸ºè¿™ä¸ªå®éªŒæä¾›äº†é¢å¤–çš„æºæ–‡ä»¶å’Œæµ‹è¯•æ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶ä¸åœ¨ä½ æ”¶åˆ°çš„åŸå§‹ä»£ç åˆ†å‘ä¸­ã€‚</p>
<p>You will need to add these new files to your release and set up your lab4 branch. The easiest way to do this is to change to your project directory (probably called simple-db-hw), set up the branch, and pull from the master GitHub repository:</p>
<p>ä½ éœ€è¦æŠŠè¿™äº›æ–°æ–‡ä»¶æ·»åŠ åˆ°ä½ çš„ç‰ˆæœ¬ä¸­ï¼Œå¹¶å»ºç«‹ä½ çš„lab4åˆ†æ”¯ã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯åˆ‡æ¢åˆ°ä½ çš„é¡¹ç›®ç›®å½•ï¼ˆå¯èƒ½å«simple-db-hwï¼‰ï¼Œå»ºç«‹åˆ†æ”¯ï¼Œç„¶åä»GitHubçš„ä¸»ä»“åº“æ‹‰å–ã€‚</p>
<pre><code>$ cd simple-db-hw $ git pull upstream master
</code></pre>
<h2 id="2-search"><a class="header" href="#2-search">2. Search</a></h2>
<p>Take a look at index/ and BTreeFile.java. This is the core file for the implementation of the B+Tree and where you will write all your code for this lab. Unlike the HeapFile, the BTreeFile consists of four different kinds of pages. As you would expect, there are two different kinds of pages for the nodes of the tree: internal pages and leaf pages. Internal pages are implemented in BTreeInternalPage.java, and leaf pages are implemented in BTreeLeafPage.java. For convenience, we have created an abstract class in BTreePage.java which contains code that is common to both leaf and internal pages. In addition, header pages are implemented in BTreeHeaderPage.java and keep track of which pages in the file are in use. Lastly, there is one page at the beginning of every BTreeFile which points to the root page of the tree and the first header page. This singleton page is implemented in BTreeRootPtrPage.java. Familiarize yourself with the interfaces of these classes, especially BTreePage, BTreeInternalPage and BTreeLeafPage. You will need to use these classes in your implementation of the B+Tree.</p>
<p>çœ‹ä¸€ä¸‹ index/ å’Œ BTreeFile.java ã€‚è¿™æ˜¯å®ç°B+Treeçš„æ ¸å¿ƒæ–‡ä»¶ï¼Œä½ å°†åœ¨è¿™é‡Œç¼–å†™æœ¬å®éªŒçš„æ‰€æœ‰ä»£ç ã€‚ä¸HeapFileä¸åŒï¼ŒBTreeFileç”±å››ç§ä¸åŒçš„é¡µé¢ç»„æˆã€‚æ­£å¦‚ä½ æ‰€æœŸæœ›çš„ï¼Œæ ‘çš„èŠ‚ç‚¹æœ‰ä¸¤ç§ä¸åŒçš„é¡µï¼šå†…éƒ¨é¡µå’Œå¶å­é¡µã€‚å†…éƒ¨é¡µåœ¨BTreeInternalPage.javaä¸­å®ç°ï¼Œè€Œå¶å­é¡µåœ¨BTreeLeafPage.javaä¸­å®ç°ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬åœ¨BTreePage.javaä¸­åˆ›å»ºäº†ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå…¶ä¸­åŒ…å«äº†å¶å­é¡µå’Œå†…éƒ¨é¡µçš„å…±åŒä»£ç ã€‚æ­¤å¤–ï¼Œæ ‡é¢˜é¡µåœ¨BTreeHeaderPage.javaä¸­å®ç°ï¼Œå¹¶è·Ÿè¸ªæ–‡ä»¶ä¸­å“ªäº›é¡µæ­£åœ¨ä½¿ç”¨ã€‚æœ€åï¼Œåœ¨æ¯ä¸ªBTreeFileçš„å¼€å¤´éƒ½æœ‰ä¸€ä¸ªé¡µé¢ï¼Œå®ƒæŒ‡å‘æ ‘çš„æ ¹é¡µå’Œç¬¬ä¸€ä¸ªæ ‡é¢˜é¡µã€‚è¿™ä¸ªå•å­é¡µåœ¨BTreeRootPtrPage.javaä¸­å®ç°ã€‚ç†Ÿæ‚‰è¿™äº›ç±»çš„æ¥å£ï¼Œç‰¹åˆ«æ˜¯BTreePageã€BTreeInternalPageå’ŒBTreeLeafPageã€‚ä½ å°†éœ€è¦åœ¨ä½ çš„B+Treeçš„å®ç°ä¸­ä½¿ç”¨è¿™äº›ç±»ã€‚</p>
<p>Your first job is to implement the findLeafPage() function in BTreeFile.java. This function is used to find the appropriate leaf page given a particular key value, and is used for both searches and inserts. For example, suppose we have a B+Tree with two leaf pages (See Figure 1). The root node is an internal page with one entry containing one key (6, in this case) and two child pointers. Given a value of 1, this function should return the first leaf page. Likewise, given a value of 8, this function should return the second page. The less obvious case is if we are given a key value of 6. There may be duplicate keys, so there could be 6's on both leaf pages. In this case, the function should return the first (left) leaf page.</p>
<p>ä½ çš„ç¬¬ä¸€ä¸ªå·¥ä½œæ˜¯åœ¨BTreeFile.javaä¸­å®ç°findLeafPage()å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ç”¨äºåœ¨ç»™å®šä¸€ä¸ªç‰¹å®šçš„é”®å€¼çš„æƒ…å†µä¸‹æ‰¾åˆ°åˆé€‚çš„å¶å­é¡µï¼Œå¹¶ä¸”ç”¨äºæœç´¢å’Œæ’å…¥ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰ä¸¤ä¸ªå¶å­é¡µçš„B+Treeï¼ˆè§å›¾1ï¼‰ã€‚æ ¹èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå†…éƒ¨é¡µé¢ï¼Œæœ‰ä¸€ä¸ªæ¡ç›®ï¼ŒåŒ…å«ä¸€ä¸ªé”®ï¼ˆæœ¬ä¾‹ä¸­ä¸º6ï¼‰å’Œä¸¤ä¸ªå­æŒ‡é’ˆã€‚ç»™å®šä¸€ä¸ªå€¼ä¸º1ï¼Œè¿™ä¸ªå‡½æ•°åº”è¯¥è¿”å›ç¬¬ä¸€ä¸ªå¶å­é¡µã€‚åŒæ ·åœ°ï¼Œå¦‚æœæ•°å€¼ä¸º8ï¼Œè¿™ä¸ªå‡½æ•°åº”è¯¥è¿”å›ç¬¬äºŒä¸ªé¡µé¢ã€‚ä¸å¤ªæ˜æ˜¾çš„æƒ…å†µæ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ç»™å®šçš„é”®å€¼æ˜¯6ï¼Œå¯èƒ½æœ‰é‡å¤çš„é”®ï¼Œæ‰€ä»¥ä¸¤ä¸ªå¶å­é¡µä¸Šå¯èƒ½éƒ½æœ‰6ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå‡½æ•°åº”è¯¥è¿”å›ç¬¬ä¸€ä¸ªï¼ˆå·¦è¾¹ï¼‰å¶å­é¡µã€‚</p>
<p><img src="image/6-lab5/1644485061911.png" alt="" />
Figure 1: A simple B+ Tree with duplicate keys</p>
<p>å›¾1ï¼šä¸€ä¸ªç®€å•çš„æœ‰é‡å¤ key çš„ B+ æ ‘</p>
<p>Your findLeafPage() function should recursively search through internal nodes until it reaches the leaf page corresponding to the provided key value. In order to find the appropriate child page at each step, you should iterate through the entries in the internal page and compare the entry value to the provided key value. BTreeInternalPage.iterator() provides access to the entries in the internal page using the interface defined in BTreeEntry.java. This iterator allows you to iterate through the key values in the internal page and access the left and right child page ids for each key. The base case of your recursion happens when the passed-in BTreePageId has pgcateg() equal to BTreePageId.LEAF, indicating that it is a leaf page. In this case, you should just fetch the page from the buffer pool and return it. You do not need to confirm that it actually contains the provided key value f.</p>
<p>ä½ çš„findLeafPage()å‡½æ•°åº”è¯¥é€’å½’åœ°æœç´¢å†…éƒ¨èŠ‚ç‚¹ï¼Œç›´åˆ°åˆ°è¾¾ä¸æ‰€æä¾›çš„é”®å€¼ç›¸å¯¹åº”çš„å¶å­é¡µã€‚ä¸ºäº†åœ¨æ¯ä¸€æ­¥æ‰¾åˆ°åˆé€‚çš„å­é¡µé¢ï¼Œä½ åº”è¯¥éå†å†…éƒ¨é¡µé¢ä¸­çš„æ¡ç›®ï¼Œå¹¶å°†æ¡ç›®å€¼ä¸æä¾›çš„é”®å€¼è¿›è¡Œæ¯”è¾ƒã€‚BTreeInternalPage.iterator()ä½¿ç”¨BTreeEntry.javaä¸­å®šä¹‰çš„æ¥å£æä¾›äº†å¯¹å†…éƒ¨é¡µé¢ä¸­æ¡ç›®çš„è®¿é—®ã€‚è¿™ä¸ªè¿­ä»£å™¨å…è®¸ä½ éå†å†…éƒ¨é¡µé¢ä¸­çš„é”®å€¼ï¼Œå¹¶è®¿é—®æ¯ä¸ªé”®çš„å·¦å³å­é¡µé¢IDã€‚å½“ä¼ å…¥çš„BTreePageIdçš„pgcateg()ç­‰äºBTreePageId.LEAFæ—¶ï¼Œä½ é€’å½’çš„åŸºæœ¬æƒ…å†µå°±ä¼šå‘ç”Ÿï¼Œè¡¨æ˜å®ƒæ˜¯ä¸€ä¸ªå¶å­é¡µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ åº”è¯¥åªæ˜¯ä»ç¼“å†²æ± ä¸­è·å–è¯¥é¡µå¹¶è¿”å›å®ƒã€‚ä½ ä¸éœ€è¦ç¡®è®¤å®ƒæ˜¯å¦çœŸçš„åŒ…å«æ‰€æä¾›çš„é”®å€¼fã€‚</p>
<p>Your findLeafPage() code must also handle the case when the provided key value f is null. If the provided value is null, recurse on the left-most child every time in order to find the left-most leaf page. Finding the left-most leaf page is useful for scanning the entire file. Once the correct leaf page is found, you should return it. As mentioned above, you can check the type of page using the pgcateg() function in BTreePageId.java. You can assume that only leaf and internal pages will be passed to this function.</p>
<p>ä½ çš„findLeafPage()ä»£ç è¿˜å¿…é¡»å¤„ç†æ‰€æä¾›çš„é”®å€¼fä¸ºç©ºçš„æƒ…å†µã€‚å¦‚æœæä¾›çš„å€¼æ˜¯ç©ºçš„ï¼Œæ¯æ¬¡éƒ½åœ¨æœ€å·¦è¾¹çš„å­é¡µä¸Šé€’å½’ï¼Œä»¥ä¾¿æ‰¾åˆ°æœ€å·¦è¾¹çš„å¶å­é¡µã€‚æ‰¾åˆ°æœ€å·¦è¾¹çš„å¶å­é¡µå¯¹äºæ‰«ææ•´ä¸ªæ–‡ä»¶æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚ä¸€æ—¦æ‰¾åˆ°æ­£ç¡®çš„å¶å­é¡µï¼Œä½ åº”è¯¥è¿”å›å®ƒã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œä½ å¯ä»¥ä½¿ç”¨BTreePageId.javaä¸­çš„pgcateg()å‡½æ•°æ£€æŸ¥é¡µé¢çš„ç±»å‹ã€‚ä½ å¯ä»¥å‡è®¾åªæœ‰å¶å­é¡µå’Œå†…éƒ¨é¡µä¼šè¢«ä¼ é€’ç»™è¿™ä¸ªå‡½æ•°ã€‚</p>
<p>Instead of directly calling BufferPool.getPage() to get each internal page and leaf page, we recommend calling the wrapper function we have provided, BTreeFile.getPage(). It works exactly like BufferPool.getPage(), but takes an extra argument to track the list of dirty pages. This function will be important for the next two exercises in which you will actually update the data and therefore need to keep track of dirty pages.</p>
<p>ä¸å…¶ç›´æ¥è°ƒç”¨BufferPool.getPage()æ¥è·å–æ¯ä¸ªå†…éƒ¨é¡µé¢å’Œå¶å­é¡µé¢ï¼Œæˆ‘ä»¬å»ºè®®è°ƒç”¨æˆ‘ä»¬æä¾›çš„åŒ…è£…å‡½æ•°BTreeFile.getPage()ã€‚å®ƒçš„å·¥ä½œåŸç†ä¸BufferPool.getPage()å®Œå…¨ä¸€æ ·ï¼Œä½†éœ€è¦ä¸€ä¸ªé¢å¤–çš„å‚æ•°æ¥è·Ÿè¸ªè„é¡µçš„åˆ—è¡¨ã€‚è¿™ä¸ªå‡½æ•°åœ¨æ¥ä¸‹æ¥çš„ä¸¤ä¸ªç»ƒä¹ ä¸­éå¸¸é‡è¦ï¼Œä½ å°†å®é™…æ›´æ–°æ•°æ®ï¼Œå› æ­¤éœ€è¦è·Ÿè¸ªè„é¡µã€‚</p>
<p>Every internal (non-leaf) page your findLeafPage() implementation visits should be fetched with READ_ONLY permission, except the returned leaf page, which should be fetched with the permission provided as an argument to the function. These permission levels will not matter for this lab, but they will be important for the code to function correctly in future labs.</p>
<p>ä½ çš„findLeafPage()å®ç°è®¿é—®çš„æ¯ä¸€ä¸ªå†…éƒ¨ï¼ˆéå¶å­ï¼‰é¡µé¢éƒ½åº”è¯¥ä»¥READ_ONLYæƒé™è·å–ï¼Œé™¤äº†è¿”å›çš„å¶å­é¡µé¢ï¼Œå®ƒåº”è¯¥ä»¥ä½œä¸ºå‡½æ•°å‚æ•°æä¾›çš„æƒé™è·å–ã€‚è¿™äº›æƒé™çº§åˆ«å¯¹æœ¬å®éªŒæ¥è¯´å¹¶ä¸é‡è¦ï¼Œä½†å®ƒä»¬å¯¹ä»£ç åœ¨æœªæ¥å®éªŒä¸­çš„æ­£å¸¸è¿è¡Œéå¸¸é‡è¦ã€‚</p>
<h2 id="exercise-1-btreefilefindleafpage"><a class="header" href="#exercise-1-btreefilefindleafpage">Exercise 1: BTreeFile.findLeafPage()</a></h2>
<p>Implement BTreeFile.findLeafPage().</p>
<p>After completing this exercise, you should be able to pass all the unit tests in BTreeFileReadTest.java and the system tests in BTreeScanTest.java.</p>
<p>å®Œæˆè¿™ä¸ªç»ƒä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeFileReadTest.javaä¸­çš„æ‰€æœ‰å•å…ƒæµ‹è¯•å’ŒBTreeScanTest.javaä¸­çš„ç³»ç»Ÿæµ‹è¯•ã€‚</p>
<h2 id="3-insert"><a class="header" href="#3-insert">3. Insert</a></h2>
<p>In order to keep the tuples of the B+Tree in sorted order and maintain the integrity of the tree, we must insert tuples into the leaf page with the enclosing key range. As was mentioned above, findLeafPage() can be used to find the correct leaf page into which we should insert the tuple. However, each page has a limited number of slots and we need to be able to insert tuples even if the corresponding leaf page is full.</p>
<p>ä¸ºäº†ä½¿B+Treeçš„ tuple ä¿æŒæ’åºï¼Œå¹¶ä¿æŒæ ‘çš„å®Œæ•´æ€§ï¼Œæˆ‘ä»¬å¿…é¡»å°† tuple æ’å…¥åˆ°å…·æœ‰åŒ…å›´é”®èŒƒå›´çš„å¶é¡µä¸­ã€‚å¦‚ä¸Šæ‰€è¿°ï¼ŒfindLeafPage()å¯ä»¥ç”¨æ¥æ‰¾åˆ°æˆ‘ä»¬åº”è¯¥æ’å…¥ tuple çš„æ­£ç¡®å¶å­é¡µã€‚ç„¶è€Œï¼Œæ¯ä¸ªé¡µé¢éƒ½æœ‰æœ‰é™çš„æ§½ä½ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ’å…¥ tuple ï¼Œå³ä½¿ç›¸åº”çš„å¶å­é¡µé¢å·²ç»æ»¡äº†ã€‚</p>
<p>As described in the textbook, attempting to insert a tuple into a full leaf page should cause that page to split so that the tuples are evenly distributed between the two new pages. Each time a leaf page splits, a new entry corresponding to the first tuple in the second page will need to be added to the parent node. Occasionally, the internal node may also be full and unable to accept new entries. In that case, the parent should split and add a new entry to its parent. This may cause recursive splits and ultimately the creation of a new root node.</p>
<p>æ­£å¦‚æ•™ç§‘ä¹¦ä¸­æ‰€æè¿°çš„ï¼Œè¯•å›¾åœ¨ä¸€ä¸ªå®Œæ•´çš„å¶å­é¡µä¸­æ’å…¥ä¸€ä¸ªtupleåº”è¯¥å¯¼è‡´è¯¥é¡µåˆ†è£‚ï¼Œä»¥ä¾¿tupleå‡åŒ€åœ°åˆ†å¸ƒåœ¨ä¸¤ä¸ªæ–°é¡µä¸­ã€‚æ¯æ¬¡å¶å­é¡µåˆ†è£‚æ—¶ï¼Œéœ€è¦å‘çˆ¶èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªä¸ç¬¬äºŒé¡µä¸­ç¬¬ä¸€ä¸ªtupleå¯¹åº”çš„æ–°æ¡ç›®ã€‚å¶å°”ï¼Œå†…éƒ¨èŠ‚ç‚¹ä¹Ÿå¯èƒ½æ˜¯æ»¡çš„ï¼Œæ— æ³•æ¥å—æ–°æ¡ç›®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œçˆ¶èŠ‚ç‚¹åº”è¯¥æ‹†åˆ†å¹¶å‘å…¶çˆ¶èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªæ–°æ¡ç›®ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´é€’å½’åˆ†è£‚ï¼Œæœ€ç»ˆåˆ›å»ºä¸€ä¸ªæ–°çš„æ ¹èŠ‚ç‚¹ã€‚</p>
<p>In this exercise you will implement splitLeafPage() and splitInternalPage() in BTreeFile.java. If the page being split is the root page, you will need to create a new internal node to become the new root page, and update the BTreeRootPtrPage. Otherwise, you will need to fetch the parent page with READ_WRITE permissions, recursively split it if necessary, and add a new entry. You will find the function getParentWithEmptySlots() extremely useful for handling these different cases. In splitLeafPage() you should &quot;copy&quot; the key up to the parent page, while in splitInternalPage() you should &quot;push&quot; the key up to the parent page. See Figure 2 and review section 10.5 in the text book if this is confusing. Remember to update the parent pointers of the new pages as needed (for simplicity, we do not show parent pointers in the figures). When an internal node is split, you will need to update the parent pointers of all the children that were moved. You may find the function updateParentPointers() useful for this task. Additionally, remember to update the sibling pointers of any leaf pages that were split. Finally, return the page into which the new tuple or entry should be inserted, as indicated by the provided key field. (Hint: You do not need to worry about the fact that the provided key may actually fall in the exact center of the tuples/entries to be split. You should ignore the key during the split, and only use it to determine which of the two pages to return.)</p>
<p>åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†åœ¨ BTreeFile.java ä¸­å®ç° splitLeafPage() å’Œ splitInternalPage() ã€‚å¦‚æœè¢«åˆ†å‰²çš„é¡µé¢æ˜¯æ ¹é¡µé¢ï¼Œä½ å°†éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„å†…éƒ¨èŠ‚ç‚¹æ¥æˆä¸ºæ–°çš„æ ¹é¡µé¢ï¼Œå¹¶æ›´æ–°BTreeRootPtrPageã€‚å¦åˆ™ï¼Œä½ å°†éœ€è¦ä»¥READ_WRITEæƒé™è·å–çˆ¶é¡µï¼Œå¿…è¦æ—¶é€’å½’åˆ†å‰²ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªæ–°æ¡ç›®ã€‚ä½ ä¼šå‘ç°å‡½æ•°getParentWithEmptySlots()å¯¹äºå¤„ç†è¿™äº›ä¸åŒçš„æƒ…å†µéå¸¸æœ‰ç”¨ã€‚åœ¨splitLeafPage()ä¸­ï¼Œä½ åº”è¯¥å°†é”® &quot;å¤åˆ¶ &quot;åˆ°çˆ¶é¡µä¸Šï¼Œè€Œåœ¨splitInternalPage()ä¸­ï¼Œä½ åº”è¯¥å°†é”® &quot;æ¨ &quot;åˆ°çˆ¶é¡µä¸Šã€‚å¦‚æœè¿™ä¸€ç‚¹ä»¤äººå›°æƒ‘ï¼Œè¯·å‚è§å›¾2ï¼Œå¹¶å›é¡¾æ•™ç§‘ä¹¦ä¸­çš„10.5èŠ‚ã€‚è®°ä½è¦æ ¹æ®éœ€è¦æ›´æ–°æ–°é¡µé¢çš„çˆ¶æŒ‡é’ˆï¼ˆä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ä¸åœ¨å›¾ä¸­æ˜¾ç¤ºçˆ¶æŒ‡é’ˆï¼‰ã€‚å½“ä¸€ä¸ªå†…éƒ¨èŠ‚ç‚¹è¢«åˆ†å‰²æ—¶ï¼Œä½ å°†éœ€è¦æ›´æ–°æ‰€æœ‰è¢«ç§»åŠ¨çš„å­èŠ‚ç‚¹çš„çˆ¶æŒ‡é’ˆã€‚ä½ å¯èƒ½ä¼šå‘ç°å‡½æ•°updateParentPointers()å¯¹è¿™é¡¹ä»»åŠ¡å¾ˆæœ‰ç”¨ã€‚æ­¤å¤–ï¼Œè®°å¾—è¦æ›´æ–°ä»»ä½•è¢«æ‹†åˆ†çš„å¶å­é¡µé¢çš„å…„å¼Ÿå§å¦¹æŒ‡é’ˆã€‚æœ€åï¼Œè¿”å›æ–°çš„tupleæˆ–æ¡ç›®åº”è¯¥è¢«æ’å…¥çš„é¡µé¢ï¼Œå¦‚æ‰€æä¾›çš„é”®å­—æ®µæ‰€ç¤ºã€‚(æç¤ºï¼šä½ ä¸éœ€è¦æ‹…å¿ƒæ‰€æä¾›çš„é”®å®é™…ä¸Šå¯èƒ½æ­£å¥½è½åœ¨è¦åˆ†å‰²çš„tuple/æ¡ç›®çš„ä¸­å¿ƒã€‚åœ¨åˆ†å‰²è¿‡ç¨‹ä¸­ï¼Œä½ åº”è¯¥å¿½ç•¥è¿™ä¸ªé”®ï¼Œè€Œåªæ˜¯ç”¨å®ƒæ¥å†³å®šè¿”å›ä¸¤ä¸ªé¡µé¢ä¸­çš„å“ªä¸€ä¸ªï¼‰ã€‚</p>
<p><img src="image/6-lab5/1644501314066.png" alt="" />
Figure 2: Splitting pages</p>
<p>Whenever you create a new page, either because of splitting a page or creating a new root page, call getEmptyPage() to get the new page. This function is an abstraction which will allow us to reuse pages that have been deleted due to merging (covered in the next section).</p>
<p>æ¯å½“ä½ åˆ›å»ºä¸€ä¸ªæ–°çš„é¡µé¢ï¼Œæ— è®ºæ˜¯å› ä¸ºæ‹†åˆ†ä¸€ä¸ªé¡µé¢è¿˜æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„æ ¹é¡µé¢ï¼Œéƒ½è¦è°ƒç”¨getEmptyPage()æ¥è·å–æ–°çš„é¡µé¢ã€‚è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªæŠ½è±¡ï¼Œå®ƒå°†å…è®¸æˆ‘ä»¬é‡æ–°ä½¿ç”¨å› åˆå¹¶è€Œè¢«åˆ é™¤çš„é¡µé¢ï¼ˆåœ¨ä¸‹ä¸€èŠ‚æ¶‰åŠï¼‰ã€‚</p>
<p>We expect that you will interact with leaf and internal pages using BTreeLeafPage.iterator() and BTreeInternalPage.iterator() to iterate through the tuples/entries in each page. For convenience, we have also provided reverse iterators for both types of pages: BTreeLeafPage.reverseIterator() and BTreeInternalPage.reverseIterator(). These reverse iterators will be especially useful for moving a subset of tuples/entries from a page to its right sibling.</p>
<p>æˆ‘ä»¬å¸Œæœ›ä½ èƒ½ä½¿ç”¨BTreeLeafPage.iterator()å’ŒBTreeInternalPage.iterator()ä¸å¶å­é¡µå’Œå†…éƒ¨é¡µè¿›è¡Œäº¤äº’ï¼Œä»¥è¿­ä»£æ¯ä¸ªé¡µé¢ä¸­çš„ tuple /æ¡ç›®ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬è¿˜ä¸ºè¿™ä¸¤ç§ç±»å‹çš„é¡µé¢æä¾›äº†åå‘è¿­ä»£å™¨ã€‚BTreeLeafPage.reverseIteratorï¼ˆï¼‰å’ŒBTreeInternalPage.reverseIteratorï¼ˆï¼‰ã€‚è¿™äº›åå‘è¿­ä»£å™¨å¯¹äºå°†ä¸€ä¸ªé¡µé¢ä¸­çš„ tuple /æ¡ç›®å­é›†ç§»åŠ¨åˆ°å…¶å³è¾¹çš„åŒçº§é¡µé¢ä¸­ç‰¹åˆ«æœ‰ç”¨ã€‚</p>
<p>As mentioned above, the internal page iterators use the interface defined in BTreeEntry.java, which has one key and two child pointers. It also has a recordId, which identifies the location of the key and child pointers on the underlying page. We think working with one entry at a time is a natural way to interact with internal pages, but it is important to keep in mind that the underlying page does not actually store a list of entries, but stores ordered lists of m keys and m+1 child pointers. Since the BTreeEntry is just an interface and not an object actually stored on the page, updating the fields of BTreeEntry will not modify the underlying page. In order to change the data on the page, you need to call BTreeInternalPage.updateEntry(). Furthermore, deleting an entry actually deletes only a key and a single child pointer, so we provide the funtions BTreeInternalPage.deleteKeyAndLeftChild() and BTreeInternalPage.deleteKeyAndRightChild() to make this explicit. The entry's recordId is used to find the key and child pointer to be deleted. Inserting an entry also only inserts a key and single child pointer (unless it's the first entry), so BTreeInternalPage.insertEntry() checks that one of the child pointers in the provided entry overlaps an existing child pointer on the page, and that inserting the entry at that location will keep the keys in sorted order.</p>
<p>å¦‚ä¸Šæ‰€è¿°ï¼Œå†…éƒ¨é¡µé¢è¿­ä»£å™¨ä½¿ç”¨BTreeEntry.javaä¸­å®šä¹‰çš„æ¥å£ï¼Œå®ƒæœ‰ä¸€ä¸ªkeyå’Œä¸¤ä¸ªchild pointersã€‚å®ƒè¿˜æœ‰ä¸€ä¸ªrecordIdï¼Œç”¨äºè¯†åˆ«åº•å±‚é¡µé¢ä¸Šé”®å’Œå­æŒ‡é’ˆçš„ä½ç½®ã€‚æˆ‘ä»¬è®¤ä¸ºä¸€æ¬¡å¤„ç†ä¸€ä¸ªæ¡ç›®æ˜¯ä¸å†…éƒ¨é¡µé¢äº¤äº’çš„è‡ªç„¶æ–¹å¼ï¼Œä½†é‡è¦çš„æ˜¯è¦è®°ä½ï¼Œåº•å±‚é¡µé¢å®é™…ä¸Šå¹¶ä¸å­˜å‚¨ä¸€ä¸ªæ¡ç›®åˆ—è¡¨ï¼Œè€Œæ˜¯å­˜å‚¨mä¸ªé”®å’Œm+1ä¸ªå­æŒ‡é’ˆçš„æœ‰åºåˆ—è¡¨ã€‚ç”±äºBTreeEntryåªæ˜¯ä¸€ä¸ªæ¥å£ï¼Œè€Œä¸æ˜¯å®é™…å­˜å‚¨åœ¨é¡µé¢ä¸Šçš„å¯¹è±¡ï¼Œæ›´æ–°BTreeEntryçš„å­—æ®µä¸ä¼šä¿®æ”¹åº•å±‚é¡µé¢ã€‚ä¸ºäº†æ”¹å˜é¡µé¢ä¸Šçš„æ•°æ®ï¼Œä½ éœ€è¦è°ƒç”¨BTreeInternalPage.updateEntryï¼ˆï¼‰ã€‚æ­¤å¤–ï¼Œåˆ é™¤ä¸€ä¸ªæ¡ç›®å®é™…ä¸Šåªåˆ é™¤äº†ä¸€ä¸ªé”®å’Œä¸€ä¸ªå­æŒ‡é’ˆï¼Œæ‰€ä»¥æˆ‘ä»¬æä¾›äº†BTreeInternalPage.deleteKeyAndLeftChild()å’ŒBTreeInternalPage.deleteKeyAndRightChild()çš„åŠŸèƒ½æ¥æ˜ç¡®è¿™ä¸€ç‚¹ã€‚è¯¥æ¡ç›®çš„recordIdè¢«ç”¨æ¥å¯»æ‰¾è¦åˆ é™¤çš„keyå’ŒchildæŒ‡é’ˆã€‚æ’å…¥ä¸€ä¸ªæ¡ç›®ä¹Ÿåªæ’å…¥ä¸€ä¸ªé”®å’Œå•ä¸ªå­æŒ‡é’ˆï¼ˆé™¤éå®ƒæ˜¯ç¬¬ä¸€ä¸ªæ¡ç›®ï¼‰ï¼Œæ‰€ä»¥BTreeInternalPage.insertEntry()æ£€æŸ¥æ‰€æä¾›çš„æ¡ç›®ä¸­çš„ä¸€ä¸ªå­æŒ‡é’ˆæ˜¯å¦ä¸é¡µé¢ä¸Šç°æœ‰çš„ä¸€ä¸ªå­æŒ‡é’ˆé‡å ï¼Œåœ¨è¯¥ä½ç½®æ’å…¥æ¡ç›®å°†ä¿æŒé”®çš„æ’åºé¡ºåºã€‚</p>
<p>In both splitLeafPage() and splitInternalPage(), you will need to update the set of dirtypages with any newly created pages as well as any pages modified due to new pointers or new data. This is where BTreeFile.getPage() will come in handy. Each time you fetch a page, BTreeFile.getPage() will check to see if the page is already stored in the local cache (dirtypages), and if it can't find the requested page there, it fetches it from the buffer pool. BTreeFile.getPage() also adds pages to the dirtypages cache if they are fetched with read-write permission, since presumably they will soon be dirtied. One advantage of this approach is that it prevents loss of updates if the same pages are accessed multiple times during a single tuple insertion or deletion.</p>
<p>åœ¨ splitLeafPage() å’Œ splitInternalPage() ä¸­ï¼Œä½ éœ€è¦ç”¨ä»»ä½•æ–°åˆ›å»ºçš„é¡µé¢ä»¥åŠç”±äºæ–°æŒ‡é’ˆæˆ–æ–°æ•°æ®è€Œä¿®æ”¹çš„é¡µé¢æ¥æ›´æ–° dirtypages çš„é›†åˆã€‚è¿™å°±æ˜¯BTreeFile.getPage()çš„ç”¨æ­¦ä¹‹åœ°ã€‚æ¯æ¬¡ä½ è·å–ä¸€ä¸ªé¡µé¢æ—¶ï¼ŒBTreeFile.getPage()éƒ½ä¼šæ£€æŸ¥è¯¥é¡µé¢æ˜¯å¦å·²ç»å­˜å‚¨åœ¨æœ¬åœ°ç¼“å­˜ï¼ˆdirtypagesï¼‰ä¸­ï¼Œå¦‚æœå®ƒåœ¨é‚£é‡Œæ‰¾ä¸åˆ°æ‰€è¯·æ±‚çš„é¡µé¢ï¼Œå®ƒå°±ä¼šä»ç¼“å†²æ± ä¸­è·å–å®ƒã€‚BTreeFile.getPage()è¿˜å°†é¡µé¢æ·»åŠ åˆ°dirtypagesç¼“å­˜ä¸­ï¼Œå¦‚æœå®ƒä»¬æ˜¯ä»¥è¯»å†™æƒé™è·å–çš„ï¼Œå› ä¸ºæ®æ¨æµ‹å®ƒä»¬å¾ˆå¿«å°±ä¼šè¢«å¼„è„ã€‚è¿™ç§æ–¹æ³•çš„ä¸€ä¸ªä¼˜ç‚¹æ˜¯ï¼Œå¦‚æœåœ¨ä¸€æ¬¡tupleæ’å…¥æˆ–åˆ é™¤è¿‡ç¨‹ä¸­å¤šæ¬¡è®¿é—®ç›¸åŒçš„é¡µé¢ï¼Œå®ƒå¯ä»¥é˜²æ­¢æ›´æ–°çš„æŸå¤±ã€‚</p>
<p>Note that in a major departure from HeapFile.insertTuple(), BTreeFile.insertTuple() could return a large set of dirty pages, especially if any internal pages are split. As you may remember from previous labs, the set of dirty pages is returned to prevent the buffer pool from evicting dirty pages before they have been flushed.</p>
<p>è¯·æ³¨æ„ï¼Œä¸ HeapFile.insertTuple() å¤§ç›¸å¾„åº­çš„æ˜¯ï¼ŒBTreeFile.insertTuple() å¯èƒ½ä¼šè¿”å›ä¸€å¤§ç»„è„é¡µï¼Œç‰¹åˆ«æ˜¯åœ¨ä»»ä½•å†…éƒ¨é¡µé¢è¢«åˆ†å‰²çš„æƒ…å†µä¸‹ã€‚ä½ å¯èƒ½è¿˜è®°å¾—ä»¥å‰çš„å®éªŒï¼Œè¿”å›è„é¡µé›†æ˜¯ä¸ºäº†é˜²æ­¢ç¼“å†²æ± åœ¨è„é¡µè¢«åˆ·æ–°ä¹‹å‰é©±é€å®ƒä»¬ã€‚</p>
<p>Warning: as the B+Tree is a complex data structure, it is helpful to understand the properties necessary of every legal B+Tree before modifying it. Here is an informal list:</p>
<p>è­¦å‘Šï¼šç”±äºB+Treeæ˜¯ä¸€ä¸ªå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œåœ¨ä¿®æ”¹å®ƒä¹‹å‰ï¼Œäº†è§£æ¯ä¸ªåˆæ³•B+Treeçš„å¿…è¦å±æ€§æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªéæ­£å¼çš„åˆ—è¡¨ã€‚</p>
<p>If a parent node points to a child node, the child nodes must point back to those same parents.</p>
<p>å¦‚æœä¸€ä¸ªçˆ¶èŠ‚ç‚¹æŒ‡å‘ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹å¿…é¡»æŒ‡å‘é‚£äº›ç›¸åŒçš„çˆ¶èŠ‚ç‚¹ã€‚</p>
<p>If a leaf node points to a right sibling, then the right sibling points back to that leaf node as a left sibling.</p>
<p>å¦‚æœä¸€ä¸ªå¶å­èŠ‚ç‚¹æŒ‡å‘ä¸€ä¸ªå³è¾¹çš„å…„å¼Ÿå§å¦¹ï¼Œé‚£ä¹ˆå³è¾¹çš„å…„å¼Ÿå§å¦¹å°±ä¼šä½œä¸ºå·¦è¾¹çš„å…„å¼Ÿå§å¦¹æŒ‡å‘è¯¥å¶å­èŠ‚ç‚¹ã€‚</p>
<p>The first and last leaves must point to null left and right siblings respectively.
Record Id's must match the page they are actually in.
A key in a node with non-leaf children must be larger than any key in the left child, and smaller than any key in the right child.
A key in a node with leaf children must be larger or equal than any key in the left child, and smaller or equal than any key in the right child.
A node has either all non-leaf children, or all leaf children.
A non-root node cannot be less than half full.
We have implemented a mechanized check for all these properties in the file BTreeChecker.java. This method is also used to test your B+Tree implementation in the systemtest/BTreeFileDeleteTest.java. Feel free to add calls to this function to help debug your implementation, like we did in BTreeFileDeleteTest.java.</p>
<p>ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå¶å­å¿…é¡»åˆ†åˆ«æŒ‡å‘ç©ºçš„å·¦è¾¹å’Œå³è¾¹çš„å…„å¼Ÿå§å¦¹ã€‚
è®°å½•çš„Idå¿…é¡»ä¸å®ƒä»¬å®é™…æ‰€åœ¨çš„é¡µé¢ç›¸åŒ¹é…ã€‚
æœ‰éå¶å­çš„èŠ‚ç‚¹ä¸­çš„ä¸€ä¸ªé”®å¿…é¡»å¤§äºå·¦ä¾§å­èŠ‚ç‚¹ä¸­çš„ä»»ä½•é”®ï¼Œå¹¶ä¸”å°äºå³ä¾§å­èŠ‚ç‚¹ä¸­çš„ä»»ä½•é”®ã€‚
ä¸€ä¸ªæœ‰å¶å­çš„èŠ‚ç‚¹ä¸­çš„é”®å¿…é¡»å¤§äºæˆ–ç­‰äºå·¦è¾¹å­èŠ‚ç‚¹ä¸­çš„ä»»ä½•é”®ï¼Œå¹¶ä¸”å°äºæˆ–ç­‰äºå³è¾¹å­èŠ‚ç‚¹ä¸­çš„ä»»ä½•é”®ã€‚
ä¸€ä¸ªèŠ‚ç‚¹è¦ä¹ˆæœ‰æ‰€æœ‰éå¶å­çš„å­©å­ï¼Œè¦ä¹ˆæœ‰æ‰€æœ‰å¶å­çš„å­©å­ã€‚
ä¸€ä¸ªéæ ¹èŠ‚ç‚¹ä¸èƒ½å°‘äºä¸€åŠã€‚
æˆ‘ä»¬å·²ç»åœ¨BTreeChecker.javaæ–‡ä»¶ä¸­å®ç°äº†å¯¹æ‰€æœ‰è¿™äº›å±æ€§çš„æœºæ¢°åŒ–æ£€æŸ¥ã€‚åœ¨systemtest/BTreeFileDeleteTest.javaä¸­ï¼Œè¿™ä¸ªæ–¹æ³•ä¹Ÿè¢«ç”¨æ¥æµ‹è¯•ä½ çš„B+Treeå®ç°ã€‚è¯·éšæ„æ·»åŠ å¯¹è¯¥å‡½æ•°çš„è°ƒç”¨ï¼Œä»¥å¸®åŠ©è°ƒè¯•ä½ çš„å®ç°ï¼Œå°±åƒæˆ‘ä»¬åœ¨BTreeFileDeleteTest.javaä¸­åšçš„é‚£æ ·ã€‚</p>
<p>N.B.</p>
<p>The checker method should always pass after initialization of the tree and before starting and after completing a full call to key insertion or deletion, but not necessarily within internal methods.</p>
<p>æ£€æŸ¥å™¨æ–¹æ³•åº”è¯¥æ€»æ˜¯åœ¨æ ‘çš„åˆå§‹åŒ–ä¹‹åï¼Œåœ¨å¼€å§‹å’Œå®Œæˆå¯¹é”®æ’å…¥æˆ–åˆ é™¤çš„å®Œæ•´è°ƒç”¨ä¹‹å‰ä¼ é€’ï¼Œä½†ä¸ä¸€å®šåœ¨å†…éƒ¨æ–¹æ³•ä¸­ä¼ é€’ã€‚</p>
<p>A tree may be well formed (and therefore pass checkRep()) but still incorrect. For example, the empty tree will always pass checkRep(), but may not always be correct (if you just inserted a tuple, the tree should not be empty). ***</p>
<p>ä¸€ä¸ªæ ‘å¯èƒ½å½¢æˆå¾—å¾ˆå¥½ï¼ˆå› æ­¤é€šè¿‡äº†checkRep()ï¼‰ï¼Œä½†æ˜¯ä»ç„¶ä¸æ­£ç¡®ã€‚ä¾‹å¦‚ï¼Œç©ºçš„æ ‘æ€»æ˜¯èƒ½é€šè¿‡checkRep()ï¼Œä½†ä¸ä¸€å®šæ€»æ˜¯æ­£ç¡®çš„ï¼ˆå¦‚æœä½ åˆšåˆšæ’å…¥äº†ä¸€ä¸ªtupleï¼Œæ ‘ä¸åº”è¯¥æ˜¯ç©ºçš„ï¼‰ã€‚***</p>
<h2 id="exercise-2-splitting-pages"><a class="header" href="#exercise-2-splitting-pages">Exercise 2: Splitting Pages</a></h2>
<p>Implement BTreeFile.splitLeafPage() and BTreeFile.splitInternalPage().</p>
<p>After completing this exercise, you should be able to pass the unit tests in BTreeFileInsertTest.java. You should also be able to pass the system tests in systemtest/BTreeFileInsertTest.java. Some of the system test cases may take a few seconds to complete. These files will test that your code inserts tuples and splits pages correcty, and also handles duplicate tuples.</p>
<p>å®Œæˆè¿™ä¸ªç»ƒä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeFileInsertTest.javaä¸­çš„å•å…ƒæµ‹è¯•ã€‚ä½ ä¹Ÿåº”è¯¥èƒ½å¤Ÿé€šè¿‡ systemtest/BTreeFileInsertTest.java ä¸­çš„ç³»ç»Ÿæµ‹è¯•ã€‚ä¸€äº›ç³»ç»Ÿæµ‹è¯•æ¡ˆä¾‹å¯èƒ½éœ€è¦å‡ ç§’é’Ÿçš„æ—¶é—´æ¥å®Œæˆã€‚è¿™äº›æ–‡ä»¶å°†æµ‹è¯•ä½ çš„ä»£ç æ˜¯å¦æ­£ç¡®åœ°æ’å…¥ tuple å’Œåˆ†å‰²é¡µé¢ï¼Œå¹¶å¤„ç†é‡å¤çš„ tuple ã€‚</p>
<h2 id="4-delete"><a class="header" href="#4-delete">4. Delete</a></h2>
<p>In order to keep the tree balanced and not waste unnecessary space, deletions in a B+Tree may cause pages to redistribute tuples (Figure 3) or, eventually, to merge (see Figure 4). You may find it useful to review section 10.6 in the textbook.</p>
<p>ä¸ºäº†ä¿æŒæ ‘çš„å¹³è¡¡ï¼Œä¸æµªè´¹ä¸å¿…è¦çš„ç©ºé—´ï¼ŒB+æ ‘ä¸­çš„åˆ é™¤å¯èƒ½ä¼šå¯¼è‡´é¡µé¢é‡æ–°åˆ†é… tuple ï¼ˆå›¾3ï¼‰æˆ–æœ€ç»ˆåˆå¹¶ï¼ˆè§å›¾4ï¼‰ã€‚ä½ å¯èƒ½ä¼šå‘ç°å¤ä¹ ä¸€ä¸‹æ•™ç§‘ä¹¦ä¸­çš„ç¬¬10.6èŠ‚æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚</p>
<p><img src="image/6-lab5/1644564797612.png" alt="" />
Figure 3: Redistributing pages</p>
<p><img src="image/6-lab5/1644564966538.png" alt="" />
Figure 4: Merging pages</p>
<p>As described in the textbook, attempting to delete a tuple from a leaf page that is less than half full should cause that page to either steal tuples from one of its siblings or merge with one of its siblings. If one of the page's siblings has tuples to spare, the tuples should be evenly distributed between the two pages, and the parent's entry should be updated accordingly (see Figure 3). However, if the sibling is also at minimum occupancy, then the two pages should merge and the entry deleted from the parent (Figure 4). In turn, deleting an entry from the parent may cause the parent to become less than half full. In this case, the parent should steal entries from its siblings or merge with a sibling. This may cause recursive merges or even deletion of the root node if the last entry is deleted from the root node.</p>
<p>æ­£å¦‚æ•™ç§‘ä¹¦ä¸­æ‰€æè¿°çš„é‚£æ ·ï¼Œå¦‚æœè¯•å›¾ä»ä¸€ä¸ªä¸æ»¡ä¸€åŠçš„å¶å­é¡µä¸­åˆ é™¤ä¸€ä¸ª tuple ï¼Œåº”è¯¥ä¼šå¯¼è‡´è¯¥é¡µä»å®ƒçš„ä¸€ä¸ªå…„å¼Ÿå§å¦¹é‚£é‡Œå·å– tuple æˆ–ä¸å®ƒçš„ä¸€ä¸ªå…„å¼Ÿå§å¦¹åˆå¹¶ã€‚å¦‚æœè¯¥é¡µçš„ä¸€ä¸ªå…„å¼Ÿå§å¦¹æœ‰å¤šä½™çš„ tuple ï¼Œè¿™äº› tuple åº”è¯¥åœ¨ä¸¤ä¸ªé¡µé¢ä¹‹é—´å¹³å‡åˆ†é…ï¼Œå¹¶ä¸”çˆ¶é¡µçš„æ¡ç›®åº”è¯¥ç›¸åº”åœ°è¢«æ›´æ–°ï¼ˆè§å›¾3ï¼‰ã€‚ç„¶è€Œï¼Œå¦‚æœå…„å¼Ÿå§å¦¹ä¹Ÿå¤„äºæœ€å°çš„å ç”¨ç‡ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªé¡µé¢å°±åº”è¯¥åˆå¹¶ï¼Œå¹¶ä»çˆ¶é¡µé¢åˆ é™¤æ¡ç›®ï¼ˆå›¾4ï¼‰ã€‚åè¿‡æ¥ï¼Œä»çˆ¶æœ¬ä¸­åˆ é™¤ä¸€ä¸ªæ¡ç›®å¯èƒ½ä¼šå¯¼è‡´çˆ¶æœ¬çš„å…¥ä½ç‡ä½äºä¸€åŠã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œçˆ¶æœ¬åº”è¯¥ä»å…¶å…„å¼Ÿå§å¦¹é‚£é‡Œå·å–æ¡ç›®ï¼Œæˆ–è€…ä¸å…„å¼Ÿå§å¦¹åˆå¹¶ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´é€’å½’åˆå¹¶ï¼Œç”šè‡³æ˜¯åˆ é™¤æ ¹èŠ‚ç‚¹ï¼Œå¦‚æœæœ€åä¸€ä¸ªæ¡ç›®ä»æ ¹èŠ‚ç‚¹ä¸Šè¢«åˆ é™¤ã€‚</p>
<p>In this exercise you will implement stealFromLeafPage(), stealFromLeftInternalPage(), stealFromRightInternalPage(), mergeLeafPages() and mergeInternalPages() in BTreeFile.java. In the first three functions you will implement code to evenly redistribute tuples/entries if the siblings have tuples/entries to spare. Remember to update the corresponding key field in the parent (look carefully at how this is done in Figure 3 - keys are effectively &quot;rotated&quot; through the parent). In stealFromLeftInternalPage()/stealFromRightInternalPage(), you will also need to update the parent pointers of the children that were moved. You should be able to reuse the function updateParentPointers() for this purpose.</p>
<p>åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†åœ¨BTreeFile.javaä¸­å®ç° stealFromLeafPage(), stealFromLeftInternalPage(), stealFromRightInternalPage(), mergeLeafPages() å’Œ mergeInternalPages() ã€‚åœ¨å‰ä¸‰ä¸ªå‡½æ•°ä¸­ï¼Œä½ å°†å®ç°ä»£ç ï¼Œåœ¨å…„å¼Ÿå§å¦¹æœ‰ tuple /æ¡ç›®çš„æƒ…å†µä¸‹å‡åŒ€åœ°é‡æ–°åˆ†é… tuple /æ¡ç›®ã€‚è®°ä½è¦æ›´æ–°çˆ¶ä»£ä¸­ç›¸åº”çš„é”®å­—æ®µï¼ˆä»”ç»†çœ‹çœ‹å›¾3ä¸­æ˜¯å¦‚ä½•åšåˆ°çš„--é”®å­—åœ¨çˆ¶ä»£ä¸­è¢«æœ‰æ•ˆåœ° &quot;æ—‹è½¬ &quot;äº†ï¼‰ã€‚åœ¨stealFromLeftInternalPage()/stealFromRightInternalPage()ä¸­ï¼Œä½ è¿˜éœ€è¦æ›´æ–°è¢«ç§»åŠ¨çš„å­é¡¹çš„çˆ¶é¡¹æŒ‡é’ˆã€‚ä½ åº”è¯¥å¯ä»¥ä¸ºè¿™ä¸ªç›®çš„é‡æ–°ä½¿ç”¨å‡½æ•° updateParentPointers()ã€‚</p>
<p>In mergeLeafPages() and mergeInternalPages() you will implement code to merge pages, effectively performing the inverse of splitLeafPage() and splitInternalPage(). You will find the function deleteParentEntry() extremely useful for handling all the different recursive cases. Be sure to call setEmptyPage() on deleted pages to make them available for reuse. As with the previous exercises, we recommend using BTreeFile.getPage() to encapsulate the process of fetching pages and keeping the list of dirty pages up to date.</p>
<p>åœ¨mergeLeafPages()å’ŒmergeInternalPages()ä¸­ï¼Œä½ å°†å®ç°åˆå¹¶é¡µé¢çš„ä»£ç ï¼Œæœ‰æ•ˆåœ°æ‰§è¡ŒsplitLeafPage()å’ŒsplitInternalPage()çš„é€†è¿‡ç¨‹ã€‚ä½ ä¼šå‘ç°å‡½æ•°deleteParentEntry()å¯¹äºå¤„ç†æ‰€æœ‰ä¸åŒçš„é€’å½’æƒ…å†µéå¸¸æœ‰ç”¨ã€‚è¯·ç¡®ä¿åœ¨è¢«åˆ é™¤çš„é¡µé¢ä¸Šè°ƒç”¨setEmptyPage()ï¼Œä»¥ä½¿å®ƒä»¬å¯ä»¥è¢«é‡æ–°ä½¿ç”¨ã€‚ä¸ä¹‹å‰çš„ç»ƒä¹ ä¸€æ ·ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨BTreeFile.getPage()æ¥å°è£…è·å–é¡µé¢çš„è¿‡ç¨‹ï¼Œå¹¶ä¿æŒè„é¡µé¢åˆ—è¡¨çš„æ›´æ–°ã€‚</p>
<h2 id="exercise-3-redistributing-pages"><a class="header" href="#exercise-3-redistributing-pages">Exercise 3: Redistributing pages</a></h2>
<p>Implement BTreeFile.stealFromLeafPage(), BTreeFile.stealFromLeftInternalPage(), BTreeFile.stealFromRightInternalPage().</p>
<p>After completing this exercise, you should be able to pass some of the unit tests in BTreeFileDeleteTest.java (such as testStealFromLeftLeafPage and testStealFromRightLeafPage). The system tests may take several seconds to complete since they create a large B+ tree in order to fully test the system.</p>
<p>å®Œæˆè¿™ä¸ªç»ƒä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeFileDeleteTest.javaä¸­çš„ä¸€äº›å•å…ƒæµ‹è¯•ï¼ˆå¦‚testStealFromLeftLeafPageå’ŒtestStealFromRightLeafPageï¼‰ã€‚ç³»ç»Ÿæµ‹è¯•å¯èƒ½éœ€è¦å‡ ç§’é’Ÿæ‰èƒ½å®Œæˆï¼Œå› ä¸ºå®ƒä»¬ä¼šåˆ›å»ºä¸€ä¸ªå¤§çš„B+æ ‘ï¼Œä»¥ä¾¿å…¨é¢æµ‹è¯•ç³»ç»Ÿã€‚</p>
<p>Exercise 4: Merging pages</p>
<p>Implement BTreeFile.mergeLeafPages() and BTreeFile.mergeInternalPages().</p>
<p>å®ç°BTreeFile.mergeLeafPages()å’ŒBTreeFile.mergeInternalPages()ã€‚</p>
<p>Now you should be able to pass all unit tests in BTreeFileDeleteTest.java and the system tests in systemtest/BTreeFileDeleteTest.java.</p>
<p>ç°åœ¨ä½ åº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeFileDeleteTest.javaä¸­çš„æ‰€æœ‰å•å…ƒæµ‹è¯•å’Œsystemtest/BTreeFileDeleteTest.javaä¸­çš„ç³»ç»Ÿæµ‹è¯•ã€‚</p>
<h2 id="5-transactions"><a class="header" href="#5-transactions">5. Transactions</a></h2>
<p>You may remember that B+ trees can prevent phantom tuples from showing up between two consecutive range scans by using next-key locking. Since SimpleDB uses page-level, strict two-phase locking, protection against phantoms effectively comes for free if the B+ tree is implemented correctly. Thus, at this point you should also be able to pass BTreeNextKeyLockingTest.</p>
<p>ä½ å¯èƒ½è¿˜è®°å¾—ï¼ŒB+æ ‘å¯ä»¥é€šè¿‡ä½¿ç”¨ä¸‹ä¸€ä¸ªé”®é”å®šæ¥é˜²æ­¢å¹»å½± tuple åœ¨ä¸¤ä¸ªè¿ç»­çš„èŒƒå›´æ‰«æä¹‹é—´å‡ºç°ã€‚ç”±äºSimpleDBä½¿ç”¨äº†é¡µçº§çš„ã€ä¸¥æ ¼çš„ä¸¤é˜¶æ®µé”å®šï¼Œå¦‚æœB+æ ‘è¢«æ­£ç¡®å®ç°ï¼Œå¯¹å¹»å½±çš„ä¿æŠ¤å®é™…ä¸Šæ˜¯å…è´¹çš„ã€‚å› æ­¤ï¼Œåœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ ä¹Ÿåº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeNextKeyLockingTestã€‚</p>
<p>Additionally, you should be able to pass the tests in test/simpledb/BTreeDeadlockTest.java if you have implemented locking correctly inside of your B+ tree code.</p>
<p>æ­¤å¤–ï¼Œå¦‚æœä½ åœ¨B+æ ‘ä»£ç ä¸­æ­£ç¡®å®ç°äº†é”å®šï¼Œä½ åº”è¯¥èƒ½å¤Ÿé€šè¿‡test/simpledb/BTreeDeadlockTest.javaçš„æµ‹è¯•ã€‚</p>
<p>If everything is implemented correctly, you should also be able to pass the BTreeTest system test. We expect many people to find BTreeTest difficult, so it's not required, but we'll give extra credit to anyone who can run it successfully. Please note that this test may take up to a minute to complete.</p>
<p>å¦‚æœä¸€åˆ‡å®æ–½æ­£ç¡®ï¼Œä½ ä¹Ÿåº”è¯¥èƒ½å¤Ÿé€šè¿‡BTreeTestç³»ç»Ÿæµ‹è¯•ã€‚æˆ‘ä»¬é¢„è®¡å¾ˆå¤šäººä¼šè§‰å¾—BTreeTestå¾ˆéš¾ï¼Œæ‰€ä»¥å®ƒä¸æ˜¯å¿…é¡»çš„ï¼Œä½†æˆ‘ä»¬ä¼šç»™èƒ½å¤ŸæˆåŠŸè¿è¡Œå®ƒçš„äººåŠ åˆ†ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸ªæµ‹è¯•å¯èƒ½éœ€è¦ä¸€åˆ†é’Ÿçš„æ—¶é—´æ¥å®Œæˆã€‚</p>
<h2 id="6-extra-credit"><a class="header" href="#6-extra-credit">6. Extra Credit</a></h2>
<p>Bonus Exercise 5: (10% extra credit)</p>
<p>Create and implement a class called BTreeReverseScan which scans the BTreeFile in reverse, given an optional IndexPredicate.</p>
<p>åˆ›å»ºå¹¶å®ç°ä¸€ä¸ªåä¸ºBTreeReverseScançš„ç±»ï¼Œè¯¥ç±»åœ¨ç»™å®šä¸€ä¸ªå¯é€‰çš„IndexPredicateåï¼Œåå‘æ‰«æBTreeFileã€‚</p>
<p>You can use BTreeScan as a starting point, but you will probably need to implement a reverse iterator in BTreeFile. You will also likely need to implement a separate version of BTreeFile.findLeafPage(). We have provided reverse iterators on BTreeLeafPage and BTreeInternalPage which you may find useful. You should also write code to test that your implementation works correctly. BTreeScanTest.java is a good place to look for ideas.</p>
<p>ä½ å¯ä»¥ä½¿ç”¨BTreeScanä½œä¸ºèµ·ç‚¹ï¼Œä½†ä½ å¯èƒ½éœ€è¦åœ¨BTreeFileä¸­å®ç°ä¸€ä¸ªåå‘è¿­ä»£å™¨ã€‚ä½ ä¹Ÿå¯èƒ½éœ€è¦å®ç°ä¸€ä¸ªå•ç‹¬çš„BTreeFile.findLeafPage()ç‰ˆæœ¬ã€‚æˆ‘ä»¬å·²ç»åœ¨BTreeLeafPageå’ŒBTreeInternalPageä¸Šæä¾›äº†åå‘è¿­ä»£å™¨ï¼Œä½ å¯èƒ½ä¼šå‘ç°å®ƒå¾ˆæœ‰ç”¨ã€‚ä½ è¿˜åº”è¯¥ç¼–å†™ä»£ç æ¥æµ‹è¯•ä½ çš„å®ç°æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚BTreeScanTest.javaæ˜¯ä¸€ä¸ªå¯»æ‰¾æ€è·¯çš„å¥½åœ°æ–¹ã€‚</p>
<h2 id="7-logistics"><a class="header" href="#7-logistics">7. Logistics</a></h2>
<p>You must submit your code (see below) as well as a short (1 page, maximum) writeup describing your approach. This writeup should:</p>
<p>ä½ å¿…é¡»æäº¤ä½ çš„ä»£ç ï¼ˆè§ä¸‹æ–‡ï¼‰ï¼Œä»¥åŠæè¿°ä½ çš„æ–¹æ³•çš„ç®€çŸ­ï¼ˆæœ€å¤š1é¡µï¼‰çš„æ–‡ç« ã€‚è¿™ç¯‡æŠ¥å‘Šåº”è¯¥</p>
<p>Describe any design decisions you made, including anything that was difficult or unexpected.</p>
<p>æè¿°ä½ æ‰€åšçš„ä»»ä½•è®¾è®¡å†³å®šï¼ŒåŒ…æ‹¬ä»»ä½•å›°éš¾æˆ–æ„å¤–ã€‚</p>
<p>Discuss and justify any changes you made outside of BTreeFile.java.</p>
<p>è®¨è®ºå¹¶è®ºè¯ä½ åœ¨BTreeFile.javaä¹‹å¤–æ‰€åšçš„ä»»ä½•æ”¹åŠ¨ã€‚</p>
<p>How long did this lab take you? Do you have any suggestions for ways to improve it?</p>
<p>è¿™ä¸ªå®éªŒèŠ±äº†ä½ å¤šé•¿æ—¶é—´ï¼Ÿä½ æœ‰ä»€ä¹ˆå»ºè®®å¯ä»¥æ”¹è¿›å®ƒå—ï¼Ÿ</p>
<p>Optional: If you did the extra credit exercise, explain your implementation and show us that you thoroughly tested it.</p>
<p>å¯é€‰ï¼šå¦‚æœä½ åšäº†åŠ åˆ†ç»ƒä¹ ï¼Œè¯·è§£é‡Šä½ çš„å®ç°ï¼Œå¹¶å‘æˆ‘ä»¬å±•ç¤ºä½ å½»åº•æµ‹è¯•äº†å®ƒã€‚</p>
<h2 id="71-collaboration"><a class="header" href="#71-collaboration">7.1. Collaboration</a></h2>
<p>This lab should be manageable for a single person, but if you prefer to work with a partner, this is also OK. Larger groups are not allowed. Please indicate clearly who you worked with, if anyone, on your writeup.</p>
<p>è¿™ä¸ªå®éªŒå¯¹ä¸€ä¸ªäººæ¥è¯´åº”è¯¥æ˜¯å¯ä»¥åº”ä»˜çš„ï¼Œä½†å¦‚æœä½ å–œæ¬¢å’Œä¸€ä¸ªä¼™ä¼´ä¸€èµ·å·¥ä½œï¼Œè¿™ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ä¸å…è®¸æœ‰è¾ƒå¤§çš„å›¢ä½“ã€‚å¦‚æœæœ‰çš„è¯ï¼Œè¯·åœ¨ä½ çš„æŠ¥å‘Šä¸­æ˜ç¡®æŒ‡å‡ºä½ å’Œè°ä¸€èµ·å·¥ä½œã€‚</p>
<h2 id="72-submitting-your-assignment"><a class="header" href="#72-submitting-your-assignment">7.2. Submitting your assignment</a></h2>
<p>We will be using gradescope to autograde all programming assignments. You should have all been invited to the class instance; if not, please let us know and we can help you set up. You may submit your code multiple times before the deadline; we will use the latest version as determined by gradescope. Place the write-up in a file called lab3-writeup.txt with your submission. You also need to explicitly add any other files you create, such as new *.java files.</p>
<p>æˆ‘ä»¬å°†ä½¿ç”¨gradescopeå¯¹æ‰€æœ‰ç¼–ç¨‹ä½œä¸šè¿›è¡Œè‡ªåŠ¨è¯„åˆ†ã€‚ä½ ä»¬åº”è¯¥éƒ½è¢«é‚€è¯·åˆ°ç­çº§å®ä¾‹ä¸­ï¼›å¦‚æœæ²¡æœ‰ï¼Œè¯·å‘Šè¯‰æˆ‘ä»¬ï¼Œæˆ‘ä»¬å¯ä»¥å¸®åŠ©ä½ ä»¬è®¾ç½®ã€‚ä½ å¯ä»¥åœ¨æˆªæ­¢æ—¥æœŸå‰å¤šæ¬¡æäº¤ä½ çš„ä»£ç ï¼›æˆ‘ä»¬å°†ä½¿ç”¨ç”±gradescopeç¡®å®šçš„æœ€æ–°ç‰ˆæœ¬ã€‚æŠŠå†™å¥½çš„ä¸œè¥¿æ”¾åœ¨ä¸€ä¸ªå«lab3-writeup.txtçš„æ–‡ä»¶é‡Œï¼Œå’Œä½ çš„æäº¤ä¸€èµ·ã€‚ä½ è¿˜éœ€è¦æ˜ç¡®åœ°æ·»åŠ ä½ åˆ›å»ºçš„ä»»ä½•å…¶ä»–æ–‡ä»¶ï¼Œå¦‚æ–°çš„*.javaæ–‡ä»¶ã€‚</p>
<p>The easiest way to submit to gradescope is with .zip files containing your code. On Linux/MacOS, you can do so by running the following command:</p>
<p>å‘ gradescope æäº¤çš„æœ€ç®€å•æ–¹æ³•æ˜¯ä½¿ç”¨åŒ…å«ä½ çš„ä»£ç çš„ .zip æ–‡ä»¶ã€‚åœ¨Linux/MacOSä¸Šï¼Œä½ å¯ä»¥é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥å®ç°ã€‚</p>
<pre><code>$ zip -r submission.zip src/ lab5-writeup.txt
</code></pre>
<h2 id="73-submitting-a-bug"><a class="header" href="#73-submitting-a-bug">7.3. Submitting a bug</a></h2>
<p>SimpleDB is a relatively complex piece of code. It is very possible you are going to find bugs, inconsistencies, and bad, outdated, or incorrect documentation, etc.</p>
<p>SimpleDBæ˜¯ä¸€ä¸ªç›¸å¯¹å¤æ‚çš„ä»£ç ã€‚ä½ å¾ˆå¯èƒ½ä¼šå‘ç°é”™è¯¯ã€ä¸ä¸€è‡´ï¼Œä»¥åŠç³Ÿç³•çš„ã€è¿‡æ—¶çš„æˆ–ä¸æ­£ç¡®çš„æ–‡æ¡£ç­‰ç­‰ã€‚</p>
<p>We ask you, therefore, to do this lab with an adventurous mindset. Don't get mad if something is not clear, or even wrong; rather, try to figure it out yourself or send us a friendly email.</p>
<p>å› æ­¤ï¼Œæˆ‘ä»¬è¦æ±‚ä½ ä»¥ä¸€ç§å†’é™©çš„å¿ƒæ€æ¥åšè¿™ä¸ªå®éªŒã€‚å¦‚æœæœ‰ä¸æ¸…æ¥šçš„åœ°æ–¹ï¼Œç”šè‡³æ˜¯é”™è¯¯çš„åœ°æ–¹ï¼Œä¸è¦ç”Ÿæ°”ï¼›è€Œæ˜¯è¦è‡ªå·±å°è¯•å»å¼„æ¸…æ¥šï¼Œæˆ–è€…ç»™æˆ‘ä»¬å‘ä¸€å°å‹å¥½çš„ç”µå­é‚®ä»¶ã€‚</p>
<p>Please submit (friendly!) bug reports to 6.830-staff@mit.edu. When you do, please try to include:</p>
<p>A description of the bug.
A .java file we can drop in the test/simpledb directory, compile, and run.
A .txt file with the data that reproduces the bug. We should be able to convert it to a .dat file using HeapFileEncoder.
You can also post on the class page on Piazza if you feel you have run into a bug.</p>
<p>è¯·æäº¤ï¼ˆå‹å¥½çš„ï¼ï¼‰é”™è¯¯æŠ¥å‘Šåˆ°6.830-staff@mit.eduã€‚å½“ä½ è¿™æ ·åšæ—¶ï¼Œè¯·å°½é‡åŒ…æ‹¬ã€‚</p>
<p>å¯¹è¯¥é”™è¯¯çš„æè¿°ã€‚
ä¸€ä¸ªæˆ‘ä»¬å¯ä»¥æ”¾åœ¨test/simpledbç›®å½•ä¸‹çš„.javaæ–‡ä»¶ï¼Œå¹¶è¿›è¡Œç¼–è¯‘å’Œè¿è¡Œã€‚
ä¸€ä¸ªåŒ…å«å†ç°è¯¥é”™è¯¯çš„æ•°æ®çš„.txtæ–‡ä»¶ã€‚æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿç”¨HeapFileEncoderå°†å…¶è½¬æ¢ä¸º.datæ–‡ä»¶ã€‚
å¦‚æœä½ è§‰å¾—ä½ é‡åˆ°äº†ä¸€ä¸ªbugï¼Œä½ ä¹Ÿå¯ä»¥åœ¨Piazzaçš„ç±»é¡µé¢ä¸Šå‘å¸–ã€‚</p>
<h2 id="74-grading"><a class="header" href="#74-grading">7.4 Grading</a></h2>
<p>75% of your grade will be based on whether or not your code passes the system test suite we will run over it. These tests will be a superset of the tests we have provided. Before handing in your code, you should make sure it produces no errors (passes all of the tests) from both ant test and ant systemtest.</p>
<p>Important: before testing, gradescope will replace your build.xml, HeapFileEncoder.java and the entire contents of the test directory with our version of these files. This means you cannot change the format of .dat files! You should also be careful changing our APIs. You should test that your code compiles the unmodified tests.</p>
<p>You should get immediate feedback and error outputs for failed tests (if any) from gradescope after submission. The score given will be your grade for the autograded portion of the assignment. An additional 25% of your grade will be based on the quality of your writeup and our subjective evaluation of your code. This part will also be published on gradescope after we finish grading your assignment.</p>
<p>We had a lot of fun designing this assignment, and we hope you enjoy hacking on it!</p>
<p>ä½ çš„æˆç»©çš„75%å°†åŸºäºä½ çš„ä»£ç æ˜¯å¦é€šè¿‡æˆ‘ä»¬å°†å¯¹å…¶è¿›è¡Œçš„ç³»ç»Ÿæµ‹è¯•å¥—ä»¶ã€‚è¿™äº›æµ‹è¯•å°†æ˜¯æˆ‘ä»¬æä¾›çš„æµ‹è¯•çš„ä¸€ä¸ªè¶…é›†ã€‚åœ¨äº¤å‡ºä½ çš„ä»£ç ä¹‹å‰ï¼Œä½ åº”è¯¥ç¡®ä¿å®ƒåœ¨ant testå’Œant systemtestä¸­æ²¡æœ‰äº§ç”Ÿé”™è¯¯ï¼ˆé€šè¿‡æ‰€æœ‰çš„æµ‹è¯•ï¼‰ã€‚</p>
<p>é‡è¦çš„æ˜¯ï¼šåœ¨æµ‹è¯•ä¹‹å‰ï¼Œgradescope ä¼šç”¨æˆ‘ä»¬çš„ç‰ˆæœ¬æ›¿æ¢ä½ çš„ build.xmlã€HeapFileEncoder.java ä»¥åŠæµ‹è¯•ç›®å½•ä¸­çš„å…¨éƒ¨å†…å®¹ã€‚è¿™æ„å‘³ç€ä½ ä¸èƒ½æ”¹å˜.datæ–‡ä»¶çš„æ ¼å¼! ä½ ä¹Ÿåº”è¯¥å°å¿ƒæ”¹å˜æˆ‘ä»¬çš„APIã€‚ä½ åº”è¯¥æµ‹è¯•ä½ çš„ä»£ç æ˜¯å¦ç¼–è¯‘äº†æœªä¿®æ”¹çš„æµ‹è¯•ã€‚</p>
<p>åœ¨æäº¤åï¼Œä½ åº”è¯¥ä» gradescope å¾—åˆ°å³æ—¶åé¦ˆå’Œå¤±è´¥æµ‹è¯•çš„é”™è¯¯è¾“å‡ºï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚ç»™å‡ºçš„åˆ†æ•°å°†æ˜¯ä½ åœ¨ä½œä¸šçš„è‡ªåŠ¨è¯„åˆ†éƒ¨åˆ†çš„æˆç»©ã€‚å¦å¤–25%çš„åˆ†æ•°å°†åŸºäºä½ çš„å†™ä½œè´¨é‡å’Œæˆ‘ä»¬å¯¹ä½ ä»£ç çš„ä¸»è§‚è¯„ä»·ã€‚åœ¨æˆ‘ä»¬ç»™ä½ çš„ä½œä¸šè¯„åˆ†åï¼Œè¿™éƒ¨åˆ†ä¹Ÿå°†åœ¨ gradescope ä¸Šå…¬å¸ƒã€‚</p>
<p>æˆ‘ä»¬åœ¨è®¾è®¡è¿™é¡¹ä½œä¸šæ—¶éå¸¸æœ‰è¶£ï¼Œæˆ‘ä»¬å¸Œæœ›ä½ èƒ½äº«å—åˆ°é»‘å®¢çš„ä¹è¶£!</p>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../6.830/cn/5-lab4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../6.830/cn/7-lab6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../6.830/cn/5-lab4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../../6.830/cn/7-lab6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "6.830/cn/6-lab5.md"
    </script>


    <!-- Custom JS scripts -->


</body>
</html>