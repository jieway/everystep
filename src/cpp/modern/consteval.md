# C++ 20 consteval 的作用？

讲 `consteval` 之前要先讲解 `constexpr` ，`constexpr` 是 C++11 引入的一个关键字，用于定义常量表达式。`constexpr` 的主要作用是指示编译器在编译时计算表达式的值，从而使得该值在编译时就已经确定。使用 `constexpr` 可以创建编译时的常量，还可以定义能够在编译时计算结果的函数。

### 作用

1. **编译时常量**：使用 `constexpr` 定义的变量必须在编译时就能确定其值。

2. **编译时函数求值**：`constexpr` 函数能够在编译时进行计算，只要其所有参数都是编译时常量。

3. **模板和类型安全**：`constexpr` 在模板编程和元编程中非常有用，它确保了类型安全，并能在编译时进行复杂的计算。

4. **性能优化**：`constexpr` 可以减少运行时的计算，因为相关计算已经在编译时完成。

### 编译时常量

```cpp
constexpr int max_size = 100;  // 编译时常量
int array[max_size];           // 使用常量定义数组大小
```

这里，`max_size` 是一个编译时常量，可以用作数组的大小，这是因为其值在编译时就已经确定了。

### 编译时函数

```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : (n * factorial(n - 1));
}

int main() {
    constexpr int fac_5 = factorial(5); // 编译时计算 5 的阶乘
    int array[fac_5];                  // 使用结果作为数组大小
    return 0;
}
```

这个示例中的 `factorial` 函数是一个 `constexpr` 函数，能够在编译时计算阶乘。因此，`fac_5` 是一个编译时常量，其值为 `5!`（即 120），可以用于定义数组的大小。

### constexpr 总结

`constexpr` 是 C++ 中的一个强大特性，允许在编译时进行计算，从而提供性能优化和类型安全。它对于编写高效、类型安全的模板代码尤为重要。通过在编译时执行更多的计算，`constexpr` 可以减少运行时的负担，使得程序更加高效。

要判断一个表达式是否能在编译时计算，关键在于检查其是否完全由常量、常量表达式、constexpr 变量/函数构成，并且其操作符也支持在编译时求值。编译器的具体实现和优化策略也会影响是否能在编译时计算表达式。

## consteval 的作用，和 constexpr 的区别？

`consteval` 和 `constexpr` 都是 C++ 中用于编译时计算的关键字，但它们有一些重要的区别。

### consteval

1. **引入时间**: `consteval` 是在 C++20 引入的。
2. **含义**: `consteval` 指定的函数必须在编译时进行求值。
3. **限制**: 如果一个 `consteval` 函数在编译时不能被求值，那么会产生一个编译错误。
4. **用途**: `consteval` 用于创建那些一定需要在编译时求值的函数，比如用于元编程或者生成编译时常量。

### constexpr

1. **引入时间**: `constexpr` 是在 C++11 引入的，后续的标准中进行了扩展。
2. **含义**: `constexpr` 指示一个函数或对象可能在编译时求值。
3. **灵活性**: `constexpr` 函数或对象可以在编译时也可以在运行时求值。如果编译器能够在编译时求值，它通常会这样做；否则，该函数或对象就会在运行时求值。
4. **用途**: `constexpr` 用于创建可以在编译时或运行时求值的函数或对象，提供了更大的灵活性。

### 区别总结

- **编译时求值的强制性**: `consteval` 强制其函数在编译时求值，而 `constexpr` 则不强制。
- **应用场景**: `consteval` 用于那些必须在编译时求值的场景，而 `constexpr` 更适用于那些编译时求值能带来性能优化但非必需的情况。
- **错误处理**: 如果 `consteval` 函数不能在编译时求值，将导致编译错误；而 `constexpr` 函数则会退化为普通函数，在运行时求值。

简而言之，`consteval` 保证了函数必定在编译时求值，而 `constexpr` 提供了在编译时求值的可能性，但并非强制性的。

## 如何区分在编译期求值还是在运行期求值？

要理解 `constexpr` 和 `consteval` 的区别，关键在于区分哪些情况下一个表达式或函数是在编译期能确定的（即完全由编译时常量和操作组成），以及哪些情况下需要到运行期才能确定。以下是一些例子，帮助区分这两种情况：

### 例子 1: 纯编译期计算
```cpp
consteval int Square(int n) {
    return n * n;
}

constexpr int compileTimeResult = Square(4); // 正确: 编译期可以计算
```

在这里，`Square` 是 `consteval` 函数，必须在编译期计算。传递给 `Square` 函数的参数 `4` 是一个编译期常量，因此整个表达式可以在编译期计算。

### 例子 2: 运行期输入

```cpp
constexpr int Square(int n) {
    return n * n;
}

int main() {
    int runtimeValue = 5;
    int runtimeResult = Square(runtimeValue); // 正确: 运行期计算
}
```

此处 `Square` 是 `constexpr` 函数，它可以在编译期或运行期计算。`runtimeValue` 是一个运行期变量，因此 `Square(runtimeValue)` 必须在运行期计算。

### 例子 3: 编译期和运行期混合

```cpp
constexpr int Square(int n) {
    return n * n;
}

constexpr int compileTimeResult = Square(4); // 正确: 编译期计算

int main() {
    int runtimeValue = 5;
    constexpr int compileTimeResult2 = Square(runtimeValue); // 错误: 尝试在编译期计算运行期变量
}
```

在 `main` 函数中，尝试将运行期变量 `runtimeValue` 传递给 `constexpr` 函数并期望其在编译期计算，这是不允许的，因为 `runtimeValue` 的值只有在运行期才确定。

### 例子 4: `consteval` 强制编译期计算

```cpp
consteval int Add(int a, int b) {
    return a + b;
}

int main() {
    int x = 10;
    int result = Add(x, 20); // 错误: `consteval` 函数不能使用运行期变量
}
```
在这个例子中，尽管 `20` 是编译期常量，`x` 是运行期变量。因为 `Add` 是 `consteval` 函数，它不能接受运行期变量作为参数。

- 代码中的 `x` 赋值为 `10` 看似是一个常量，但它仍然被视为运行期变量。为什么？

在 C++ 中，即使变量 `x` 在代码中被赋予了一个字面值（例如 `10`），它仍然被视为运行期变量。这是因为：

1. **编译器视角**：尽管 `x` 被赋予了一个固定的值，但从编译器的角度来看，它是一个普通变量，其值可以在程序运行时更改。编译器在处理 `x` 时，并不会将其视为一个编译期常量。

2. **变量存储**：`x` 被存储在程序的栈上或其他非静态存储区域，这意味着它在程序执行时才被分配和初始化。即便它的初始值是常量，它的存储和生命周期特性使得它是一个运行期变量。

3. **常量与变量的区别**：在 C++ 中，`const` 关键字用于定义常量，而非 `const` 的普通变量即使被赋予常量值也仍被视为变量。例如：

   ```cpp
   const int constValue = 10;  // 编译期常量
   int x = 10;                 // 运行期变量
   ```

   在这个例子中，`constValue` 是一个编译期常量，而 `x` 是一个运行期变量，尽管它们都被赋予了同样的值。

4. **`consteval` 的要求**：`consteval` 函数要求所有参数必须是字面量或编译期常量。即使 `x` 被赋予了一个常量值，它在定义时并没有被标记为 `constexpr` 或 `const`，因此不能满足 `consteval` 函数的要求。

因此，即使 `x` 的值在某种意义上是“已知的”，在 C++ 的类型系统和编译器规则下，它仍然是一个运行期变量。

- 在 `consteval` 函数中，所有的参数必须是编译期常量，即它们的值必须在编译时就已经完全确定，不仅仅是赋值为常量。换句话说，即使 `x` 被赋予了一个字面量（如 `10`），在编译器看来，它仍然是一个普通的运行期变量，因为它有可能在程序运行时被改变。

- 对于 `constexpr` 函数，如果所有的参数在编译时都是常量，那么函数可以在编译时执行。但如果参数中包含运行时才能确定的变量，函数调用就会被推迟到运行时。

上述例子中，即使 `x` 的值被设置为 `10`，它仍然是在运行时被分配和初始化的。因此，尽管其赋值看起来像常量，它在 `consteval` 函数中的使用仍然是非法的，因为 `consteval` 要求所有输入必须是编译时常量。

### 总结
- `constexpr` 允许函数或对象在编译期或运行期求值。如果所有输入都是编译期常量，`constexpr` 函数会在编译期求值。
- `consteval` 强制函数必须在编译期求值。任何包含运行期变量的 `consteval` 函数调用都会导致编译错误。
- 识别一个表达式是编译期还是运行期可以确定，关键在于它的所有组成部分（包括参数和操作符）是否都是编译期常量。
