# 大小端

大小端是计算机存储多字节数据的一种方式，主要涉及到字节的顺序问题。这两种方式的主要区别在于多字节数据的最高有效字节（Most Significant Byte，MSB）和最低有效字节（Least Significant Byte，LSB）在内存中的存放顺序。

### 一个具体的例子

- 大端（Big Endian）：最高有效字节在最低内存地址处，最低有效字节在最高内存地址处。比如一个32位整数0x12345678在内存中的存储顺序（从低地址到高地址）为：12 34 56 78。

- 小端（Little Endian）：最低有效字节在最低内存地址处，最高有效字节在最高内存地址处。同样的32位整数0x12345678在内存中的存储顺序（从低地址到高地址）为：78 56 34 12。

举个例子，假设我们有一个32位的整数0x12345678，我们将其存储在内存地址0x100开始的位置。

如果我们的机器是大端模式，那么在内存中的存储顺序为：
```
0x100: 12
0x101: 34
0x102: 56
0x103: 78
```

如果我们的机器是小端模式，那么在内存中的存储顺序为：
```
0x100: 78
0x101: 56
0x102: 34
0x103: 12
```

### 为什么字节顺序没有统一？

字节顺序的不统一主要是由于历史原因和技术选择造成的。在计算机历史的早期，不同的硬件制造商选择了不同的字节顺序，这主要是由于他们对硬件设计的不同理解和优化策略。例如，一些制造商认为大端序更符合人类的阅读习惯，因为最重要的字节（类似于我们阅读数字时的最高位）在前。而另一些制造商则认为小端序在处理某些类型的运算（如增量或减量运算）时更高效。

尽管现在我们已经意识到这种差异可能会导致一些问题，但由于大量的硬件和软件已经依赖于特定的字节顺序，所以改变这一点是非常困难的。此外，由于大多数情况下，程序员并不需要关心字节顺序，因此这个问题通常只在特定的场景（如网络通信或二进制文件处理）中才会显现出来。

因此，尽管统一字节顺序可能会带来一些好处，但由于历史原因和实际的技术挑战，仍然需要处理不同的字节顺序。为了解决由此产生的问题，我们通常会在需要的地方使用特定的函数或协议来进行字节顺序的转换。

### 使用场景

在网络通信中，通常采用大端（Big-Endian）字节序，这也被称为网络字节序。这是因为在早期的网络协议（如TCP/IP）中，大端字节序被选为标准。因此，当我们在网络中发送和接收数据时，无论主机使用的是大端字节序还是小端字节序，都需要将数据转换为网络字节序。

在计算机硬件中，字节序的选择取决于具体的处理器设计。有些处理器（如大多数Intel和AMD的x86和x64处理器）使用小端（Little-Endian）字节序，有些处理器（如IBM的PowerPC和Oracle（Sun）的SPARC）使用大端字节序。还有一些处理器（如ARM）可以配置为使用大端或小端字节序。但是，一旦选择了操作系统，字节序就会固定下来。例如，虽然ARM处理器可以配置为大端或小端，但是最常见的两个操作系统——Android（来自Google）和iOS（来自Apple）——都只在小端模式下运行。

在查看表示整数数据的字节序列时，字节排序也很重要，这在检查机器级程序时经常发生。例如，一个反汇编器生成的机器级代码行可能包含一个十六进制的字节序列，这个序列是一条指令的字节级表示。在小端机器上，字节序列的自然写法是最低编号的字节在左边，最高编号的字节在右边，但这与我们通常写数字的方式相反，即最高有效位在左边，最低有效位在右边。
