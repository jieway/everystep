

### <a name="Ri-global"></a>I.2: 避免非 `const` 全局变量

##### 理由

非 `const` 全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

##### 示例

    struct Data {
        // ... 大量成员 ...
    } data;            //  非 const 数据

    void compute()     // 请勿这样做
    {
        // ... 使用 data ...
    }

    void output()     // 请勿这样做
    {
        // ... 使用 data ...
    }

哪个可能会修改 `data` 呢？

**警告**: 全局对象的初始化并不是完全有序的。
当使用全局对象时，应当用常量为之初始化。
还要注意，即便对于 `const` 对象，也可能发生未定义的初始化顺序。

##### 例外

全局对象通常优于单例。

##### 注解

全局常量是有益的。

##### 注解

针对全局变量的规则同样适用于命名空间作用域的变量。

**替代方案**: 如果你用全局（或者更一般地说命名空间作用域）数据来避免复制操作的话，请考虑把数据以 `const` 引用的形式进行传递的方案。
另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。

**警告**: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。
指向可变数据的每个指针或引用都是潜在的数据竞争。

使用全局指针或引用来访问和修改非 const 且非局部的数据，并非是比非 const 全局变量更好的替代方案，
这是因为它并不能解决隐藏依赖性或潜在竞争条件的问题。

##### 注解

不可变数据是不会带来数据竞争条件的。

**参见**: 另见[关于调用函数的规则](#SS-call)。

#### 注解

这条规则是“避免”，而不是“不要用”。当然是有（罕见）例外的，比如 `cin`、`cout` 和 `cerr`。

##### 强制实施

【简单】 报告所有在命名空间作用域中声明的非 `const` 变量和全局的指向非 const 数据的指针/引用。





为了深入解释和对比为什么避免非 `const` 全局变量是一个好实践，我们可以通过比较两个具体的编程例子来理解这一点：一个使用非 `const` 全局变量，另一个避免使用它们。这种比较能够更清晰地展示使用非 `const` 全局变量可能带来的问题，以及通过其他方式管理依赖和状态可以带来的好处。

### 使用非 `const` 全局变量的例子

假设我们正在开发一个游戏，其中有一个全局变量用于跟踪玩家的总分数：

```cpp
int totalScore; // 非 const 全局变量

void addScore(int score) {
    totalScore += score; // 修改全局变量
}

void resetScore() {
    totalScore = 0; // 也修改全局变量
}
```

在这个例子中，`totalScore` 是一个非 `const` 全局变量，它被多个函数修改。这样的设计有几个问题：

- **隐藏的依赖关系**：`addScore` 和 `resetScore` 函数的行为依赖于全局变量 `totalScore`。这个依赖关系在函数签名中并不明显，使得理解和维护代码变得更加困难。
- **不可预测的变动**：任何部分的代码都可能修改 `totalScore`，导致调试和跟踪问题变得复杂。
- **并发问题**：如果在多线程环境中，不同的线程试图同时修改 `totalScore`，可能会导致数据竞争和不一致的状态。

### 避免非 `const` 全局变量的替代方案

作为替代，我们可以将数据封装在一个类中，并通过成员函数来管理状态：

```cpp
class ScoreKeeper {
public:
    void addScore(int score) {
        totalScore += score;
    }

    void resetScore() {
        totalScore = 0;
    }

    int getTotalScore() const {
        return totalScore;
    }

private:
    int totalScore = 0; // 封装在类内部
};
```

在这个改进的设计中：

- **明确的依赖关系**：`ScoreKeeper` 类明确管理着分数的状态，任何对分数的修改都通过其成员函数进行，这使得依赖关系变得清晰。
- **控制变动**：分数的修改被限制在类的成员函数内，减少了意外修改的风险。
- **更好的并发控制**：通过使用适当的同步机制（例如锁），`ScoreKeeper` 可以安全地在多线程环境中使用，减少数据竞争的风险。

### 结论

通过比较，我们可以看到避免非 `const` 全局变量并采用封装的方式管理状态和依赖关系，不仅可以使代码更加清晰和可维护，而且还能提高代码的安全性和稳定性。这就是为什么在现代C++编程实践中，推荐使用类和对象来管理状态，而避免使用非 `const` 全局变量的原因。