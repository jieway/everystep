# Bloom 过滤器

Bloom 过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它的特点是可能会误报（即错误地表示某个元素在集合中），但不会漏报（如果表示某个元素不在集合中，则该元素确实不在集合中）。由于其独特的特性和高效的空间利用率，Bloom过滤器在各种应用中非常有用，特别是在需要快速检查元素是否存在于一个非常大的集合中时。

## 1. Bloom 过滤器的作用

下面用一个简单的例子来说明 Bloom 过滤器的作用：

**场景**：假设你正在运行一个大型在线图书馆，每当用户搜索一本书时，你需要快速判断这本书是否在库存中。

**问题**：图书馆拥有数百万本书，如果每次搜索都查找整个数据库，这将非常耗时。

**解决方案**：使用 Bloom 过滤器。

**如何工作**：
1. **初始化**：当图书馆收到一本新书时，将这本书的标识（如书名或ISBN）添加到 Bloom 过滤器中。
2. **搜索**：用户搜索一本书时，先通过 Bloom 过滤器检查。
   - 如果 Bloom 过滤器表示没有这本书，那么就可以肯定图书馆中没有这本书，无需查询数据库。
   - 如果 Bloom 过滤器表示有这本书，这时可能存在误判（认为有，但实际没有），需要进一步在数据库中确认。

**效果**：Bloom 过滤器能快速过滤掉绝大多数不存在的搜索请求，减轻数据库负担。但它不能100%准确地确认图书馆是否有某本书，可能需要数据库进一步核实。

简而言之，Bloom 过滤器是一种高效的方法来减少不必要的数据库查询，尤其在处理大量数据时非常有效。

## 2. 发展历史

布隆过滤器（Bloom Filter）是由布尔顿·布隆（Burton Howard Bloom）在1970年提出的一种数据结构。下面是它的简明发展历史总结：

1. **1970年**：布隆过滤器由布尔顿·布隆首次提出。最初的设计目的是高效地处理分布式系统中的数据库通信问题，尤其是为了减少不必要的数据传输。

2. **之后几十年**：布隆过滤器由于其空间效率和查询效率得到广泛应用，特别是在网络和分布式系统中。它被用于快速查找和缓存优化，如网络路由器中的IP地址查找、网络爬虫的网页去重等。

3. **21世纪初**：随着互联网技术的发展，布隆过滤器在网络应用中的作用变得更加重要，例如在分布式数据库、缓存系统和网络爬虫中进行快速集合成员检查。

4. **近年来**：布隆过滤器的变种和改进版本相继出现，以适应更复杂的现代计算需求。例如，计数布隆过滤器（Counting Bloom Filter）允许元素被删除，标量布隆过滤器（Scalable Bloom Filter）可以根据需要动态调整大小。

总的来说，布隆过滤器自从1970年被提出以来，因其高效的空间利用率和快速的查询能力，在计算机科学的众多领域得到了广泛应用，并且随着新需求和技术的发展不断演化。

## 3. 性质

从理论的角度来看，布隆过滤器具有以下几个主要性质：

1. **概率型数据结构**：布隆过滤器不存储元素本身，而是通过几个哈希函数将元素映射到一个位数组中。因此，它不能确切地说某个元素是否在集合中，只能说元素“可能在”或“绝对不在”。

2. **空间效率**：与传统的列表或集合相比，布隆过滤器使用极少的空间来存储大量数据的存在信息。这使得它非常适合于存储大型集合的存在检查，尤其是当元素本身很大时。

3. **误报（False Positives）**：布隆过滤器可能会错误地判断某个不在集合中的元素为存在于集合中（即误报）。这种误判的概率可以通过调整位数组的大小和使用的哈希函数的数量来减少。

4. **零误判（Zero False Negatives）**：布隆过滤器从不会错误地判断某个在集合中的元素为不存在。如果它说某个元素不在集合中，那么这个元素确实不在集合中。

5. **不可逆**：一旦元素被添加到布隆过滤器中，就无法从中删除它。这是因为当一个元素被添加时，会影响位数组中的几个位置，而这些位置也可能被其他元素共享。

6. **哈希函数的选择**：布隆过滤器的效率和准确性很大程度上依赖于所选用的哈希函数。理想的哈希函数应该是独立的、均匀分布的，以尽量减少哈希冲突和误报的概率。

7. **可扩展性**：标准布隆过滤器的大小在创建时就固定了，但也有可扩展的变种（如标量布隆过滤器），它们可以根据需要动态调整大小。

总结来说，布隆过滤器是一种以牺牲准确性为代价来极大地节省存储空间和提高查询效率的数据结构，非常适用于那些可以容忍一定误报率的应用场景。

## 4. 实现

布隆过滤器的实现可以简洁地概括为以下几个步骤：

1. **初始化**：创建一个固定大小的位数组，初始时所有位都设为0。

2. **选择哈希函数**：选定几个（通常是2到3个）不同的哈希函数，这些哈希函数应该能将输入均匀地映射到位数组的不同位置。

3. **添加元素**：
   - 对于要添加的每个元素，使用所有的哈希函数分别对其进行哈希计算。
   - 根据每个哈希函数计算出的位置，将位数组对应位置的值设为1。

4. **查询元素**：
   - 要检查一个元素是否可能在集合中，同样使用所有的哈希函数对该元素进行哈希计算。
   - 检查由哈希函数得到的所有位置对应的位是否都是1。
   - 如果所有位都是1，那么元素可能在集合中；如果任何一个位不是1，那么元素肯定不在集合中。

这种实现方式导致布隆过滤器有可能发生误报（即错误地判断某个不在集合中的元素为存在于集合中），但不会发生漏报（即如果它判断元素不在集合中，则该元素确实不在集合中）。


## 5. 为什么会存在误报？

布隆过滤器会产生误报的主要原因是位数组中的位可能被多个不同元素共同影响：

1. **多个哈希函数**：每个元素通过多个哈希函数映射到位数组的多个位置。

2. **位冲突**：不同元素的哈希函数可能映射到相同的位置，导致这些位置的位被设置为1。

3. **误判**：查询一个不在集合中的元素时，如果它的所有哈希函数映射的位置在位数组中恰好都是1（由其他元素设置），布隆过滤器会错误地认为这个元素可能在集合中。

简言之，由于位数组的共享和哈希冲突，布隆过滤器在测试元素是否在集合中时可能会发生误报。

下面通过一个简单的例子来解释布隆过滤器为什么会存在误报：

假设一个布隆过滤器使用一个很小的位数组，大小为10位，并且使用两个哈希函数（记为`hash1`和`hash2`）来处理元素。初始时，所有位都设置为0。

现在，考虑两个元素`X`和`Y`：

1. **添加元素`X`**：
   - `hash1(X)` 映射到位数组的位置2。
   - `hash2(X)` 映射到位数组的位置5。
   - 将位置2和位置5的位设置为1。

   此时，位数组可能是这样的：`[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]`。

2. **检查元素`Y`**：
   - 假设`hash1(Y)`也映射到位置2，而`hash2(Y)`也映射到位置5（这种情况在实际中是可能发生的，尤其是位数组较小的时候）。
   - 当检查元素`Y`是否在布隆过滤器中时，我们看到位置2和位置5都是1。
   - 因此，布隆过滤器会错误地判断`Y`可能在集合中，尽管实际上我们只添加了`X`。

在这个例子中，即使`Y`并不在集合中，由于`X`和`Y`的哈希值恰好映射到了相同的位置，布隆过滤器还是会产生误报。这就是布隆过滤器可能误报的典型情况。

## 8. FilterPolicy

FilterPolicy 涉及到两部分，一部分是  `util/filter_policy.cc` 另一部分是 `include/aryadb/filter_policy.h` 。

FilterPolicy 类是一个用于数据库过滤机制的抽象基类，提供了定义数据库过滤策略所需的基本接口。它的主要功能包括：

1. **命名**：每种过滤策略都有一个独特的名字，用来标识它。

2. **创建过滤器**：基于一组特定的键（数据项）来创建一个过滤器。这个过滤器用来快速判断某个键是否可能存在于这组键中。

3. **键匹配检测**：判断一个特定的键是否可能被之前创建的过滤器匹配。这个功能主要用于快速检查某个数据项是否可能存在，从而避免不必要的数据查找操作。

简而言之，`FilterPolicy` 类是用来创建和管理一种特殊的过滤机制，它可以帮助数据库快速判断某些数据是否存在，从而提高数据处理的效率。

### 8.1 BloomFilterPolicy

这段代码定义了一个名为`BloomFilterPolicy`的C++类，用于实现一个布隆过滤器（Bloom Filter），它是一种用于快速集合成员检测的概率性数据结构。`BloomFilterPolicy`类继承自`FilterPolicy`。以下是该代码的关键点：

1. **构造函数**：`BloomFilterPolicy`接受一个`bits_per_key`参数，用于确定每个键在过滤器中占用的位数。它还计算了`k_`，即每个键使用的哈希函数的数量，基于`bits_per_key`和对数函数的一个固定值。

2. **Name 方法**：重写了基类的`Name`虚函数，返回过滤器的名称。

3. **CreateFilter 方法**：根据给定的键集合（`Slice`类型数组）创建布隆过滤器。该方法首先计算过滤器的大小，然后通过双重哈希生成一系列的哈希值，并设置相应的位。

4. **KeyMayMatch 方法**：检查给定的键是否可能存在于布隆过滤器中。这是通过计算键的哈希值并检查过滤器中相应位是否已设置来完成的。如果任何必要的位未设置，则返回`false`，否则返回`true`。

5. **BloomHash 函数**：一个辅助函数，用于为给定的键生成一个哈希值。

6. **NewBloomFilterPolicy 函数**：一个工厂函数，用于创建`BloomFilterPolicy`对象的新实例。这个函数位于`aryadb`命名空间外部。


`NewBloomFilterPolicy` 函数的参数指定了布隆过滤器中每个键（element）大约占用的比特数（bits per key）。这个值决定了布隆过滤器的空间效率和错误率（false positive rate）。

- **空间效率**：更多的比特数意味着每个键占用更多的空间，从而使过滤器更大。
- **错误率**：更多的比特数通常会降低假阳性率，即错误地判断一个不存在的键存在于过滤器中的概率。

后面调用该函数时设定的参数是 `10` ，这是一个平衡空间和准确性的选择。它被用来初始化布隆过滤器策略，使得每个键在过滤器中占用大约 10 个比特。这个值通常根据具体应用场景和性能需求来选择。


## 9. 如何使用 BloomFilter

接下来研究 Bloom 的测试类 `BloomTest` 的类，它是用来测试布隆过滤器（Bloom filter）的性能和准确性的。该类继承自 `testing::Test`，表明它用于单元测试环境。

下面是单元测试，可以很清晰的看到验证了匹配成功和失败的两种情况：

```c++
TEST_F(BloomTest, EmptyFilter) {
  ASSERT_TRUE(!Matches("hello"));
  ASSERT_TRUE(!Matches("world"));
}

TEST_F(BloomTest, Small) {
  Add("hello");
  Add("world");
  ASSERT_TRUE(Matches("hello"));
  ASSERT_TRUE(Matches("world"));
  ASSERT_TRUE(!Matches("x"));
  ASSERT_TRUE(!Matches("foo"));
}
```

接下来研究 Add 的实现，Add 属于 BloomTest 类似，一个辅助实现测试的 Bloom 的类。

### 9.1 BloomTest

`BloomTest` 类是一个用于测试布隆过滤器性能和准确性的单元测试类。它通过添加键、构建过滤器、检查键匹配和计算假阳性率等方法，全面评估布隆过滤器在不同条件下的行为。成员变量存储测试数据和过滤器状态，而成员函数执行具体的测试逻辑和过滤器操作。这个类的目的是确保布隆过滤器按预期工作，有效地减少数据库查询中的磁盘寻道次数。

`BloomTest` 类包含以下成员变量和成员函数，它们分别承担着不同的角色和功能：

- 成员变量

1. **`const FilterPolicy* policy_;`**
   - 这是一个指向 `FilterPolicy` 接口的指针，具体实现为一个布隆过滤器策略。它定义了如何创建和检测键是否存在于过滤器中。

2. **`std::string filter_;`**
   - 存储布隆过滤器的实际位数组（bit array）。这个字符串表示了过滤器的内容，即哪些位被设置了。

3. **`std::vector<std::string> keys_;`**
   - 存储要添加到布隆过滤器中的键。这些键在构建过滤器之前被收集起来，然后一起用于生成过滤器的内容。

- 成员函数

1. **构造函数 (`BloomTest`) 和 析构函数 (`~BloomTest`)**
   - 构造函数初始化布隆过滤器策略，析构函数负责清理，确保没有内存泄露。

2. **`Reset`**
   - 清空 `keys_` 和 `filter_`，为新一轮测试准备。

3. **`Add`**
   - 将新的键添加到 `keys_` 集合中，准备后续构建过滤器。

4. **`Build`**
   - 根据 `keys_` 中收集的键构建布隆过滤器。构建过程中，`keys_` 中的每个键都被转换成 `Slice` 对象并加入到过滤器中。

5. **`FilterSize`**
   - 返回过滤器的大小（以字节为单位）。

6. **`DumpFilter`**
   - 打印过滤器的内容，主要用于调试和验证过滤器的内部状态。

7. **`Matches`**
   - 检查给定的键是否可能存在于过滤器中。

8. **`FalsePositiveRate`**
   - 计算并返回过滤器的假阳性率。这通过检查不应该存在于过滤器中的大量随机键来实现。

9. **测试用例**
   - `TEST_F` 宏定义的几个测试函数，如 `EmptyFilter`、`Small`、`VaryingLengths`，用于测试布隆过滤器在不同情况下的行为和性能。

- 总结

成员变量主要负责存储测试的状态和数据，而成员函数则提供了执行测试、构建过滤器和评估其性能的具体逻辑。通过这些方法，`BloomTest` 类全面测试了布隆过滤器在各种不同条件下的行为，确保其符合预期的性能特征。

### 9.2 CreateFilter

接下来深入研究 Bloom 的成员方法 CreateFilter 。CreateFilter 是布隆过滤器的一个创建过程。首先，它计算过滤器所需的比特数，这基于给定的键数量和每个键应占用的比特数。为防止过高的假阳性率，它确保最小的过滤器大小为 64 比特。然后，它将这个比特数转换为字节大小，并相应地调整目标字符串 `dst` 的大小以容纳过滤器，并在字符串末尾添加一个字节来记录散列函数的数量。

接下来，代码使用双重哈希技术（参见 Kirsch 和 Mitzenmacher 的研究）为每个键生成一系列哈希值。每个哈希值用于在过滤器的位数组中设置相应的位。这是通过计算每个哈希值对应的位位置，并在那里设置位来完成的。通过这种方式，代码有效地构建了一个布隆过滤器，它可以用于后续的快速成员检测操作。

代码中尽管只明确调用了一个哈希函数 (`BloomHash`)，但它实际上通过一种巧妙的方法实现了双重哈希的效果。关键在于如何使用单个哈希函数的输出来生成多个不同的哈希值。这里是如何做到的：

1. **初始哈希值**：
   - `uint32_t h = BloomHash(keys[i]);`
   - 这行代码为每个键 `keys[i]` 生成一个初始哈希值 `h`。

2. **生成第二个哈希值**：
   - `const uint32_t delta = (h >> 17) | (h << 15);`
   - 这行代码通过对 `h` 进行位运算（这里是将 `h` 向右旋转 17 位）来生成一个“第二个哈希值” `delta`。这个 `delta` 值在每次循环中都会被加到 `h` 上，从而改变 `h` 的值。

3. **使用循环来模拟多个哈希函数**：
   - 在接下来的循环中，`h` 的值在每次迭代中都通过加上 `delta` 来更新。
   - 这样，每次循环中的 `h` 实际上可以被视为是由两个哈希函数生成的不同哈希值：一个是 `BloomHash`，另一个是通过 `delta` 变化得到的。

因此，虽然代码中只调用了一个哈希函数，但通过在每次迭代中改变 `h` 的值，它实际上模拟了多个哈希函数的效果。这种方法在[Kirsch,Mitzenmacher 2006]的论文中有详细讨论，是一种有效的实现布隆过滤器双重哈希的技术。

### 9.3 KeyMayMatch

`KeyMayMatch` 是布隆过滤器中检查一个键是否可能存在于过滤器中的方法。其步骤如下：

1. **基本检查**：首先检查传入的布隆过滤器（`bloom_filter`）的长度。如果长度小于 2，函数直接返回 `false`，表示键不匹配。

2. **处理过滤器数据**：从布隆过滤器中获取原始字节数据和有效比特数。过滤器的最后一个字节用于存储过滤器中使用的散列函数数量（`k`）。

3. **散列函数数量检查**：如果 `k` 的值异常（大于 30），则假定它是一个匹配，返回 `true`。这种情况可能用于特殊编码的短布隆过滤器。

4. **检查键是否匹配**：使用 `BloomHash` 函数对键进行哈希，然后在布隆过滤器中检查相应的位置是否都被设置（即是否为 1）。如果任何一个检查的位没有被设置，意味着键不在过滤器中，函数返回 `false`。

5. **检查循环**：使用双重哈希技术（通过改变哈希值 `h`）来检查 `k` 次，对应于布隆过滤器的 `k` 个散列函数。

如果所有检查的位都被设置，那么函数返回 `true`，表示该键可能存在于过滤器中。需要注意的是，由于布隆过滤器的特性，即使返回 `true` 也不能保证 100% 的准确性（可能存在假阳性）。


## 10. 使用 `std::clamp` 优化边界值处理：

`std::clamp` 是 C++17 引入的一个函数，它用于限制一个值在指定的范围内。如果给定的值已经在这个范围内，它就返回该值；如果值低于范围的最小值，它返回范围的最小值；如果值高于范围的最大值，它返回范围的最大值。基本上，它确保了返回值总是在给定的范围内。

这个函数的原型如下：
```cpp
template< class T >
constexpr const T& clamp( const T& v, const T& lo, const T& hi );
```

其中 `v` 是要限制的值，`lo` 是范围的最小值，`hi` 是范围的最大值。`lo` 和 `hi` 的值必须满足 `lo <= hi`，否则行为是未定义的。

### 示例

假设有如下的代码：

```cpp
int x = std::clamp(5, 1, 10); // x 将是 5
int y = std::clamp(0, 1, 10); // y 将是 1
int z = std::clamp(15, 1, 10); // z 将是 10
```

在这个例子中：
- `x` 的值 5 已经在指定的范围 1 到 10 内，所以它保持不变。
- `y` 的值 0 低于范围的最小值 1，所以它被调整为 1。
- `z` 的值 15 高于范围的最大值 10，所以它被调整为 10。

`std::clamp` 在需要确保值不超出预定范围时非常有用，比如在处理边界条件或限制用户输入时。


### 修改后的代码

示例如下：

```cpp
#include <algorithm>

class BloomFilterPolicy : public FilterPolicy {
 public:
  static constexpr size_t kMaxHashFunctions = 30;
  static constexpr double kNaturalLog2 = 0.69;  // 0.69 =~ ln(2) 近似值

  explicit BloomFilterPolicy(int bits_per_key)
    : bits_per_key_(std::max(bits_per_key, 1)),  // 确保至少为 1
      k_(std::clamp(static_cast<size_t>(bits_per_key_ * kNaturalLog2), 
                    static_cast<size_t>(1), 
                    kMaxHashFunctions)) {
  }

  // ... 其他成员函数 ...

 private:
  size_t bits_per_key_;
  size_t k_;
};
```

这里，`std::clamp` 用于确保 `k_` 的值位于有效范围内。同时，通过在初始化列表中直接使用 `std::max` 和 `std::clamp`，构造函数的主体部分变得更加简洁和清晰。这些改进使得代码更加健壮，易于阅读和维护。


