# Bloom 过滤器

Bloom 过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它的特点是可能会误报（即错误地表示某个元素在集合中），但不会漏报（如果表示某个元素不在集合中，则该元素确实不在集合中）。由于其独特的特性和高效的空间利用率，Bloom过滤器在各种应用中非常有用，特别是在需要快速检查元素是否存在于一个非常大的集合中时。

## 1. Bloom 过滤器的作用

下面用一个简单的例子来说明 Bloom 过滤器的作用：

**场景**：假设你正在运行一个大型在线图书馆，每当用户搜索一本书时，你需要快速判断这本书是否在库存中。

**问题**：图书馆拥有数百万本书，如果每次搜索都查找整个数据库，这将非常耗时。

**解决方案**：使用 Bloom 过滤器。

**如何工作**：
1. **初始化**：当图书馆收到一本新书时，将这本书的标识（如书名或ISBN）添加到 Bloom 过滤器中。
2. **搜索**：用户搜索一本书时，先通过 Bloom 过滤器检查。
   - 如果 Bloom 过滤器表示没有这本书，那么就可以肯定图书馆中没有这本书，无需查询数据库。
   - 如果 Bloom 过滤器表示有这本书，这时可能存在误判（认为有，但实际没有），需要进一步在数据库中确认。

**效果**：Bloom 过滤器能快速过滤掉绝大多数不存在的搜索请求，减轻数据库负担。但它不能100%准确地确认图书馆是否有某本书，可能需要数据库进一步核实。

简而言之，Bloom 过滤器是一种高效的方法来减少不必要的数据库查询，尤其在处理大量数据时非常有效。

## 2. 发展历史

布隆过滤器（Bloom Filter）是由布尔顿·布隆（Burton Howard Bloom）在1970年提出的一种数据结构。下面是它的简明发展历史总结：

1. **1970年**：布隆过滤器由布尔顿·布隆首次提出。最初的设计目的是高效地处理分布式系统中的数据库通信问题，尤其是为了减少不必要的数据传输。

2. **之后几十年**：布隆过滤器由于其空间效率和查询效率得到广泛应用，特别是在网络和分布式系统中。它被用于快速查找和缓存优化，如网络路由器中的IP地址查找、网络爬虫的网页去重等。

3. **21世纪初**：随着互联网技术的发展，布隆过滤器在网络应用中的作用变得更加重要，例如在分布式数据库、缓存系统和网络爬虫中进行快速集合成员检查。

4. **近年来**：布隆过滤器的变种和改进版本相继出现，以适应更复杂的现代计算需求。例如，计数布隆过滤器（Counting Bloom Filter）允许元素被删除，标量布隆过滤器（Scalable Bloom Filter）可以根据需要动态调整大小。

总的来说，布隆过滤器自从1970年被提出以来，因其高效的空间利用率和快速的查询能力，在计算机科学的众多领域得到了广泛应用，并且随着新需求和技术的发展不断演化。

## 3. 性质

从理论的角度来看，布隆过滤器具有以下几个主要性质：

1. **概率型数据结构**：布隆过滤器不存储元素本身，而是通过几个哈希函数将元素映射到一个位数组中。因此，它不能确切地说某个元素是否在集合中，只能说元素“可能在”或“绝对不在”。

2. **空间效率**：与传统的列表或集合相比，布隆过滤器使用极少的空间来存储大量数据的存在信息。这使得它非常适合于存储大型集合的存在检查，尤其是当元素本身很大时。

3. **误报（False Positives）**：布隆过滤器可能会错误地判断某个不在集合中的元素为存在于集合中（即误报）。这种误判的概率可以通过调整位数组的大小和使用的哈希函数的数量来减少。

4. **零误判（Zero False Negatives）**：布隆过滤器从不会错误地判断某个在集合中的元素为不存在。如果它说某个元素不在集合中，那么这个元素确实不在集合中。

5. **不可逆**：一旦元素被添加到布隆过滤器中，就无法从中删除它。这是因为当一个元素被添加时，会影响位数组中的几个位置，而这些位置也可能被其他元素共享。

6. **哈希函数的选择**：布隆过滤器的效率和准确性很大程度上依赖于所选用的哈希函数。理想的哈希函数应该是独立的、均匀分布的，以尽量减少哈希冲突和误报的概率。

7. **可扩展性**：标准布隆过滤器的大小在创建时就固定了，但也有可扩展的变种（如标量布隆过滤器），它们可以根据需要动态调整大小。

总结来说，布隆过滤器是一种以牺牲准确性为代价来极大地节省存储空间和提高查询效率的数据结构，非常适用于那些可以容忍一定误报率的应用场景。

## 4. 实现

布隆过滤器的实现可以简洁地概括为以下几个步骤：

1. **初始化**：创建一个固定大小的位数组，初始时所有位都设为0。

2. **选择哈希函数**：选定几个（通常是2到3个）不同的哈希函数，这些哈希函数应该能将输入均匀地映射到位数组的不同位置。

3. **添加元素**：
   - 对于要添加的每个元素，使用所有的哈希函数分别对其进行哈希计算。
   - 根据每个哈希函数计算出的位置，将位数组对应位置的值设为1。

4. **查询元素**：
   - 要检查一个元素是否可能在集合中，同样使用所有的哈希函数对该元素进行哈希计算。
   - 检查由哈希函数得到的所有位置对应的位是否都是1。
   - 如果所有位都是1，那么元素可能在集合中；如果任何一个位不是1，那么元素肯定不在集合中。

这种实现方式导致布隆过滤器有可能发生误报（即错误地判断某个不在集合中的元素为存在于集合中），但不会发生漏报（即如果它判断元素不在集合中，则该元素确实不在集合中）。


## 5. 为什么会存在误报？

布隆过滤器会产生误报的主要原因是位数组中的位可能被多个不同元素共同影响：

1. **多个哈希函数**：每个元素通过多个哈希函数映射到位数组的多个位置。

2. **位冲突**：不同元素的哈希函数可能映射到相同的位置，导致这些位置的位被设置为1。

3. **误判**：查询一个不在集合中的元素时，如果它的所有哈希函数映射的位置在位数组中恰好都是1（由其他元素设置），布隆过滤器会错误地认为这个元素可能在集合中。

简言之，由于位数组的共享和哈希冲突，布隆过滤器在测试元素是否在集合中时可能会发生误报。

下面通过一个简单的例子来解释布隆过滤器为什么会存在误报：

假设一个布隆过滤器使用一个很小的位数组，大小为10位，并且使用两个哈希函数（记为`hash1`和`hash2`）来处理元素。初始时，所有位都设置为0。

现在，考虑两个元素`X`和`Y`：

1. **添加元素`X`**：
   - `hash1(X)` 映射到位数组的位置2。
   - `hash2(X)` 映射到位数组的位置5。
   - 将位置2和位置5的位设置为1。

   此时，位数组可能是这样的：`[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]`。

2. **检查元素`Y`**：
   - 假设`hash1(Y)`也映射到位置2，而`hash2(Y)`也映射到位置5（这种情况在实际中是可能发生的，尤其是位数组较小的时候）。
   - 当检查元素`Y`是否在布隆过滤器中时，我们看到位置2和位置5都是1。
   - 因此，布隆过滤器会错误地判断`Y`可能在集合中，尽管实际上我们只添加了`X`。

在这个例子中，即使`Y`并不在集合中，由于`X`和`Y`的哈希值恰好映射到了相同的位置，布隆过滤器还是会产生误报。这就是布隆过滤器可能误报的典型情况。


## 6. Hash
 
下面研究 `util/hash.cc` ，这里面是一个 hash 函数。

Leveldb 的 布隆过滤器中的 Hash 函数采用了一个类似 MurmurHash。MurmurHash是一种非加密型哈希函数，适用于一般的哈希检索操作。这个名称“Murmur”来源于两个基本操作，即乘法（multiply）和旋转（rotate），这是这个算法的关键部分。MurmurHash以其高效性和产生较少哈希碰撞的能力而闻名。它不适用于加密，因为它不是为安全性设计的，而是为速度和效率设计的。

MurmurHash 的几个关键特点包括：

1. **性能高效**：MurmurHash被设计成在处理大量数据时保持高效和快速。它的算法结构确保了即使是大量的数据也能快速处理。

2. **分布均匀**：MurmurHash能生成的哈希值分布非常均匀，这减少了哈希碰撞的可能性，即不同的输入产生相同哈希值的情况。

3. **不同版本**：MurmurHash有几个不同的版本，如MurmurHash1、MurmurHash2、MurmurHash3等。每个版本在效率和分布特性方面都有所不同。

4. **平台独立**：MurmurHash算法在不同的硬件和操作系统上都能保持一致的性能和结果。

5. **非加密用途**：重要的是要记住，MurmurHash不适合用于任何需要加密的场合。它的设计重点是速度和效率，而不是防止逆向工程或抵抗哈希碰撞攻击。

MurmurHash常用于数据存储和处理领域，如哈希表的键值映射、数据分片、负载均衡等。由于其高效的性能特点，它在需要快速哈希运算的场景中非常受欢迎。

### MurmurHash 的处理步骤

Leveldb 的 MurmurHash 的处理步骤可以简要概述如下：

1. **初始化**：
   - 使用异或操作将初始种子与数据总大小乘以常数 `m` 结合起来。

2. **处理四字节块**：
   - 当数据长度足够（剩余至少4字节）时，按4字节为一组处理数据。
   - 对每4字节：
     - 读取4字节数据，并将其加到哈希值 `h` 上。
     - 将哈希值 `h` 乘以常数 `m`。
     - 将哈希值 `h` 右移16位后与自身进行异或操作。

3. **处理剩余字节**：
   - 根据剩余字节数（0到3字节），处理每个剩余字节：
     - 如果剩余3字节，则将第三个字节左移16位后加到哈希值 `h` 上。
     - 如果剩余至少2字节，则将第二个字节左移8位后加到哈希值 `h` 上。
     - 如果剩余至少1字节，则将第一个字节直接加到哈希值 `h` 上。
   - 在处理完剩余字节后，将哈希值 `h` 乘以常数 `m`，然后将哈希值 `h` 右移 `r`（24位）位后与自身进行异或操作。

4. **返回最终哈希值**：
   - 返回处理完成后的哈希值 `h`。


## 7. fallthrough

```c++
#ifndef FALLTHROUGH_INTENDED
#define FALLTHROUGH_INTENDED \
  do {                       \
  } while (0)
#endif
```

这段代码定义了一个宏 `FALLTHROUGH_INTENDED`，它用于在 `switch` 语句中明确表示故意的穿透（fallthrough）。接下来分解这段代码，以便更好地理解其作用和用途。

在 `switch` 语句中使用 `FALLTHROUGH_INTENDED` 宏：

```c
switch (value) {
    case 1:
        // 执行一些操作
        FALLTHROUGH_INTENDED;  // 明确表示接下来将执行 case 2 的代码
    case 2:
        // 执行 case 2 的操作
        break;
    ...
}
```

在这个例子中，如果 `value` 是1，代码将执行 `case 1` 的操作，然后由于 `FALLTHROUGH_INTENDED` 宏的存在，继续执行 `case 2` 的操作，而不会因为编译器警告而中断。这样的设计提供了一种清晰且明确的方法来处理 `switch` 语句中的穿透情况。

在 C++ 中，C++17 标准中引入了`[[fallthrough]]` 属性 ，可以用来替换上面的宏定义。

在不使用 `[[fallthrough]]` 的情况下，如果一个 `case` 分支在结束前没有 `break`、`return` 或 `throw` 语句，许多编译器（特别是启用了更严格警告的编译器）会发出警告，因为这通常被视为编程错误。然而，在某些情况下，程序员可能确实希望一个 `case` 分支执行完后继续执行下一个 `case` 分支，这时 `[[fallthrough]]` 就非常有用。

### 7.1 示例

不使用 `[[fallthrough]]` 的情况：

```cpp
switch (value) {
    case 1:
        // 执行一些操作
        // 编译器可能会警告这里缺少 break
    case 2:
        // 执行一些操作
        break;
    default:
        // 默认操作
        break;
}
```

使用 `[[fallthrough]]` 的情况：

```cpp
switch (value) {
    case 1:
        // 执行一些操作
        [[fallthrough]]; // 明确指出接下来的 case 也会被执行
    case 2:
        // 执行一些操作
        break;
    default:
        // 默认操作
        break;
}
```

在第二个例子中，`[[fallthrough]]` 属性清楚地表明从 `case 1` 到 `case 2` 的穿透是有意为之的，从而避免了潜在的编译器警告，同时也让代码的意图更加明显。

### 7.2  什么情况下会用到 fallthrough ？

在 `switch` 语句中，有时程序员会故意设计一个 `case` 分支执行完后继续执行下一个 `case` 分支的逻辑。这种设计模式通常出现在以下几种情况：

#### 1. 共享逻辑
当多个 `case` 分支有部分共享的逻辑时，可以让一个 `case` 分支“落入”下一个分支，以避免代码重复。例如，两种情况下的处理逻辑大体相同，但某些情况下需要执行额外的步骤：

```cpp
switch (value) {
    case 1:
        // 仅对 case 1 特有的逻辑
        // ...
        [[fallthrough]]; // 共享 case 2 的逻辑
    case 2:
        // 对 case 1 和 case 2 都适用的逻辑
        // ...
        break;
    // ...
}
```

#### 2. 逐步处理
在某些算法中，可能需要逐步处理多个步骤，其中后一个步骤依赖于前一个步骤的结果。在这种情况下，可以使用 `case` 的穿透来表示这种逐步处理：

```cpp
switch (step) {
    case 1:
        // 第一步的处理
        // ...
        [[fallthrough]];
    case 2:
        // 第二步的处理，可能依赖于第一步的结果
        // ...
        break;
    // ...
}
```

#### 3. 默认处理加特殊情况
在某些情况下，大多数 `case` 分支可能共享相同的处理逻辑，但某些特定的 `case` 需要执行额外的操作。这时，可以让这些特殊 `case` 先执行特殊逻辑，然后落入通用处理逻辑：

```cpp
switch (value) {
    case 特殊情况:
        // 特殊情况的处理
        // ...
        [[fallthrough]];
    default:
        // 大多数情况下的通用处理逻辑
        // ...
        break;
}
```

使用 `case` 的穿透可以在不牺牲代码可读性的前提下减少重复代码，使代码更加紧凑和高效。但同时，它也可能使代码的流程变得不那么直观，因此在使用时需要小心，确保代码的清晰和易于理解。












## 4. FilterPolicy

FilterPolicy 涉及到两部分，一部分是  `util/filter_policy.cc` 另一部分是 `include/aryadb/filter_policy.h` 。

FilterPolicy 类是一个用于数据库过滤机制的抽象基类，提供了定义数据库过滤策略所需的基本接口。它的主要功能包括：

1. **命名**：每种过滤策略都有一个独特的名字，用来标识它。

2. **创建过滤器**：基于一组特定的键（数据项）来创建一个过滤器。这个过滤器用来快速判断某个键是否可能存在于这组键中。

3. **键匹配检测**：判断一个特定的键是否可能被之前创建的过滤器匹配。这个功能主要用于快速检查某个数据项是否可能存在，从而避免不必要的数据查找操作。

简而言之，`FilterPolicy` 类是用来创建和管理一种特殊的过滤机制，它可以帮助数据库快速判断某些数据是否存在，从而提高数据处理的效率。

### 5. BloomFilterPolicy

这段代码定义了一个名为`BloomFilterPolicy`的C++类，用于实现一个布隆过滤器（Bloom Filter），它是一种用于快速集合成员检测的概率性数据结构。`BloomFilterPolicy`类继承自`FilterPolicy`。以下是该代码的关键点：

1. **构造函数**：`BloomFilterPolicy`接受一个`bits_per_key`参数，用于确定每个键在过滤器中占用的位数。它还计算了`k_`，即每个键使用的哈希函数的数量，基于`bits_per_key`和对数函数的一个固定值。

2. **Name 方法**：重写了基类的`Name`虚函数，返回过滤器的名称。

3. **CreateFilter 方法**：根据给定的键集合（`Slice`类型数组）创建布隆过滤器。该方法首先计算过滤器的大小，然后通过双重哈希生成一系列的哈希值，并设置相应的位。

4. **KeyMayMatch 方法**：检查给定的键是否可能存在于布隆过滤器中。这是通过计算键的哈希值并检查过滤器中相应位是否已设置来完成的。如果任何必要的位未设置，则返回`false`，否则返回`true`。

5. **BloomHash 函数**：一个辅助函数，用于为给定的键生成一个哈希值。

6. **NewBloomFilterPolicy 函数**：一个工厂函数，用于创建`BloomFilterPolicy`对象的新实例。这个函数位于`aryadb`命名空间外部。


### 6. 如何使用 BloomFilter

接下来研究 Bloom 的测试类 `BloomTest` 的类，它是用来测试布隆过滤器（Bloom filter）的性能和准确性的。该类继承自 `testing::Test`，表明它用于单元测试环境。以下是对该类的简明扼要总结：

1. **构造函数与析构函数**：`BloomTest` 在构造时初始化一个布隆过滤器策略（`NewBloomFilterPolicy(10)`），并在析构时释放它。

2. **数据结构**：
   - `policy_`：指向布隆过滤器策略的指针。
   - `filter_`：存储布隆过滤器的字符串表示。
   - `keys_`：存储要加入布隆过滤器的键的字符串向量。

3. **方法**：
   - `Reset()`：清空键集合和过滤器。
   - `Add(const Slice& s)`：向键集合中添加一个新的键。
   - `Build()`：根据当前键集合构建布隆过滤器。
   - `FilterSize()`：返回过滤器的大小。
   - `DumpFilter()`：打印出过滤器的内容（用于调试）。
   - `Matches(const Slice& s)`：检查给定的键是否可能在布隆过滤器中。
   - `FalsePositiveRate()`：计算并返回假阳性率。

4. **应用场景**：
   - 这个类主要用于测试布隆过滤器的实现，特别是其假阳性率和存储效率。
   - 它通过构建过滤器并测试大量不在过滤器中的键来评估假阳性率。

这个类提供了一个框架来评估布隆过滤器的实现，并且可以用于确保过滤器的行为符合预期。


下面是如何使用这个类的代码：

```c++
TEST_F(BloomTest, EmptyFilter) {
  ASSERT_TRUE(!Matches("hello"));
  ASSERT_TRUE(!Matches("world"));
}

TEST_F(BloomTest, Small) {
  Add("hello");
  Add("world");
  ASSERT_TRUE(Matches("hello"));
  ASSERT_TRUE(Matches("world"));
  ASSERT_TRUE(!Matches("x"));
  ASSERT_TRUE(!Matches("foo"));
}
```




### 3. cmake 拆分

要将这个 CMake 配置拆分为多个文件夹，我们需要创建多个 CMakeLists.txt 文件，每个文件夹一个。以下是一种可能的拆分方式：

1. **根目录**: 包含主 CMakeLists.txt。
2. **include/aryadb**: 存放头文件的 CMakeLists.txt。
3. **util**: 存放工具类的 CMakeLists.txt。
4. **test**: 存放测试代码的 CMakeLists.txt。
5. **third_party**: 存放第三方库，如 Google Test。

#### 根目录 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.27)
project(aryadb)

set(CMAKE_CXX_STANDARD 23)

add_subdirectory(util)
add_subdirectory(test)
add_subdirectory(third_party/googletest)

enable_testing()
```

#### include/aryadb/CMakeLists.txt

```cmake
# 这个文件夹只包含头文件，通常不需要特别的 CMakeLists.txt
# 但如果需要对头文件进行特殊处理，可以在这里添加
```

#### util/CMakeLists.txt

```cmake
add_library(util
    status.cc
    arean.cc
    random.h
    bloom.cc
    filter_policy.cc
)

target_include_directories(util PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

#### test/CMakeLists.txt

```cmake
add_executable(public_tests
    arean_test.cc
    slice_test.cc
    status_test.cc
    bloom_test.cc
)

target_link_libraries(
    public_tests
    util
    GTest::gtest_main
)

include(GoogleTest)
gtest_discover_tests(public_tests)
```

#### third_party/googletest/CMakeLists.txt

```cmake
# 确保已将 Google Test 作为子模块添加
add_subdirectory(googletest)
```

**注意**：

1. **util** 文件夹的 CMakeLists.txt 中创建了一个库（`util`），这是因为 util 文件夹包含了多个源文件。
2. **test** 文件夹的 CMakeLists.txt 链接了 `util` 库和 Google Test。
3. 依赖关系和路径可能需要根据项目的具体结构进行调整。
4. 头文件夹 `include/aryadb` 通常不需要专门的 CMakeLists.txt，除非有特殊处理需求。
5. Google Test 应作为子模块添加到项目中，并在对应的 CMakeLists.txt 中引用。




### 3. 为什么单独列出 Slice ？

在 C++ 中，`class Slice;` 是一个前向声明（Forward Declaration）。前向声明是一种编程技术，用于告知编译器某个类的存在，而不提供该类的完整定义。在这种情况下，它声明了一个名为 `Slice` 的类。

#### 用途和好处

1. **减少依赖**：通过前向声明，你可以在一个文件中引用另一个类，而不需要包含（include）整个定义。这样可以减少编译时的依赖和编译时间。

2. **解决循环依赖**：如果两个或多个类互相引用，前向声明可以帮助解决循环依赖问题。

3. **提高编译效率**：由于减少了对完整头文件的依赖，前向声明可以提高编译效率，特别是在大型项目中。

#### 使用场景

- 在声明指向另一个类的指针或引用时，你可以使用前向声明，因为编译器不需要完整的类定义来处理指针或引用。

- 在函数声明中，如果仅仅需要引用某个类类型，而不需要访问其成员，可以使用前向声明。

#### 注意事项

- 不能使用前向声明来定义该类的对象，因为对象的大小在前向声明时未知。

- 不能在前向声明的类上使用其成员，因为这些成员在声明时还未定义。

- 前向声明后，必须在使用该类之前提供完整的类定义。

在 `class Slice;` 的这种用法中，它可能被用于类 `FilterPolicy` 中的方法声明，比如作为函数参数的类型，但在 `FilterPolicy` 的定义中不会涉及到 `Slice` 类的内部细节。完整的 `Slice` 类定义需要在实际使用这些方法之前在其他地方提供。


## 3. coding 


