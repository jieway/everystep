# Hash

这一章主要研究 `util/hash.cc` 和 `util/hash.h` 。

hash 又用到了 `util/coding.cc` 和 `util/coding.h`

## 1. Coding

`util/coding.cc` 和 `util/coding.h` 提供了一套用于数据编码和解码的功能，特别是针对固定长度和可变长度整数以及字符串数据。它主要实现了：

1. **固定长度整数的编码与解码**：使用小端字节序编码 `uint32_t` 和 `uint64_t` 类型的整数，并提供相应的解码功能。

2. **可变长度整数（varint）的编码与解码**：对 `uint32_t` 和 `uint64_t` 类型的整数进行可变长度编码，称为 varint 编码，同时提供解码这些编码的功能。

3. **字符串的长度前缀编码**：将字符串前缀为其长度（使用 varint 编码），然后是字符串本身，提供解析这种格式的字符串的功能。

总的来说，这段代码是一个用于处理不同类型数据（特别是整数和字符串）的端序中立编码和解码库，适用于需要高效存储和传输数据的场景。

这部分代码比较底层，没有太多可以修改的地方，先略过。

## 2. Hash

下面研究 `util/hash.cc` ，这里面是一个 hash 函数。

Leveldb 的 布隆过滤器中的 Hash 函数采用了一个类似 MurmurHash。MurmurHash是一种非加密型哈希函数，适用于一般的哈希检索操作。这个名称“Murmur”来源于两个基本操作，即乘法（multiply）和旋转（rotate），这是这个算法的关键部分。MurmurHash以其高效性和产生较少哈希碰撞的能力而闻名。它不适用于加密，因为它不是为安全性设计的，而是为速度和效率设计的。

MurmurHash 的几个关键特点包括：

1. **性能高效**：MurmurHash被设计成在处理大量数据时保持高效和快速。它的算法结构确保了即使是大量的数据也能快速处理。

2. **分布均匀**：MurmurHash能生成的哈希值分布非常均匀，这减少了哈希碰撞的可能性，即不同的输入产生相同哈希值的情况。

3. **不同版本**：MurmurHash有几个不同的版本，如MurmurHash1、MurmurHash2、MurmurHash3等。每个版本在效率和分布特性方面都有所不同。

4. **平台独立**：MurmurHash算法在不同的硬件和操作系统上都能保持一致的性能和结果。

5. **非加密用途**：重要的是要记住，MurmurHash不适合用于任何需要加密的场合。它的设计重点是速度和效率，而不是防止逆向工程或抵抗哈希碰撞攻击。

MurmurHash常用于数据存储和处理领域，如哈希表的键值映射、数据分片、负载均衡等。由于其高效的性能特点，它在需要快速哈希运算的场景中非常受欢迎。

### MurmurHash 的处理步骤

Leveldb 的 MurmurHash 的处理步骤可以简要概述如下：

1. **初始化**：
   - 使用异或操作将初始种子与数据总大小乘以常数 `m` 结合起来。

2. **处理四字节块**：
   - 当数据长度足够（剩余至少4字节）时，按4字节为一组处理数据。
   - 对每4字节：
     - 读取4字节数据，并将其加到哈希值 `h` 上。
     - 将哈希值 `h` 乘以常数 `m`。
     - 将哈希值 `h` 右移16位后与自身进行异或操作。

3. **处理剩余字节**：
   - 根据剩余字节数（0到3字节），处理每个剩余字节：
     - 如果剩余3字节，则将第三个字节左移16位后加到哈希值 `h` 上。
     - 如果剩余至少2字节，则将第二个字节左移8位后加到哈希值 `h` 上。
     - 如果剩余至少1字节，则将第一个字节直接加到哈希值 `h` 上。
   - 在处理完剩余字节后，将哈希值 `h` 乘以常数 `m`，然后将哈希值 `h` 右移 `r`（24位）位后与自身进行异或操作。

4. **返回最终哈希值**：
   - 返回处理完成后的哈希值 `h`。

## 3. fallthrough

`util/hash.cc` 中使用了 fallthrough ，下面是原始代码：

```c++
#ifndef FALLTHROUGH_INTENDED
#define FALLTHROUGH_INTENDED \
  do {                       \
  } while (0)
#endif
```

这段代码定义了一个宏 `FALLTHROUGH_INTENDED`，它用于在 `switch` 语句中明确表示故意的穿透（fallthrough）。接下来分解这段代码，以便更好地理解其作用和用途。

在 `switch` 语句中使用 `FALLTHROUGH_INTENDED` 宏：

```c
switch (value) {
    case 1:
        // 执行一些操作
        FALLTHROUGH_INTENDED;  // 明确表示接下来将执行 case 2 的代码
    case 2:
        // 执行 case 2 的操作
        break;
    ...
}
```

在这个例子中，如果 `value` 是1，代码将执行 `case 1` 的操作，然后由于 `FALLTHROUGH_INTENDED` 宏的存在，继续执行 `case 2` 的操作，而不会因为编译器警告而中断。这样的设计提供了一种清晰且明确的方法来处理 `switch` 语句中的穿透情况。

在 C++ 中，C++17 标准中引入了`[[fallthrough]]` 属性 ，可以用来替换上面的宏定义。

在不使用 `[[fallthrough]]` 的情况下，如果一个 `case` 分支在结束前没有 `break`、`return` 或 `throw` 语句，许多编译器（特别是启用了更严格警告的编译器）会发出警告，因为这通常被视为编程错误。然而，在某些情况下，程序员可能确实希望一个 `case` 分支执行完后继续执行下一个 `case` 分支，这时 `[[fallthrough]]` 就非常有用。

### 3.1 示例

不使用 `[[fallthrough]]` 的情况：

```cpp
switch (value) {
    case 1:
        // 执行一些操作
        // 编译器可能会警告这里缺少 break
    case 2:
        // 执行一些操作
        break;
    default:
        // 默认操作
        break;
}
```

使用 `[[fallthrough]]` 的情况：

```cpp
switch (value) {
    case 1:
        // 执行一些操作
        [[fallthrough]]; // 明确指出接下来的 case 也会被执行
    case 2:
        // 执行一些操作
        break;
    default:
        // 默认操作
        break;
}
```

在第二个例子中，`[[fallthrough]]` 属性清楚地表明从 `case 1` 到 `case 2` 的穿透是有意为之的，从而避免了潜在的编译器警告，同时也让代码的意图更加明显。

### 3.2  什么情况下会用到 fallthrough ？

在 `switch` 语句中，有时程序员会故意设计一个 `case` 分支执行完后继续执行下一个 `case` 分支的逻辑。这种设计模式通常出现在以下几种情况：

#### 1. 共享逻辑
当多个 `case` 分支有部分共享的逻辑时，可以让一个 `case` 分支“落入”下一个分支，以避免代码重复。例如，两种情况下的处理逻辑大体相同，但某些情况下需要执行额外的步骤：

```cpp
switch (value) {
    case 1:
        // 仅对 case 1 特有的逻辑
        // ...
        [[fallthrough]]; // 共享 case 2 的逻辑
    case 2:
        // 对 case 1 和 case 2 都适用的逻辑
        // ...
        break;
    // ...
}
```

#### 2. 逐步处理
在某些算法中，可能需要逐步处理多个步骤，其中后一个步骤依赖于前一个步骤的结果。在这种情况下，可以使用 `case` 的穿透来表示这种逐步处理：

```cpp
switch (step) {
    case 1:
        // 第一步的处理
        // ...
        [[fallthrough]];
    case 2:
        // 第二步的处理，可能依赖于第一步的结果
        // ...
        break;
    // ...
}
```

#### 3. 默认处理加特殊情况
在某些情况下，大多数 `case` 分支可能共享相同的处理逻辑，但某些特定的 `case` 需要执行额外的操作。这时，可以让这些特殊 `case` 先执行特殊逻辑，然后落入通用处理逻辑：

```cpp
switch (value) {
    case 特殊情况:
        // 特殊情况的处理
        // ...
        [[fallthrough]];
    default:
        // 大多数情况下的通用处理逻辑
        // ...
        break;
}
```

使用 `case` 的穿透可以在不牺牲代码可读性的前提下减少重复代码，使代码更加紧凑和高效。但同时，它也可能使代码的流程变得不那么直观，因此在使用时需要小心，确保代码的清晰和易于理解。



