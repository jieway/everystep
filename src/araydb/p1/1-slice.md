# 2. Slice 

简单来说 LevelDB 自己设计了一套处理字符串的方式取名为 slice ，而非用 C++ 标准库中的 `std::string` 。`Slice`类的目的是为了高效地处理和表示字符串或字节数组的子部分。这在需要频繁操作大量数据时特别有用，例如在数据库系统或性能敏感的应用中。

使用 `Slice` 的用户必须确保在相应的外部存储被释放后不再使用该 `Slice`。多线程可以在不进行外部同步的情况下调用 `Slice` 的 const 方法，但如果任何线程可能调用非 const 方法，所有访问同一 `Slice` 的线程都必须使用外部同步。

## 1. 为什么要单独设计一套处理字符串的方式而非 `std::string` ？

LevelDB 使用 `Slice` 而不是 `std::string` 的主要原因是为了提高性能和灵活性：

1. **避免复制**：`Slice` 只是引用数据，不拥有数据，这样可以避免不必要的数据复制，从而提高效率。
2. **处理非文本数据**：LevelDB 需要处理的不仅仅是文本，还包括二进制数据。`Slice` 更适合处理这种类型的数据。
3. **简单高效**：`Slice` 提供了一个简单且直接访问数据的方式，这对于 LevelDB 这样的底层系统来说非常重要。

## 2. noexcept

- **使用 `noexcept` 关键字**：
对于不抛出异常的函数，可以添加 `noexcept`。例如：

```cpp
bool empty() const noexcept { return size_ == 0; }
```

在 C++ 中，`noexcept` 是一个关键字，用于指定函数不会抛出异常。这对编译器优化和代码的明确性有重要作用。使用 `noexcept` 的主要目的和优势包括：

### 作用

1. **阻止异常传播**：如果标记为 `noexcept` 的函数确实抛出了异常，程序将不会尝试正常的异常传播机制。相反，会直接调用 `std::terminate()` 函数，通常会导致程序终止。

2. **优化指示**：当编译器知道一个函数不会抛出异常时，它可以对这个函数进行更激进的优化。例如，它可以省略一些用于异常处理的代码，从而提高程序的性能。

3. **接口明确性**：`noexcept` 明确指出了函数的设计者意图不在该函数中抛出异常，为函数的使用者提供了更清晰的指导。

### 使用场景

- **析构函数**：在现代 C++ 中，析构函数默认是 `noexcept` 的。这是因为抛出异常的析构函数可能导致复杂的异常处理问题和潜在的资源泄漏。

- **移动构造函数和移动赋值运算符**：当这些函数被标记为 `noexcept` 时，标准库容器（如 `std::vector`）在重新分配内存时会使用移动而非拷贝，从而提高性能。

- **其他不抛出异常的函数**：任何确定不会抛出异常的函数都应该使用 `noexcept` 标记，以提供更好的性能和清晰的接口。


### 注意事项

- 在使用 `noexcept` 时，应确保函数确实不会抛出任何异常。如果一个标记为 `noexcept` 的函数抛出了异常，那么程序会调用 `std::terminate()`，这通常会导致程序立即终止。

- 在某些情况下，过度使用 `noexcept` 可能会导致不必要的复杂性或限制函数的灵活性。因此，在决定是否使用 `noexcept` 时，应仔细考虑函数的用途和上下文。


### noexcept 发展历史

`noexcept` 关键字的引入和发展是对 C++ 异常处理机制的重要补充和优化。它在 C++11 标准中首次被引入。以下是其发展历史的概述：

1. 异常规范（Exception Specification）：C++98 和 C++03

在 C++11 之前，C++ 异常处理机制包含了异常规范，允许开发者为函数指定可能抛出的异常类型。例如：

```cpp
void function() throw(int); // 仅当函数抛出 int 类型异常时合法
```

这种机制旨在提供更安全的异常处理，但实际上却引入了一些问题：

- **性能开销**：编译器需要生成额外的代码来处理可能抛出的异常类型，这可能导致性能降低。
- **可用性限制**：异常规范很难正确和有效地使用。
- **兼容性问题**：与其他不使用异常规范的代码库交互时可能引起问题。

2. C++11：引入 `noexcept`

鉴于异常规范的问题，C++11 引入了 `noexcept` 关键字。它是对异常规范的一种简化，仅表示函数是否会抛出异常，而不是指定可能抛出的具体异常类型。这大大简化了异常规范的复杂性，同时提供了性能优化的机会：

- **性能优化**：知道函数不会抛出异常后，编译器可以进行更积极的优化。
- **简化的语法**：`noexcept` 比旧的异常规范更易于使用和理解。
- **改进的语义**：明确指出函数是否会抛出异常，使得代码的意图更加清晰。

3. C++17 及以后

在 C++17 中，对 `noexcept` 的使用进一步扩展。大多数标准库中的函数和类型，特别是那些涉及移动语义的函数，现在都标记为 `noexcept`。这确保了标准库在异常安全性和性能上的一致性。

同时，C++17 引入了 `std::string_view` 和 `std::array_view`（在后续标准中更名为 `std::span`），这些类型的很多操作都是 `noexcept` 的，进一步推广了这一概念。

4. 总结

`noexcept` 关键字的引入和发展反映了 C++ 社区对异常安全性和性能优化的重视。它简化了异常处理机制，使得 C++ 程序更加高效和健壮。随着新标准的发布，`noexcept` 的使用逐渐成为现代 C++ 编程中的一种最佳实践。


## 3. 使用默认成员初始化

在类定义中直接初始化成员变量，例如：

```cpp
//  private:
//   const char* data_;
//   size_t size_;

private:
 const char* data_ = nullptr;
 size_t size_ = 0;
```

两种初始化方式都用于在 C++ 类中初始化成员变量，但它们的方式不同。以下是每种方法的解释及其优缺点：

1. 在类定义中直接初始化成员变量

```cpp
private:
  const char* data_ = nullptr;
  size_t size_ = 0;
```

在这种方式中，成员变量在类定义内直接赋予了初始值。这种方法在 C++11 中引入，提供了一种更清晰、更一致的初始化方式。

**优点**：
- **一致性**：所有构造函数共享相同的默认值，减少了重复代码。
- **清晰性**：直接在成员声明处看到默认值，增加代码的可读性。
- **异常安全**：有助于提高代码的异常安全性，因为成员在任何构造函数体执行之前就已经被初始化。

**缺点**：
- 对于某些类型，这种方式可能导致轻微的性能开销（如果构造函数中又对其赋予了新的值）。

2. 在构造函数中初始化成员变量

```cpp
private:
  const char* data_;
  size_t size_;
```

在这种方式中，成员变量在构造函数体或初始化列表中赋值。这是 C++98/03 中常见的做法。

**优点**：
- **灵活性**：允许在不同的构造函数中为成员变量赋予不同的初始值。
- **性能**：对于那些稍后在构造函数中被重新赋值的成员变量，这种方式可能更高效。

**缺点**：
- **重复代码**：如果多个构造函数都需要初始化相同的成员变量，可能导致代码重复。
- **易错**：可能忘记在某个构造函数中初始化成员变量，导致难以发现的错误。

- 哪种更好？最佳实践是什么？

通常，**在类定义中直接初始化成员变量**被认为是一种更现代、更安全的做法，特别是对于基本数据类型和指针。它提供了代码一致性、减少了重复，并提高了代码的可读性和可维护性。对于简单类型的成员变量（如指针和基本数据类型），这种方式几乎没有性能上的不利影响。

然而，对于一些复杂的对象，如果你在类定义中为其提供了一个默认值，但在构造函数中又会赋予它一个不同的值，这可能会导致不必要的构造和析构操作，从而影响性能。在这种情况下，最好是在构造函数的初始化列表中直接初始化。

- 结论

对于简单的类型（如指针、基本数据类型），在类定义中直接初始化通常是最佳实践。对于更复杂的类型，根据具体情况选择在类定义中初始化还是在构造函数中初始化。总的来说，现代 C++ 推荐尽可能使用类定义中的直接初始化方式。


## 4. 使用 `constexpr`

将简单的成员函数标记为 `constexpr` 例如：

```cpp
// const char* data() const { return data_; }
constexpr const char* data() const noexcept { return data_; }

// size_t size() const { return size_; }
constexpr size_t size() const noexcept { return size_; }
```


`constexpr` 是一个在 C++11 标准中引入的关键字，用于指定变量、函数、对象构造函数等在编译时就能确定其值或行为。它是 C++ 对编译时计算和优化的支持的重要扩展。

`constexpr` 从 C++11 的简单起步到 C++20 的全面支持，`constexpr` 已经成为现代 C++ 编程中不可或缺的一部分。它不仅使编译时优化和计算成为可能，还提高了代码的表达力和效率。通过不断的发展，`constexpr` 已经从一个有限的编译时常量扩展到了支持复杂逻辑和标准库算法的强大工具。


下面是两个例子来对比什么时候能用，什么时候不能用 constexpr ：

1. 可以使用 `constexpr` 的例子：幂函数

假设我们有一个计算整数幂的函数。这个函数可以在编译时计算，因为它不涉及任何运行时操作：

```cpp
constexpr int power(int base, int exp) {
    int result = 1;
    for (int i = 0; i < exp; ++i) {
        result *= base;
    }
    return result;
}

// 在编译时计算 2 的 3 次幂
constexpr int eight = power(2, 3);
```

在这个例子中，`power` 函数计算 `base` 的 `exp` 次幂。由于所有的操作（乘法和循环）都可以在编译时执行，所以这个函数可以被声明为 `constexpr`，并且 `eight` 变量在编译时就被计算出来了。

2. 不能使用 `constexpr` 的例子：时间获取函数

现在考虑一个获取当前时间的函数。这样的函数不能是 `constexpr`，因为它依赖于运行时才能确定的值：

```cpp
#include <ctime>

int getCurrentTime() {
    return std::time(nullptr);
}

// 这将导致编译错误，因为 getCurrentTime 依赖于运行时数据
constexpr int currentTime = getCurrentTime();
```

在这个例子中，`getCurrentTime` 函数调用 `std::time` 来获取当前时间。由于当前时间是在程序运行时才能确定的，这个函数不能被声明为 `constexpr`。试图将 `currentTime` 声明为 `constexpr` 会导致编译错误。

### 区别

- **`constexpr` 适用性**：如果函数执行的所有操作都可以在编译时完成（如计算固定的数学表达式），那么它可以被声明为 `constexpr`。

- **`constexpr` 不适用性**：如果函数的行为依赖于运行时的数据或环境（如当前时间、用户输入、文件数据等），它就不能被声明为 `constexpr`。

### 结论

理解 `constexpr` 的关键在于识别哪些操作是完全由编译时可知的信息决定的。当操作完全独立于程序的运行时环境时，`constexpr` 是可行的。这种方法可以提高性能，因为它允许编译器在编译时而不是运行时执行计算。



## 5. #pragma once

在 LevelDB 中，使用的是传统的宏防护（也称为包含防护或头文件防护）来防止头文件的重复包含。这是一种常见的C++实践，用于防止头文件在一个单一编译单元中被多次包含，导致定义冲突或编译错误。

从 C++11 开始，引入了一个新的特性叫做 `#pragma once`，它是一个预处理器指令，用于确保头文件只被编译一次，无论它被包含了多少次。使用 `#pragma once` 可以减少书写，避免传统宏防护可能出现的命名冲突，同时在大多数现代编译器中都得到了支持。

### 传统的宏防护
```cpp
#ifndef STORAGE_LEVELDB_INCLUDE_SLICE_H_
#define STORAGE_LEVELDB_INCLUDE_SLICE_H_

// ... 头文件内容 ...

#endif // STORAGE_LEVELDB_INCLUDE_SLICE_H_
```

### 使用 `#pragma once`
```cpp
#pragma once

// ... 头文件内容 ...
```

### 优化建议
如果您确定您的代码只会在支持 `#pragma once` 的编译器上编译，那么可以用 `#pragma once` 替代传统的宏防护。这使得代码更简洁，减少了潜在的宏命名冲突，并可能略微提高编译速度。

但请注意，尽管 `#pragma once` 在大多数现代编译器上都得到了支持，它仍然不是C++标准的一部分。因此，如果您的代码需要在各种编译器上具有最大的兼容性，或者需要遵守特定的编码标准，那么保留传统的宏防护可能是更好的选择。


## 6. string_view

* **使用 `std::string_view` 代替 `const std::string&`**

`std::string_view` 是一个标准库容器，可以用来表示一个字符串的视图。它可以用来替代 `const std::string&`，从而使代码更简潔、更安全。

例如，以下代码使用 `std::string_view` 重写了 `Slice` 类的构造函数：

```c++
  // Slice(const std::string& s) : data_(s.data()), size_(s.size()) {}
  Slice(std::string_view s) : data_(s.data()), size_(s.size()) {}
```

string_view 不能直接替换 Slice 结构，二者存在一些差异，例如：

- clear() 方法可以将 Slice 的大小设置为 0，而 std::string_view 的大小是不可变的。
- remove_prefix() 方法可以将 Slice 的前 n 个字节移除，而 std::string_view 只能进行读取操作。


`std::string_view` 在 C++17 中引入，主要提供以下优点，同时解决了一些 `std::string` 的常见问题：

- 优点

1. **性能提升**：避免了不必要的字符串复制，特别是在仅引用字符串一部分的场景中。
2. **更高的灵活性**：能够引用任何类型的字符序列，包括 `std::string` 和字符数组。
3. **减少内存分配**：不拥有所引用的字符串，不涉及额外的内存分配和管理。

- 解决的 `std::string` 问题

1. **减少复制开销**：处理大字符串时，避免了复制整个字符串，特别是在字符串传递给函数作为参数时。
2. **改善与 C 风格字符串的兼容**：直接引用 C 风格字符串，无需转换为 `std::string`。

- 使用注意

- `std::string_view` 不管理其引用的字符串，使用时需确保引用的字符串在 `std::string_view` 生命周期内有效。
- 不保证字符串以空字符结尾，可能需要额外处理以适应某些 API。


### `std::string_view` 的优点：

1. **性能提升**：`std::string_view` 可以避免不必要的字符串复制。例如，当你从一个大的字符串中提取小的子串时，使用 `std::string_view` 可以避免复制整个字符串，而是简单地引用原始字符串的一部分。

2. **灵活性**：`std::string_view` 可以指向任何字符数组，包括 `std::string`、字符字面量或者其他来源的字符数组。这提高了代码的灵活性和通用性。

3. **API兼容性**：由于 `std::string_view` 提供了与 `std::string` 类似的接口，因此在很多情况下可以直接替换 `std::string` 参数，而无需大量重写代码。

4. **内存管理**：`std::string_view` 本身不负责管理内存。它只是引用存在于其他地方的字符串，这意味着使用它时不需要担心内存分配和释放。

### 解决了 `std::string` 的哪些问题：

1. **避免不必要的内存分配**：当使用 `std::string` 时，即使只是想引用或检查字符串的一部分，也经常会涉及到字符串的复制和内存分配。`std::string_view` 则允许你在无需复制的情况下进行操作。

2. **提高字符串处理效率**：在函数参数中使用 `std::string` 时，传递字符串常常涉及复制，尤其是在字符串很大时。`std::string_view` 作为参数可以减少这种复制，特别是在只读访问时。

3. **更好地与现有的 C 风格字符串协同工作**：`std::string_view` 可以直接指向 C 风格的字符串，无需将其转换为 `std::string`，从而提高效率。

### 注意事项：

虽然 `std::string_view` 有许多优点，但在使用时也要注意：

- `std::string_view` 不拥有它所引用的字符串，因此需要确保在 `std::string_view` 生命周期内，被引用的字符串是有效的。
- 它不保证字符串以空字符结尾，因此在某些情况下可能需要额外的处理来兼容预期以空字符终止的 API。

总体来说，`std::string_view` 提供了一种更高效、更灵活的方式来引用和操作字符串，但同时需要谨慎处理其对原始数据的非拥有性引用。


代码可以参考这个分支：https://github.com/weijiew/aryadb/tree/1_slice