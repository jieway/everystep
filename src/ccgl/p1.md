

> 这个系列是阅读《C++ Core Guide Line》这本书时所做的笔记，代码参考自原书籍，文字内容为个人解读，提炼总结出来的笔记，不是翻译。
> 
> 原书是开源的，并且有人已经翻译过一遍了，建议阅读原书。有条件的话可以买一本中文版看看，中文书名为《C++ 核心指导方针》。
> 
> 英文：https://github.com/isocpp/CppCoreGuidelines
> 
> 中文：https://github.com/lynnboy/CppCoreGuidelines-zh-CN

注释是写给人看的，编译器不会参考注释，所以要尽可能的在代码中更清晰的表达意图，更强大的约束。这样使得编译器和其他工具也能对代码进行正确的处理和检查。下面结合了一些具体的使用场景来讲解这一点。

### 时间

这段代码中定义了一个`Date`类，其中包含两个名为`month`的成员函数。虽然两个函数都能实现相同的功能，但是第一个是推荐做法，第二个不推荐。

```cpp
    class Date {
    public:
        Month month() const;  // 好
        int month();          // 坏
        // ...
    };
```

第一个`month`函数是一个常量成员函数，返回类型为`Month`。这个函数的声明表明它不会修改`Date`对象的状态。这是因为它后面带有`const`关键字，这意味着这个函数不能修改类的任何成员变量（除非它们被声明为`mutable`）。这是一个好的设计，因为它明确了函数的行为：这个函数只是获取月份，不会改变日期对象的状态。

第二个`month`函数返回一个`int`，并且它不是一个常量成员函数。这意味着它可能会修改`Date`对象的状态。这是一个不好的设计，因为它的行为不清晰。从函数名`month`来看，我们可能会认为这个函数应该只是获取月份，而不应该改变`Date`对象的状态。但是，由于它不是一个常量成员函数，我们不能确定它是否会改变对象的状态。这可能会导致错误的使用，例如，如果一个函数只想获取月份，但不希望改变日期对象，而它错误地调用了这个版本的`month`函数，那么就可能会导致意外的结果。

总的来说，当你设计类的成员函数时，应该尽可能地使函数的行为明确。如果一个函数不会修改对象的状态，那么就应该将其声明为常量成员函数。这样，使用者就能清楚地知道这个函数的行为，从而减少错误的可能性。

### 循环遍历

下面是两段功能一模一样的代码，都是循环便利一个数组的代码。但是第一段是不推荐的做法，第二段是建议做法。

```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // 坏
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
```

这个例子中，使用了一个手动的循环来查找`vector`中的一个元素。这种方法的问题在于，它需要手动管理循环变量和索引，而且如果忘记在找到元素后使用`break`语句，可能会导致错误的结果。此外，这种方法的可读性较差，因为需要阅读和理解整个循环结构才能明白它的目的。

```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // 好
    // ...
}
```

这个例子中，使用了标准库函数`std::find`来查找`vector`中的一个元素。这种方法的优点在于，它更简洁，更易于理解，因为`std::find`的功能就是查找一个元素。此外，使用标准库函数可以减少错误的可能性，因为不需要手动管理循环变量和索引。最后，如果在未来需要更改容器类型（例如，从`vector`更改为`list`或`set`），使用标准库函数可以使这种更改更容易，因为`std::find`可以用于任何容器，而手动的循环可能需要根据容器的特性进行修改。

### 参数设计

```cpp
    change_speed(double s);   // 不好：s表示什么？
    // ...
    change_speed(2.3);
```

在这个例子中，函数`change_speed(double s)`的问题在于，参数`s`的含义并不清晰。`s`代表什么？是新的速度值？还是速度的增量？另外，`s`的单位是什么？是米/秒，还是千米/小时？这些都是不清晰的。

更好的做法是使用一个明确的类型，如`Speed`，来表示速度。这样，`change_speed(Speed s)`函数的参数`s`的含义就很清晰了：它是一个速度值。此外，`Speed`类型可以包含单位信息，这样就可以避免单位不清的问题。

```cpp
    change_speed(Speed s);    // 更好：s的含义已经指定
    // ...
    change_speed(2.3);        // 错误：没有单位
    change_speed(23_m / 10s);  // 米每秒
```

然后，当你调用`change_speed(2.3)`时，编译器会报错，因为`2.3`是一个`double`类型，而`change_speed`函数需要一个`Speed`类型的参数。这是一个好事，因为它防止了单位不清的问题。你应该使用`change_speed(23_m / 10s)`来调用这个函数，其中`23_m`表示23米，`10s`表示10秒，所以整个表达式表示的是2.3米/秒。

如果你既想要表示绝对速度，又想要表示速度的增量，你可以定义一个`Delta`类型。这样，你可以使用`change_speed(Delta d)`来改变速度，其中`d`是速度的增量。这样，你的代码就会更清晰，更容易理解，也更不容易出错。

### 总结

注释虽然能帮助人们理解代码，但编译器并不会参考它，因此我们应该尽可能地在代码中清晰地表达意图。例如，使用`const`关键字明确函数不会修改对象状态，使用标准库函数如`std::find`替代手动循环提高代码可读性和减少错误，以及使用明确的类型和单位来表示函数参数，而不是依赖于不清晰的`double`类型。这些做法都能使得代码更易于理解和维护，同时减少错误的可能性。