

代码的预期行为通常是由开发者在编写代码时设定的。如果没有明确的说明（例如，函数或变量的名称，或者代码注释），那么其他人可能无法准确地理解代码的预期行为。

### 函数名

例如，考虑以下 C++ 代码片段：

```cpp
int calculate(int a, int b) {
    return a + b;
}
```

从这个函数的名称`calculate`来看，我们无法确定它的具体行为。它可能是用来计算两个数的和，也可能是用来计算两个数的差，乘积，或者其他什么。只有当我们查看函数的实现，我们才能确定这个函数是用来计算两个数的和的。

但是，如果我们将函数名改为`add`，那么就能明确地知道这个函数的预期行为是计算两个数的和，即使我们没有看到函数的实现。

```cpp
int add(int a, int b) {
    return a + b;
}
```

同样，如果我们在函数上添加适当的注释，那么即使函数的名称不够明确，其他人也能理解这个函数的预期行为。

```cpp
// 计算两个数的和
int calculate(int a, int b) {
    return a + b;
}
```

因此，为了使代码的预期行为更容易被理解，我们应该尽可能地使用描述性的名称，并在必要时添加适当的注释。


### 遍历集合

在遍历集合时，如何更好地表达代码的意图和避免潜在的错误。

首先，考虑这段代码：

```cpp
gsl::index i = 0;
while (i < v.size()) {
    // ... 对 v[i] 做一些事情 ...
}
```

这段代码使用了一个索引 `i` 来遍历集合 `v`。但是，这种方式并没有明确表达出只是遍历 `v` 的元素的意图。此外，索引的实现细节被暴露出来，这可能导致误用。最后，`i` 在循环结束后仍然存在，这可能是或可能不是预期的。

更好的方式是使用范围 for 循环：

```cpp
for (const auto& x : v) { /* 对 x 的值做一些事情 */ }
```

这段代码明确表示了我们只是遍历 `v` 的元素。此外，我们使用 `const` 引用 `x` 来访问元素，这样就无法意外地修改元素的值。如果我们想要修改元素的值，我们可以去掉 `const`：

```cpp
for (auto& x : v) { /* 修改 x */ }
```

有时候，使用命名的算法可能是更好的选择。例如，我们可以使用 `for_each` 算法来遍历集合：

```cpp
for_each(v, [](int x) { /* 对 x 的值做一些事情 */ });
for_each(par, v, [](int x) { /* 对 x 的值做一些事情 */ });
```

这两个例子都使用了 `for_each` 算法来遍历 `v`。第一个例子是单线程遍历，第二个例子是多线程遍历。在第二个例子中，我们使用了 `par` 参数来表示我们对 `v` 的元素的处理顺序不感兴趣，这意味着算法可以在多个线程中并行处理 `v` 的元素。


### 参数设计

当函数的参数列表包含多个相同类型的参数时，往往会使代码的阅读者感到困惑，因为他们可能不清楚每个参数的具体含义。

例如，考虑以下函数：

```cpp
void draw_line(int, int, int, int);
```

这个函数接受四个 `int` 参数，但是从函数签名中我们无法确定这四个参数的具体含义。它们可能代表两个二维点的坐标 `(x1, y1, x2, y2)`，也可能代表一个点的坐标和高度宽度 `(x, y, h, w)`，或者其他的含义。为了理解这个函数的行为，我们可能需要查阅相关的文档。

相反，如果我们使用自定义的数据类型（例如，一个表示二维点的 `Point` 类），那么函数的签名就会变得更加清晰：

```cpp
void draw_line(Point, Point);
```

这个函数接受两个 `Point` 参数，从函数签名中我们可以清楚地看出，这两个参数代表的是两个二维点。这样，代码的阅读者就可以更容易地理解这个函数的行为，而无需查阅相关的文档。



