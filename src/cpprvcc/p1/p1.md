# Optional

使用 `std::optional` 来完善代码，具体变更可查看这个 commit ： [feat: add optional handling for command line argument.](https://github.com/rainjw/cpprvcc/commit/83c7f73990aec964f50ef29070ee95826ff929de)

## 简介

接下来结合具体的例子来讲解，`std::optional` 是 C++17 中引入的标准库类型，用于表示一个可能存在也可能不存在的值。它是一种用于处理可能缺失值的封装，比传统的使用特殊值或指针表示缺失状态的方法更加类型安全、清晰、并提供更多的操作和语法糖。

`std::optional` 是一个模板类，可以包含一个值或者不包含任何值。在包含值的情况下，可以通过 `value()` 成员函数来获取这个值；在不包含值的情况下，可以使用 `std::nullopt` 表示。它可以避免一些使用特殊值（例如 -1）或指针来表示缺失状态的问题。

```cpp
#include <iostream>
#include <optional>

// 函数返回 std::optional<int>，可能有值或者无值
std::optional<int> divide(int numerator, int denominator) {
    if (denominator != 0) {
        return numerator / denominator;
    } else {
        return std::nullopt;  // 表示无值
    }
}

int main() {
    // 尝试除法运算
    auto result = divide(10, 2);

    // 检查是否有值
    if (result.has_value()) {
        std::cout << "Result of division: " << result.value() << std::endl;
    } else {
        std::cout << "Error: Cannot divide by zero." << std::endl;
    }

    return 0;
}
```

在这个例子中，`divide` 函数返回一个 `std::optional<int>`，表示除法运算的结果。在 `main` 函数中，我们通过 `has_value()` 检查是否有值，然后使用 `value()` 来获取值。这样的设计可以避免未定义行为，并更加清晰地表达可能缺失的状态。

## Option 的优势

让我们通过一个具体的例子来说明 `std::optional` 的优势。考虑一个函数，它尝试从字符串中提取整数，并返回提取到的整数，或者在提取失败时返回一个特殊值 -1。

**使用特殊值表示失败的方式：**

```cpp
#include <iostream>

int extractInteger(const std::string& str) {
    size_t pos;
    int result = std::stoi(str, &pos);

    if (pos != str.size()) {
        // 提取失败，返回特殊值 -1
        return -1;
    }

    return result;
}

int main() {
    std::string input = "123";

    int extractedValue = extractInteger(input);

    if (extractedValue == -1) {
        std::cerr << "Error: Failed to extract integer from the string.\n";
    } else {
        std::cout << "Extracted integer: " << extractedValue << "\n";
    }

    return 0;
}
```

**使用 `std::optional` 的方式：**

```cpp
#include <iostream>
#include <optional>

std::optional<int> extractInteger(const std::string& str) {
    size_t pos;
    int result = std::stoi(str, &pos);

    if (pos != str.size()) {
        // 提取失败，返回空的 std::optional
        return std::nullopt;
    }

    return result;
}

int main() {
    std::string input = "123";

    // 尝试从字符串中提取整数
    auto extractedValue = extractInteger(input);

    // 检查是否提取成功
    if (extractedValue.has_value()) {
        std::cout << "Extracted integer: " << extractedValue.value() << "\n";
    } else {
        std::cerr << "Error: Failed to extract integer from the string.\n";
    }

    return 0;
}
```

**优势解释：**

1. **清晰性：** 使用 `std::optional` 的方式更加清晰，直接表达了可能缺失值的语义。读者不需要记住特殊的返回值 -1，而是通过 `std::optional` 的 API 来检查和获取值。

2. **类型安全：** `std::optional` 提供了类型安全的方式来表示可能不存在的值，避免了使用特殊值的类型混淆和错误。

3. **更多的操作：** 使用 `std::optional` 可以方便地使用其成员函数，例如 `has_value()` 和 `value()`，提供了更多的操作方式。

4. **异常安全性：** `std::optional` 的方式避免了抛出异常来表示失败，使得代码更加稳定和容错。

总体而言，`std::optional` 在这个例子中提供了更加清晰、安全、灵活的方式来处理可能缺失的值。


