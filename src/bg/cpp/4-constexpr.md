# constexpr 、consteval 的作用？

`constexpr` 是 C++11 引入的一个关键字，用于定义常量表达式。`constexpr` 的主要作用是指示编译器在编译时计算表达式的值，从而使得该值在编译时就已经确定。使用 `constexpr` 可以创建编译时的常量，还可以定义能够在编译时计算结果的函数。

### 作用

1. **编译时常量**：使用 `constexpr` 定义的变量必须在编译时就能确定其值。

2. **编译时函数求值**：`constexpr` 函数能够在编译时进行计算，只要其所有参数都是编译时常量。

3. **模板和类型安全**：`constexpr` 在模板编程和元编程中非常有用，它确保了类型安全，并能在编译时进行复杂的计算。

4. **性能优化**：`constexpr` 可以减少运行时的计算，因为相关计算已经在编译时完成。

### 示例

#### 编译时常量

```cpp
constexpr int max_size = 100;  // 编译时常量
int array[max_size];           // 使用常量定义数组大小
```

这里，`max_size` 是一个编译时常量，可以用作数组的大小，这是因为其值在编译时就已经确定了。

#### 编译时函数

```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : (n * factorial(n - 1));
}

int main() {
    constexpr int fac_5 = factorial(5); // 编译时计算 5 的阶乘
    int array[fac_5];                  // 使用结果作为数组大小
    return 0;
}
```

这个示例中的 `factorial` 函数是一个 `constexpr` 函数，能够在编译时计算阶乘。因此，`fac_5` 是一个编译时常量，其值为 `5!`（即 120），可以用于定义数组的大小。

### 总结

`constexpr` 是 C++ 中的一个强大特性，允许在编译时进行计算，从而提供性能优化和类型安全。它对于编写高效、类型安全的模板代码尤为重要。通过在编译时执行更多的计算，`constexpr` 可以减少运行时的负担，使得程序更加高效。

要判断一个表达式是否能在编译时计算，关键在于检查其是否完全由常量、常量表达式、constexpr 变量/函数构成，并且其操作符也支持在编译时求值。编译器的具体实现和优化策略也会影响是否能在编译时计算表达式。



## consteval 的作用，和 constexpr 的区别？

`consteval` 和 `constexpr` 都是 C++ 中用于编译时计算的关键字，但它们有一些重要的区别。

### consteval

1. **引入时间**: `consteval` 是在 C++20 引入的。
2. **含义**: `consteval` 指定的函数必须在编译时进行求值。
3. **限制**: 如果一个 `consteval` 函数在编译时不能被求值，那么会产生一个编译错误。
4. **用途**: `consteval` 用于创建那些一定需要在编译时求值的函数，比如用于元编程或者生成编译时常量。

### constexpr

1. **引入时间**: `constexpr` 是在 C++11 引入的，后续的标准中进行了扩展。
2. **含义**: `constexpr` 指示一个函数或对象可能在编译时求值。
3. **灵活性**: `constexpr` 函数或对象可以在编译时也可以在运行时求值。如果编译器能够在编译时求值，它通常会这样做；否则，该函数或对象就会在运行时求值。
4. **用途**: `constexpr` 用于创建可以在编译时或运行时求值的函数或对象，提供了更大的灵活性。

### 区别总结

- **编译时求值的强制性**: `consteval` 强制其函数在编译时求值，而 `constexpr` 则不强制。
- **应用场景**: `consteval` 用于那些必须在编译时求值的场景，而 `constexpr` 更适用于那些编译时求值能带来性能优化但非必需的情况。
- **错误处理**: 如果 `consteval` 函数不能在编译时求值，将导致编译错误；而 `constexpr` 函数则会退化为普通函数，在运行时求值。

简而言之，`consteval` 保证了函数必定在编译时求值，而 `constexpr` 提供了在编译时求值的可能性，但并非强制性的。