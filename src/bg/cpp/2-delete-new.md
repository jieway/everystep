# new / delete 改进了 malloc / free 的哪些问题？

`new` 和 `delete` 在C++中被引入，以改进C语言中使用 `malloc` 和 `free` 进行动态内存分配和释放的方法。这些改进主要包括以下几个方面：

1. **类型安全**：
   - `new` 自动计算所需内存的大小，而 `malloc` 需要显式地指定字节数。这减少了因错误计算大小而导致的错误。
   - `new` 直接返回正确的类型指针，无需像 `malloc` 那样需要进行类型转换。

2. **构造函数和析构函数**：
   - `new` 在分配内存时会自动调用对象的构造函数，而 `delete` 会调用析构函数。这确保了对象正确地进行初始化和清理。
   - 相比之下，`malloc` 和 `free` 只是分配和释放内存，不会调用构造函数或析构函数。

3. **异常处理**：
   - `new` 在内存分配失败时会抛出异常（`std::bad_alloc`），这提供了一种处理内存分配失败的标准方法。
   - `malloc` 在内存分配失败时返回 `nullptr`，需要显式检查返回值。

4. **重载**：
   - `new` 和 `delete` 可以被重载，这意味着开发者可以改变它们的行为以适应特定需求。
   - `malloc` 和 `free` 是标准库函数，不能被重载。

5. **内存对齐**：
   - `new` 通常保证返回正确对齐的内存地址，适合对象的对齐要求。
   - `malloc` 可能需要额外的处理来确保内存对齐。

**示例代码**：

```cpp
class MyClass {
public:
    MyClass() {
        // 构造函数代码
    }
    ~MyClass() {
        // 析构函数代码
    }
};

// 使用 new 和 delete
MyClass *obj = new MyClass; // 分配内存并调用构造函数
delete obj;                 // 调用析构函数并释放内存

// 使用 malloc 和 free
MyClass *obj = (MyClass *)malloc(sizeof(MyClass)); // 只分配内存
// 需要显式调用构造函数
free(obj); // 只释放内存
// 需要显式调用析构函数
```

总结来说，`new` 和 `delete` 提供了更安全、更自动化的方式来处理动态内存，特别是在涉及到对象构造和析构的情况下。