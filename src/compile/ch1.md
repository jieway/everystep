# 第一章：什么是编译

## 1.1 什么是编译？

语言大致分为高级语言，汇编语言，机器语言三种类型。

编译是指将**高级语言**编译成**机器语言**或者**汇编语言**的过程，也就是翻译！

* 机器语言本质上是由 0/1 组成的序列。
* 汇编语言在机器语言的基础上添加了助记符，提高了编写效率，但是依旧繁琐。
* 高级语言提供了更方便人类使用的语法规则，而且汇编语言依赖机器，而高级语言避免了这一点。

## 1.2 编译系统的流程？

拿到一个源程序后要先进行词法分析，输入是句子，输出是单词序列。

然后进行语法分析，上一步的输出作为语法分析的输入。将单词序列转换成语法树。目的是明确单词与单词之间的结构。

之后再进行语义分析，明确含义。

**源语言**就是要翻译的语言，**目标语言**就是最终要生成的语言，目标语言既可以是**机器语言**也可以是**汇编语言**。

总的来看编译分为**语义分析**和**生成**目标语言两部分。

语法分析：语义分析是以句子为单位，而语法分析的粒度较细，针对短语进行分析。

词法分析：词法分析是以单词为单位进行分析，也就是分析词性。 

自底向上：词法分析 => 语法分析 => 语义分析。
 
语法制导分析（Syntax Directed Translation）：将语法分析，语义分析，中间代码生成三个阶段综合到一起。

## 1.3 编译前端后端

编译过程也分为**前端**（front end）和**后端**（back end）。

区别在于所有与**源语言**相关的部分都属于前端 ，所有与**目标代码**相关的部分都属于后端。

前端和后端中间还存在一个其他语言的层次，起到桥梁作用。

编译前端和后端的划分是为了可移植性。

## 1.3 词法分析

词法分析是编译的第一个阶段！

源代码本身是由单词组成的字符集，而词法分析是将字符集中的单词识别出来并转换成统一的**机内表示**，也就是词法单元（token）形式。

token: <种别码，属性值> 

单词存在五种类型：
* 关键字：例如 if else 等，一词一码。
* 标识符：变量名，数组名等，多次一码。
* 常量：整型，浮点型等，虽然常量有无穷，但是可以根据类型来编码，也就是一型一码。
* 运算符：算术，关系，逻辑，一词一码或一型一码。
* 界限符：() ; = 等 ，一词一码。

一词一码类型的单词是用不到 token 属性值的，只用到了种别码。

一型一码因为存在同一个码存在多个关键字，所有需要用**属性值**来进一步的区分。

如何将源代码转换成 token 序列？（第三章）

## 1.4 语法分析

* <D> declare（缩写）
* <T> type 
* <IDS> identity sequence 

语法分析器如何根据语法规则将输入的 token 生成语法分析树？（第四章）

## 1.5 语义分析

语义分析会收集一些属性信息。
* 种属
* 类型
* 存储位置，长度
* 值
* 作用域
* 参数和返回值信息

以上属性信息会存入一张**符号表**中。

语义检查，将会检查一些语法方面的错误。

## 1.6 中间代码生成和编译后端

有两种类型，三地址码，语法结构树/语法树（和语法分析树不同）。

四元式 $(op,y,z,x)$ op 是操作符，y 和 z 是原操作数，x 是目标操作数。如何该操作数不存在用下划线（_）表示。

例如 $x = y op z => (op,y,z,x)$ $x = op y => (op,y,\_,x)$

一个三地址制定序列唯一确定了运算完成的顺序。

编译器如何根据分析树生成中间代码？（第六章）

目标代码生成：将中间语言映射到目标语言，为变量合理分配寄存器。

代码优化：分为机器无关优化和机器相关优化，区别在于前者是在中间代码层面，后者则是在目标代码层面

## 1.5 编译分为多遍

一遍编译分为多遍。每一遍可以针对某个阶段，也可以不对应。

单遍的代码往往效率不高。

## 1.6 