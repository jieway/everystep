
下面是一些阅读**命令行艺术**的笔记，原文只是列了一个大纲告诉你需要了解哪些内容可以更顺手的使用 Linux 系统，但是还需要自己进一步的去查询。本文是原文的基础上整理归纳，将难以理解的地方展开讲解，补充了一些常见的使用场景和使用示例。

## 遇到不会的命令如何使用 help ？

建议直接问 GPT ，下面是传统的做法，可以用来交叉验证，毕竟 GPT 有胡说八道的可能。🤬

在 Unix 和 Linux 系统中，`man`，`apropos` 和 `help` 是非常有用的命令，它们可以帮助我们查找和理解其他命令的用法。

- `man`：这个命令用于查看手册页。例如，`man ls` 会显示 `ls` 命令的手册页。这个手册页包含了命令的描述，选项和用法等信息。

- `apropos`：这个命令用于搜索手册页。例如，`apropos copy` 会显示所有与 `copy` 相关的手册页。这个命令非常有用，当你不确定应该使用哪个命令时，你可以使用 `apropos` 来查找相关的命令。

- `help`：这个命令用于查看 Bash 内置命令的帮助信息。例如，`help cd` 会显示 `cd` 命令的帮助信息。如果你想查看所有的 Bash 内置命令，你可以使用 `help -d` 命令。

- `type`：这个命令用于查看命令的类型。例如，`type ls` 会显示 `ls` 是一个可执行文件，`type cd` 会显示 `cd` 是一个 shell 内置命令。这个命令非常有用，当你不确定一个命令是可执行文件、shell 内置命令还是别名时，你可以使用 `type` 命令来查看。

这些命令都是在命令行中使用的，你可以在任何时候使用这些命令来查找和理解其他命令的用法。

## 重定向

在 Unix 和 Linux 系统中，我们可以使用 `>`，`<` 和 `|` 来重定向输入和输出。这些符号允许我们控制命令行程序的输入和输出。

- `>`：这个符号用于重定向输出。它会将命令的输出写入到一个文件中，如果文件已经存在，它会被覆盖。例如，`ls > file.txt` 会将 `ls` 命令的输出写入到 `file.txt` 文件中。

- `>>`：这个符号也用于重定向输出，但是它会将输出追加到一个已经存在的文件的末尾，而不是覆盖它。例如，`ls >> file.txt` 会将 `ls` 命令的输出追加到 `file.txt` 文件的末尾。

- `<`：这个符号用于重定向输入。它会将文件的内容作为命令的输入。例如，`sort < file.txt` 会将 `file.txt` 文件的内容作为 `sort` 命令的输入。

- `|`：这个符号用于管道。它会将一个命令的输出作为另一个命令的输入。例如，`ls | sort` 会将 `ls` 命令的输出作为 `sort` 命令的输入。

- 使用 `find` 命令查找特定的文件，然后使用 `xargs` 命令删除它们：`find . -name "*.tmp" | xargs rm`。这个命令会在当前目录及其子目录中查找所有以 ".tmp" 结尾的文件，然后删除它们。

- 使用 `sort` 和 `uniq` 命令删除重复的行：`sort file.txt | uniq > output.txt`。这个命令会将 `file.txt` 文件的内容排序，然后删除重复的行，最后将结果写入到 `output.txt` 文件中。

- 使用 `grep` 命令搜索特定的文本：`cat file.txt | grep "search term"`。这个命令会将 `file.txt` 文件的内容作为 `cat` 命令的输入，然后将 `cat` 命令的输出作为 `grep` 命令的输入，搜索包含 "search term" 的行。

在 Unix 和 Linux 系统中，我们有两种类型的输出：标准输出（stdout）和标准错误（stderr）。默认情况下，这两种输出都会被发送到终端。我们可以使用 `>` 和 `>>` 来重定向这两种输出，但是需要注意的是，这两个符号只能重定向标准输出。如果我们想要重定向标准错误，我们需要使用 `2>` 和 `2>>`。例如，`command 2> error.txt` 会将 `command` 命令的标准错误输出重定向到 `error.txt` 文件中。

## 通配符

在 Unix 和 Linux 系统中，我们可以使用通配符 `*`，`?` 和 `[...]` 来匹配文件和目录。这些通配符可以在很多命令中使用，例如 `ls`，`rm`，`cp` 等。

`*`：这个通配符可以匹配任何数量的任何字符。例如，`ls *.txt` 会列出所有以 `.txt` 结尾的文件。

复制所有 `.txt` 文件到另一个目录：`cp *.txt /path/to/destination/`。这个命令会将当前目录下所有以 `.txt` 结尾的文件复制到 `/path/to/destination/` 目录。

`?`：这个通配符可以匹配任何单个字符。例如，`ls ?.txt` 会列出所有只有一个字符并且以 `.txt` 结尾的文件。

删除所有只有一个字符的 `.txt` 文件：`rm ?.txt`。这个命令会删除所有只有一个字符并且以 `.txt` 结尾的文件。

`[...]`：这个通配符可以匹配方括号中的任何一个字符。例如，`ls [abc].txt` 会列出名为 `a.txt`，`b.txt` 和 `c.txt` 的文件。

列出所有以 `a`，`b` 或 `c` 开头的文件：`ls [abc]*`。这个命令会列出所有以 `a`，`b` 或 `c` 开头的文件。

使用单引号 `'` 处理包含特殊字符的字符串：`echo 'Hello, $USER'`。这个命令会输出 `Hello, $USER`，而不是 `Hello,` 后面跟着当前用户的用户名。因为在单引号中，所有字符都会被视为普通字符，不会被解析为特殊字符。单引号会保留字符串中的所有字符的字面值，即它会禁止所有的转义序列和变量替换。

`"`：双引号会保留字符串中的大部分字符的字面值，但是它会允许变量替换和某些转义序列。例如，如果你在终端中输入 `echo "$HOME"`，它会输出 `$HOME` 这个环境变量的值，例如 `/home/username`。这是因为在双引号中，`$` 符号表示变量替换，它会将 `$HOME` 替换为这个环境变量的值。

使用双引号 `"` 处理包含特殊字符的字符串：`echo "Hello, $USER"`。这个命令会输出 `Hello,` 后面跟着当前用户的用户名。因为在双引号中，某些特殊字符（例如 `$`）会被解析，而不是被视为普通字符。

在 Unix 和 Linux 系统中，我们可以使用单引号 `'` 和双引号 `"` 来处理包含特殊字符的字符串。这两种引号的处理方式有所不同。

这两种引号的主要区别在于是否允许变量替换和转义序列。在单引号中，所有的字符都被视为字面值，不会进行任何转义或替换。而在双引号中，某些字符，例如 `$` 和 `\`，有特殊的含义，它们可以用于变量替换和转义序列。

这些特性使得我们可以更灵活地处理文件和目录，以及处理包含特殊字符的字符串。

## Bash 中的任务管理工具

在 Unix 和 Linux 系统中，Bash 提供了一套强大的任务管理工具，可以帮助我们在后台运行任务，暂停任务，恢复任务，查看任务状态，以及结束任务。以下是一些使用示例和使用场景：

### 后台执行任务

- `&`：这个符号可以让我们在后台运行任务。例如，`python script.py &` 会在后台运行 `script.py` 脚本。

在 Unix 和 Linux 系统中，`&` 符号通常用于以下场景：

1. 长时间运行的任务：如果你有一个需要运行很长时间的任务，例如数据分析或者大规模的文件处理，你可能希望在后台运行这个任务，这样你就可以在等待任务完成的同时做其他的事情。

2. 多任务处理：如果你需要同时运行多个任务，你可以使用 `&` 符号在后台运行这些任务。这样，你可以在一个任务运行的同时开始另一个任务。

3. 服务器脚本：在服务器环境中，你可能需要运行一些持续运行的脚本或服务，例如 Web 服务器或数据库服务器。这些脚本或服务通常在后台运行，这样它们就可以在用户退出终端后继续运行。

例如，如果你有一个 Python 脚本 `script.py`，这个脚本需要运行很长时间，你可以使用以下命令在后台运行这个脚本：

```bash
python script.py &
```

这个命令会立即返回，你可以继续在终端中输入其他的命令。你的 Python 脚本会在后台运行，直到它完成。

### 如何查看任务状态？

`jobs`：这个命令可以让我们查看当前所有的任务和它们的状态。例如，我们可以运行 `jobs` 命令来查看所有的任务。

在 Unix 和 Linux 系统中，`jobs` 命令用于列出当前 shell 中的所有后台任务。这个命令非常有用，特别是当你在一个终端会话中启动了多个后台任务时。

例如，假设你在终端中启动了两个 Python 脚本在后台运行：

```bash
python script1.py &
python script2.py &
```

然后，你可以使用 `jobs` 命令来查看这两个任务的状态：

```bash
jobs
```

输出可能如下：

```bash
[1]  - running    python script1.py
[2]  + running    python script2.py
```

这个输出告诉你，你有两个后台任务正在运行。`[1]` 和 `[2]` 是任务的编号，你可以使用这些编号来引用这些任务，例如使用 `fg` 命令将任务移到前台，或者使用 `kill` 命令结束任务。

这个命令在你需要管理多个后台任务时非常有用，例如你可能需要检查哪些任务仍在运行，或者你可能需要将某个任务移到前台来查看它的输出或者交互式地控制它。

### 任务前后台如何切换？

在 Unix 和 Linux 系统中，`fg`，`bg` 和 `kill` 命令是任务管理的重要工具，它们可以帮助我们在前台和后台之间切换任务，以及结束任务。以下是一些具体的使用示例和使用场景：

1. 假设你正在运行一个需要很长时间的 Python 脚本 `long_script.py`，你可以使用 `&` 符号在后台运行这个脚本：

```bash
python long_script.py &
```

2. 然后，你可以使用 `jobs` 命令查看当前所有的后台任务：

```bash
jobs
```

输出可能如下：

```bash
[1]  + running    python long_script.py
```

3. 如果你想将这个后台运行的任务移到前台来查看它的输出或者交互式地控制它，你可以使用 `fg` 命令：

```bash
fg %1
```

这个命令会将任务 1 移到前台来继续运行。

4. 如果你想暂停这个前台运行的任务，并将其移到后台继续运行，你可以首先按下 **ctrl-z** 来暂停这个任务，然后使用 `bg` 命令：

```bash
bg %1
```

这个命令会让任务 1 在后台继续运行。

5. 如果你想结束这个任务，你可以使用 `kill` 命令：

```bash
kill %1
```

这个命令会结束任务 1。

以上就是在 Unix 和 Linux 系统中使用 `fg`，`bg` 和 `kill` 命令的一些具体的使用示例和使用场景，希望对你有所帮助。

### 如何取消和暂停任务？

**ctrl-z** 和 **ctrl-c** 都是 Unix 和 Linux 系统中常用的命令行快捷键，但它们的功能是不同的：

- **ctrl-z**：这个快捷键用于暂停当前正在运行的任务，并将其放入后台。这意味着任务并没有被终止，而是被暂停了，你可以随时使用 `fg` 命令将其恢复到前台继续运行。

- **ctrl-c**：这个快捷键用于终止当前正在运行的任务。这意味着任务会被立即停止，无法恢复。如果你需要重新运行这个任务，你需要重新启动它。

所以，主要的区别在于，**ctrl-z** 是暂停任务，而 **ctrl-c** 是终止任务。

## SSH

SSH (Secure Shell) 是一种网络协议，用于安全地连接到远程服务器。以下是如何使用 SSH 进行远程命令行登录的基本步骤：

1. 首先，你需要在本地机器上生成 SSH 密钥对。你可以使用 `ssh-keygen` 命令来生成密钥对。这将生成一个公钥和一个私钥。

```bash
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
```

2. 然后，你需要将公钥添加到远程服务器的 `~/.ssh/authorized_keys` 文件中。你可以使用 `ssh-copy-id` 命令来完成这个任务。

```bash
ssh-copy-id user@remote_host
```

3. 现在，你应该能够使用 SSH 命令来登录到远程服务器，而无需输入密码。

```bash
ssh user@remote_host
```

SSH Agent 是一个帮助管理私钥的程序，它可以记住你的私钥和密码，所以你不需要每次使用 SSH 时都输入密码。以下是如何使用 `ssh-agent` 和 `ssh-add` 命令来实现基础的无密码认证登录：

1. 首先，你需要启动 SSH Agent。在大多数系统中，SSH Agent 会在启动时自动运行。你可以使用 `ssh-agent` 命令来启动它。

```bash
eval "$(ssh-agent -s)"
```

2. 然后，你可以使用 `ssh-add` 命令将你的私钥添加到 SSH Agent 中。这样，当你使用 SSH 命令时，SSH Agent 就会自动提供你的私钥，而无需你手动输入。

```bash
ssh-add ~/.ssh/id_rsa
```

现在，你应该能够使用 SSH 命令来登录到远程服务器，而无需输入密码。

## 文件管理工具

文件管理工具是在命令行环境中操作和管理文件和目录的重要工具。以下是一些基本的文件管理命令的使用示例和场景：

### 列出目录中的文件

`ls` 和 `ls -l`：`ls` 命令用于列出目录中的文件和子目录。`ls -l` 命令以长格式列出文件和目录的详细信息，包括文件类型、权限、链接数、所有者、组、大小、最后修改时间和文件名。例如：

例如，假设我们有一个目录，其中包含两个文件：`file1.txt` 和 `file2.txt`。

如果我们运行 `ls` 命令，输出可能如下：

```bash
file1.txt  file2.txt
```

这只显示了目录中的文件名。

然而，如果我们运行 `ls -l` 命令，输出可能如下：

```bash
-rw-r--r--  1 user  staff  0 Jan  1 00:00 file1.txt
-rw-r--r--  1 user  staff  0 Jan  1 00:00 file2.txt
```

这里，每一行都对应一个文件或目录，每一列的信息如下：

- 第一列显示文件权限。
- 第二列显示链接数。
- 第三列显示文件所有者。
- 第四列显示文件所属的组。
- 第五列显示文件大小（以字节为单位）。
- 第六、七、八列显示文件最后修改的日期和时间。
- 最后一列显示文件或目录的名称。

因此，`ls -l` 命令提供了比 `ls` 命令更详细的文件和目录信息。

### 查看文件内容

`less` 命令是一个非常有用的工具，用于在命令行环境中查看文件内容。它的主要优点是可以向前和向后浏览文件，这在查看大文件时特别有用。

例如，假设我们有一个名为 `log.txt` 的日志文件，我们想查看其内容。我们可以使用以下命令：

```bash
less log.txt
```

这将打开 `log.txt` 文件，并显示其内容。你可以使用以下键来导航：

- `空格键` 或 `Page Down` 键向下翻页。
- `b` 键或 `Page Up` 键向上翻页。
- `上箭头` 和 `下箭头` 键可以逐行滚动。
- `/` 键后跟一个字符串可以在文件中搜索该字符串。
- `q` 键退出 `less` 命令。

这些是 `less` 命令的基本使用方法，它是 Linux 文件查看和导航的重要工具。

`head` 和 `tail`：`head` 命令用于显示文件的前几行，`tail` 命令用于显示文件的最后几行。`tail -f` 命令用于实时查看文件的更新。例如：

```bash
head filename
tail filename
tail -f filename
```

### 软链接和硬链接

`ln` 和 `ln -s` 命令用于在 Unix-like 系统中创建链接。链接是文件系统中的一个重要概念，它允许一个文件名引用另一个文件的数据。

硬链接 (`ln`) 是指向文件数据的指针。创建硬链接的命令格式为 `ln source_file hard_link`。这将创建一个名为 `hard_link` 的新条目，它和 `source_file` 指向同一块数据。例如，如果我们有一个名为 `file1.txt` 的文件，我们可以创建一个硬链接 `file2.txt`，如下：

```bash
ln file1.txt file2.txt
```

现在，`file1.txt` 和 `file2.txt` 都指向同一块数据。如果我们修改其中一个文件的内容，另一个文件的内容也会改变。

软链接（也称为符号链接或 symlink）是指向另一个链接的指针。创建软链接的命令格式为 `ln -s source_file soft_link`。这将创建一个名为 `soft_link` 的新条目，它指向 `source_file`。例如，如果我们有一个名为 `file1.txt` 的文件，我们可以创建一个软链接 `file2.txt`，如下：

```bash
ln -s file1.txt file2.txt
```

现在，`file2.txt` 是 `file1.txt` 的软链接。如果我们打开 `file2.txt`，我们会看到 `file1.txt` 的内容。但是，如果我们删除 `file1.txt`，`file2.txt` 将变成一个指向不存在的文件的链接。

总的来说，硬链接和软链接都是链接，但它们的工作方式略有不同。硬链接是指向文件数据的指针，而软链接是指向另一个链接的指针。

### 文件权限

`chown` 和 `chmod`：`chown` 命令用于更改文件的所有者，`chmod` 命令用于更改文件的权限。

例如，假设我们有一个名为 `file.txt` 的文件，我们想将其所有者更改为 `user1`，我们可以使用以下命令：

```bash
chown user1 file.txt
```

现在，`file.txt` 的所有者是 `user1`。

`chmod` 命令用于更改文件或目录的权限。权限分为三组：用户（u）、组（g）和其他（o）。每组权限可以有读（r）、写（w）和执行（x）权限。权限可以用数字表示，读（r）为4，写（w）为2，执行（x）为1。

例如，如果我们想给 `file.txt` 的用户设置读、写和执行权限，给组设置读和执行权限，给其他设置只读权限，我们可以使用以下命令：

```bash
chmod 754 file.txt
```

现在，`file.txt` 的权限被设置为 `rwxr-xr--`。

### 文件磁盘使用情况

`du`：`du` 命令用于查看文件和目录的磁盘使用情况。`du -hs *` 命令用于查看当前目录下所有文件和目录的大小。

例如，如果我们想查看 `file.txt` 的大小，我们可以使用以下命令：

```bash
du file.txt
```

这将显示 `file.txt` 的大小（以字节为单位）。

如果我们想查看当前目录下所有文件和目录的大小，我们可以使用以下命令：

```bash
du -hs *
```

这将显示当前目录下每个文件和目录的大小，以及总大小。`-h` 选项使得大小以人类可读的格式（如 K、M、G）显示，`-s` 选项使得只显示总大小，不显示每个子目录的大小。

### 管理文件系统

`df`，`mount`，`fdisk`，`mkfs`，`lsblk` 这些命令都是用于管理文件系统的重要工具。以下是这些命令的使用示例和场景：

1. `df`：`df` 命令用于显示磁盘空间的使用情况。例如，如果我们想查看系统中所有文件系统的磁盘使用情况，我们可以使用以下命令：

```bash
df
```

这将显示每个文件系统的总空间、已用空间、可用空间和使用百分比。

2. `mount`：`mount` 命令用于挂载文件系统。例如，如果我们有一个设备 `/dev/sda1`，我们想将其挂载到 `/mnt` 目录，我们可以使用以下命令：

```bash
mount /dev/sda1 /mnt
```

现在，`/dev/sda1` 的内容可以在 `/mnt` 目录中访问。

3. `fdisk`：`fdisk` 命令用于查看和管理磁盘分区。例如，如果我们想查看 `/dev/sda` 磁盘的分区情况，我们可以使用以下命令：

```bash
fdisk /dev/sda
```

这将进入 `fdisk` 的交互模式，我们可以在这里查看、创建、删除和修改分区。

4. `mkfs`：`mkfs` 命令用于格式化分区。例如，如果我们有一个分区 `/dev/sda1`，我们想将其格式化为 `ext4` 文件系统，我们可以使用以下命令：

```bash
mkfs -t ext4 /dev/sda1
```

现在，`/dev/sda1` 分区已经被格式化为 `ext4` 文件系统。

5. `lsblk`：`lsblk` 命令用于列出所有可用的块设备。例如，如果我们想查看系统中所有的块设备，我们可以使用以下命令：

```bash
lsblk
```

这将显示系统中所有的块设备，包括设备名、挂载点、文件系统类型等信息。

### 文件元数据

inode 是 Unix 和 Unix-like 系统（如 Linux）文件系统中的一个重要概念。每个文件和目录都有一个与之关联的 inode，它包含了文件的元数据，如文件大小、创建时间、所有者、文件权限等。inode 还包含了文件数据块的位置信息，这使得系统能够访问和读取文件的内容。

`ls -i` 命令可以显示文件的 inode 号。例如，如果我们有一个名为 `file.txt` 的文件，我们想查看其 inode 号，我们可以使用以下命令：

```bash
ls -i file.txt
```

这将显示 `file.txt` 文件的 inode 号。

`df -i` 命令用于显示 inode 的使用情况。它显示了文件系统的 inode 总数、已用数、可用数和使用百分比。例如，如果我们想查看系统中 inode 的使用情况，我们可以使用以下命令：

```bash
df -i
```

这将显示每个文件系统的 inode 总数、已用数、可用数和使用百分比。

inode 的概念对于理解 Unix 和 Unix-like 系统的文件系统非常重要。它是文件系统如何组织和访问文件的基础。

## 网络

`ip` 和 `ifconfig` 是用于管理和查看网络接口的命令，而 `dig` 是用于查询 DNS 的工具。以下是这些命令的使用示例和场景：

1. `ip` 或 `ifconfig`：这些命令用于查看和管理网络接口。例如，如果我们想查看系统中所有网络接口的信息，我们可以使用以下命令：

```bash
ip addr
```

或者

```bash
ifconfig
```

这将显示每个网络接口的信息，包括接口名、IP 地址、MAC 地址等。

如果我们想启用或禁用一个网络接口，我们可以使用以下命令：

```bash
ip link set eth0 up
ip link set eth0 down
```

或者

```bash
ifconfig eth0 up
ifconfig eth0 down
```

这将启用或禁用名为 `eth0` 的网络接口。

2. `dig`：`dig` 命令用于查询 DNS。例如，如果我们想查询 `www.example.com` 的 IP 地址，我们可以使用以下命令：

```bash
dig www.example.com
```

这将显示 `www.example.com` 的 DNS 查询结果，包括其 IP 地址。

如果我们想查询一个 IP 地址的反向 DNS 记录，我们可以使用以下命令：

```bash
dig -x 192.0.2.1
```

这将显示 `192.0.2.1` 的反向 DNS 查询结果。

这些命令是网络管理和故障排查的重要工具，对于理解和管理网络非常有帮助。

## 正则表达式

`grep` 和 `egrep` 是用于文本搜索的命令，它们支持正则表达式，可以在文件或者输入流中搜索匹配的行。以下是这些命令的使用示例和场景：

1. `-i`：这个参数表示忽略大小写。例如，如果我们想在 `file.txt` 中搜索 `hello`，不区分大小写，我们可以使用以下命令：

```bash
grep -i "hello" file.txt
```

2. `-o`：这个参数表示只输出匹配的部分，而不是整行。例如，如果我们想在 `file.txt` 中搜索 `hello`，并且只输出匹配的部分，我们可以使用以下命令：

```bash
grep -o "hello" file.txt
```

3. `-v`：这个参数表示反转匹配，也就是输出不匹配的行。例如，如果我们想在 `file.txt` 中搜索不包含 `hello` 的行，我们可以使用以下命令：

```bash
grep -v "hello" file.txt
```

4. `-A`：这个参数表示输出匹配行的后几行。例如，如果我们想在 `file.txt` 中搜索 `hello`，并且输出匹配行的后两行，我们可以使用以下命令：

```bash
grep -A 2 "hello" file.txt
```

5. `-B`：这个参数表示输出匹配行的前几行。例如，如果我们想在 `file.txt` 中搜索 `hello`，并且输出匹配行的前两行，我们可以使用以下命令：

```bash
grep -B 2 "hello" file.txt
```

6. `-C`：这个参数表示输出匹配行的前后几行。例如，如果我们想在 `file.txt` 中搜索 `hello`，并且输出匹配行的前后两行，我们可以使用以下命令：

```bash
grep -C 2 "hello" file.txt
```

`egrep` 命令和 `grep` 命令类似，但是它支持扩展的正则表达式，例如 `+`，`?` 和 `|`。

这些命令是文本处理和日志分析的重要工具，对于理解和使用正则表达式非常有帮助。

## 总结

这篇文章主要介绍了在 Unix 和 Linux 系统中一些常见命令的使用。