# 批量写入和校验和

<!-- ![章节概览](./lsm-tutorial/week2-07-overview.svg) -->

在上一章中，你已经构建了一个完整的基于 LSM 的存储引擎。在本周的最后，我们将实现一些简单但重要的存储引擎优化。欢迎来到 Mini-LSM 的第二周零食时间！

在本章中，你将：

* 实现批量写入接口。
* 在块、SST 元数据、清单和 WALs 中添加校验和。

**注意：我们没有为本章提供单元测试。只要你通过了所有之前的测试，并确保校验和在你的文件格式中正确编码，就没问题。**

## 任务 1：写入批处理接口

在此任务中，我们将通过添加写入批处理 API 为本教程的第三周做准备。你需要修改：

```
src/lsm_storage.rs
```

用户向 `write_batch` 提供一批要写入数据库的记录。这些记录是 `WriteBatchRecord<T: AsRef<[u8]>>`，因此它可以是 `Bytes`、`&[u8]` 或 `Vec<u8>`。有两种类型的记录：删除和放置。你可以像处理你的 `put` 和 `delete` 函数一样处理它们。

之后，你可以重构你原来的 `put` 和 `delete` 函数来调用 `write_batch`。

在实现此功能后，你应该通过所有之前章节的测试用例。

## 任务 2：块校验和

在此任务中，你需要在编码 SST 时在每个块的末尾添加一个块校验和。你需要修改：

```
src/table/builder.rs
src/table.rs
```

SST 的格式将更改为：

```plaintext
---------------------------------------------------------------------------------------------------------------------------
|                   块部分                     |                            元部分                           |
---------------------------------------------------------------------------------------------------------------------------
| 数据块 | 校验和 | ... | 数据块 | 校验和 | 元数据 | 元块偏移 | 布隆过滤器 | 布隆过滤器偏移 |
|   可变长度   |    u32   |     |   可变长度   |    u32   |  可变长度  |         u32       |    可变长度    |        u32          |
---------------------------------------------------------------------------------------------------------------------------
```

我们使用 crc32 作为我们的校验和算法。你可以在构建块后使用 `crc32fast::hash` 生成块的校验和。

通常，当用户在存储选项中指定目标块大小时，大小应包括块内容和校验和。例如，如果目标块大小为 4096，校验和占用 4 字节，那么实际的块内容目标大小应为 4092。然而，为了避免破坏之前的测试用例并简化，我们在本教程中，将**仍然**使用目标块大小作为目标内容大小，并简单地在块的末尾追加校验和。

当你读取块时，你应该在 `read_block` 中正确地生成块内容的切片来验证校验和。在实现此功能后，你应该通过所有之前章节的测试用例。

## 任务 3：SST 元校验和

在此任务中，你需要为布隆过滤器和块元数据添加一个块校验和：

```
src/table/builder.rs
src/table.rs
src/bloom.rs
```

```plaintext
----------------------------------------------------------------------------------------------------------
|                                                元部分                                            |
----------------------------------------------------------------------------------------------------------
| 块数量 | 元数据 | 校验和 | 元块偏移 | 布隆过滤器 | 校验和 | 布隆过滤器偏移 |
|     u32      |  可变长度  |    u32   |        u32        |    可变长度    |    u32   |        u32          |
----------------------------------------------------------------------------------------------------------
```

你需要在 `Bloom::encode` 和 `Bloom::decode` 中为布隆过滤器添加一个校验和。注意，我们的大多数 API 都接受一个现有的缓冲区，实现将写入该缓冲区，例如 `Bloom::encode`。因此，你应该在写入编码内容之前记录布隆过滤器开始的偏移量，并且只对布隆过滤器本身进行校验和，而不是对整个缓冲区进行校验和。

之后，你可以在块元数据的末尾添加一个校验和。你可能会发现在部分的开始添加一个元数据的长度很有帮助，这样在解码块元数据时就更容易知道何时停止。

## 任务 4：WAL 校验和

在此任务中，你需要修改：

```
src/wal.rs
```

我们将在预写日志中进行每记录校验和。为此，你有两个选择：

* 生成键值记录的缓冲区，并使用 `crc32fast::hash` 一次性计算校验和。
* 一次写入一个字段（例如，键长度，键切片），并使用 `crc32fast::Hasher` 逐步计算每个字段的校验和。

这取决于你的选择，你需要*选择你自己的冒险*。新的 WAL 编码应该像这样：

```
| key_len | key | value_len | value | checksum |
```

## 任务 5：清单校验和

最后，让我们在清单文件上添加一个校验和。清单与 WAL 类似，只是以前我们没有存储每个记录的长度。为了使实现更容易，我们现在在记录的开始添加一个记录长度的头部，并在记录的末尾添加一个校验和。

新的清单格式如下：

```
| len | JSON 记录 | 校验和 | len | JSON 记录 | 校验和 | len | JSON 记录 | 校验和 |
```

在实现所有内容后，你应该通过所有之前的测试用例。我们在本章中不提供新的测试用例。

## 测试你的理解

* 考虑一个只提供 `write_batch` 作为写入接口的 LSM 存储引擎（而不是单个 put + delete）。是否可以这样实现：有一个单独的写线程，带有一个 mpsc 频道接收器来获取更改，所有线程将写批次发送给写线程。写线程是写入数据库的单一点。这种实现的优点/缺点是什么？（如果你这样做，恭喜你得到了 BadgerDB！）
* 将所有块校验和一起放在 SST 文件的末尾，而不是与块一起存储，这样可以吗？为什么？

我们不提供问题的参考答案，欢迎在 Discord 社区中讨论。

## 额外任务

* **在损坏时恢复**。如果出现校验和错误，以安全模式打开数据库，以便无法执行写操作，但仍可以检索未损坏的数据。

{{#include copyright.md}}