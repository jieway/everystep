# 🐼 LSM-Tree

如何从零实现一个 LSM-Tree（Log-Structured Merge-Tree）？ 首先要弄清楚什么是 LSM-Tree ，随后将会构建一个最简易版的 LSM-Tree ，然后参考 Leveldb 一步步优化。

## 简介

要弄清楚 LSM-Tree 就不得不提 B+ 树，随着数据量的增加会导致 B+ 树叶子结点分散到不同磁盘上进而导致随机读写的概率增加。针对 B+ 树的这个问题提出了 LSM-Tree ，该结构以追加的方式写入数据，具体是如何解决的后续再详细描述。

是一种在计算机科学中用于高效存储和管理数据的数据结构。它被广泛应用于许多数据库和存储系统，特别是针对写入密集型或高吞吐量场景。

LSM-Tree 的设计主要是为了解决传统的 B 树在写入性能上的局限性。传统的 B 树需要频繁地更新磁盘上的节点，这会导致随机写入，进而影响性能。而 LSM-Tree 则通过一系列策略来优化写入性能，并在读取性能方面也有一些优势。

## 特点

下面是 LSM-Tree 的主要特点和工作原理：

1. **写入操作：** LSM-Tree 的写入操作不直接修改磁盘上的主数据结构，而是通过追加写入（append-only）的方式将数据写入到称为日志或日志文件的数据结构中。这样可以避免频繁的随机写入，提高写入性能。

2. **内存组件：** 写入的数据首先进入内存中的数据结构，通常称为 MemTable（内存表）。MemTable 是一个有序的数据结构，可以是跳表、红黑树等。写入数据首先被插入到 MemTable 中，然后周期性地将 MemTable 转换为磁盘上的一个 SSTable（Sorted String Table）文件。

3. **后台合并：** 为了保持查询性能，LSM-Tree 需要定期将内存中的数据合并到磁盘上的 SSTable 文件中。这个过程称为后台合并（Background Compaction）。通过合并和压缩操作，多个 SSTable 文件会被合并成更大的文件，以减少查询时需要搜索的文件数量。

4. **查询操作：** 查询时，LSM-Tree 首先会在 MemTable 中查找数据，如果没有找到，就会继续在不同的 SSTable 文件中查找。为了加速查询，通常会维护一个称为 Bloom Filter 的数据结构，用于快速判断某个键是否可能存在于某个 SSTable 文件中。

5. **垃圾回收：** 由于后台合并可能会产生重复的数据，LSM-Tree 需要进行垃圾回收以清理无用的数据。过时的数据会被删除，空间被释放。


- `MemTable`：内存表，用于接收写入操作的数据，通常是有序的数据结构（如跳表或红黑树）。写入的数据首先会被插入到 MemTable 中，然后定期转换为 SSTable 文件。

- `SSTable`：Sorted String Table，有序字符串表，是磁盘上的文件，包含已排序的键值对。写入 MemTable 的数据会被定期合并成 SSTable 文件，以减少查询时需要搜索的文件数量。

- `Log`：日志文件，写入操作会首先追加到日志中，保证数据不会丢失。这也提供了恢复机制，以防止在崩溃时丢失数据。

- `Background Compaction`：后台合并，定期进行的操作，将多个 SSTable 文件合并成更大的文件，以减少磁盘上的文件数量，并清理无用的数据。

通过这种结构，LSM-Tree 在写入密集型场景下能够实现较高的写入性能，同时通过后台合并和垃圾回收来维护查询性能。查询时，系统会先在 MemTable 中查找，然后在多个 SSTable 文件中查找，并利用 Bloom Filter 进行快速过滤。

总的来说，LSM-Tree 通过将写入操作优化为追加写入，并通过后台合并和垃圾回收来维护查询性能，从而在高写入负载的场景下提供了更好的性能。然而，由于后台合并和查询时需要访问多个文件，对于某些读取密集型工作负载，LSM-Tree 可能会有一些性能开销。