# 🐼 LSM-Tree

如何从零实现一个 LSM-Tree（Log-Structured Merge-Tree）？ 首先要弄清楚什么是 LSM-Tree ，随后将会构建一个最简易版的 LSM-Tree ，然后参考 Leveldb 一步步优化。

## 简介

LSM-Tree 的设计主要是为了解决传统的 B 树在写入性能上的局限性。传统的 B 树需要频繁地更新磁盘上的节点，这会导致随机写入，进而影响性能。而 LSM-Tree 则通过一系列策略来优化写入性能，并在读取性能方面也有一些优势。

LSMTree（Log-Structured Merge-Tree）是由几个关键部分组成的数据存储结构，用于实现高性能的写入操作和读取操作的平衡。以下是LSMTree的主要部分：

1. **Write-Ahead Log (WAL)：** 用于记录新写入的数据，以确保数据的持久性。写入操作首先追加到WAL中，然后异步地更新到其他部分。

2. **MemTable：** 位于内存中的有序数据结构，用于缓存写入的数据。写入操作首先被追加到MemTable中，当MemTable达到一定大小或数量限制时，它会被标记为不可修改，并转换为不可变的SSTable。

3. **SSTables (Sorted String Tables)：** 是在磁盘上存储数据的有序文件，包含范围查询所需的有序键值对。它们按键的顺序排列，便于范围查询操作。

4. **合并与压缩：** 周期性地，系统会触发SSTables的合并和压缩操作。这有助于减少数据冗余，提高读取性能，并管理磁盘空间。

5. **查询引擎：** 提供读取操作的接口，能够从WAL、MemTable和SSTables中获取数据并返回查询结果。

6. **合并策略：** 决定何时以及如何将多个较小的SSTables合并为更大的SSTable。合并策略对性能和磁盘空间的使用有重要影响。

LSMTree的基本思想是通过将写入操作追加到WAL、缓存到MemTable，然后定期合并和压缩数据到SSTables，来实现高写入吞吐量和较好的读取性能。每个部分在整个流程中都发挥着重要作用，使得LSMTree适用于写多读少的应用场景。

## 总结

通过这种结构，LSM-Tree 在写入密集型场景下能够实现较高的写入性能，同时通过后台合并和垃圾回收来维护查询性能。查询时，系统会先在 MemTable 中查找，然后在多个 SSTable 文件中查找，并利用 Bloom Filter 进行快速过滤。

整个架构的核心思想是，写入首先被追加到WAL，然后缓存到内存中的MemTable，最终以SSTable的形式持久存储在磁盘上。周期性的合并和压缩操作有助于管理SSTables，提高读取性能，以及减少磁盘空间占用。这种架构允许LSMTree在写入密集场景下获得出色的性能表现。

总的来说，LSM-Tree 通过将写入操作优化为追加写入，并通过后台合并和垃圾回收来维护查询性能，从而在高写入负载的场景下提供了更好的性能。然而，由于后台合并和查询时需要访问多个文件，对于某些读取密集型工作负载，LSM-Tree 可能会有一些性能开销。